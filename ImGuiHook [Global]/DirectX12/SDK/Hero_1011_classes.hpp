#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1011

#include "Basic.hpp"

#include "Hero_1011_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Hero_Synergy_classes.hpp"


namespace SDK
{

// Class Hero_1011.Cue_Ability_Loop_Morph
// 0x0100 (0x0F00 - 0x0E00)
class ACue_Ability_Loop_Morph final : public AMarvelCueNotify_Ability
{
public:
	struct FGameplayTag                           HulkStateTag;                                      // 0x0E00(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimerTotal;                                        // 0x0E0C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 HeroSourcePrefix;                                  // 0x0E10(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              SourceBody;                                        // 0x0E20(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              SourceHead;                                        // 0x0E28(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 HeroTargetPrefix;                                  // 0x0E30(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              TargetBody;                                        // 0x0E40(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              TargetHead;                                        // 0x0E48(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DynamicMaterialBodySlotName;                       // 0x0E50(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E5C[0x4];                                      // 0x0E5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceConstant*              BodyMorphSourceMaterial;                           // 0x0E60(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BodyMorphMask;                                     // 0x0E68(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DynamicMaterialHeadSlotName;                       // 0x0E70(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E7C[0x4];                                      // 0x0E7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceConstant*              HeadMorphSourceMaterial;                           // 0x0E80(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             HeadMorphMask;                                     // 0x0E88(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMTPositionForCurve;                            // 0x0E90(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E91[0x7];                                      // 0x0E91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MorphWeightCurve;                                  // 0x0E98(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           HeroShadowParameterNames;                          // 0x0EA0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle;                                       // 0x0EB0(0x0018)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MorphMesh;                                         // 0x0EC8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0ED0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMorphSuccess;                                     // 0x0ED8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED9[0x3];                                      // 0x0ED9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerSpent;                                        // 0x0EDC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimerFrequence;                                    // 0x0EE0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE4[0x4];                                      // 0x0EE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DynamicMaterialBody;                               // 0x0EE8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DynamicMaterialHead;                               // 0x0EF0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DynamicMaterialBodyElementIndex;                   // 0x0EF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DynamicMaterialHeadElementIndex;                   // 0x0EFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_Morph">();
	}
	static class ACue_Ability_Loop_Morph* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_Morph>();
	}
};
static_assert(alignof(ACue_Ability_Loop_Morph) == 0x000008, "Wrong alignment on ACue_Ability_Loop_Morph");
static_assert(sizeof(ACue_Ability_Loop_Morph) == 0x000F00, "Wrong size on ACue_Ability_Loop_Morph");
static_assert(offsetof(ACue_Ability_Loop_Morph, HulkStateTag) == 0x000E00, "Member 'ACue_Ability_Loop_Morph::HulkStateTag' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TimerTotal) == 0x000E0C, "Member 'ACue_Ability_Loop_Morph::TimerTotal' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, HeroSourcePrefix) == 0x000E10, "Member 'ACue_Ability_Loop_Morph::HeroSourcePrefix' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, SourceBody) == 0x000E20, "Member 'ACue_Ability_Loop_Morph::SourceBody' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, SourceHead) == 0x000E28, "Member 'ACue_Ability_Loop_Morph::SourceHead' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, HeroTargetPrefix) == 0x000E30, "Member 'ACue_Ability_Loop_Morph::HeroTargetPrefix' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TargetBody) == 0x000E40, "Member 'ACue_Ability_Loop_Morph::TargetBody' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TargetHead) == 0x000E48, "Member 'ACue_Ability_Loop_Morph::TargetHead' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialBodySlotName) == 0x000E50, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialBodySlotName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, BodyMorphSourceMaterial) == 0x000E60, "Member 'ACue_Ability_Loop_Morph::BodyMorphSourceMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, BodyMorphMask) == 0x000E68, "Member 'ACue_Ability_Loop_Morph::BodyMorphMask' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialHeadSlotName) == 0x000E70, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialHeadSlotName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, HeadMorphSourceMaterial) == 0x000E80, "Member 'ACue_Ability_Loop_Morph::HeadMorphSourceMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, HeadMorphMask) == 0x000E88, "Member 'ACue_Ability_Loop_Morph::HeadMorphMask' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, bUseMTPositionForCurve) == 0x000E90, "Member 'ACue_Ability_Loop_Morph::bUseMTPositionForCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, MorphWeightCurve) == 0x000E98, "Member 'ACue_Ability_Loop_Morph::MorphWeightCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, HeroShadowParameterNames) == 0x000EA0, "Member 'ACue_Ability_Loop_Morph::HeroShadowParameterNames' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TimerHandle) == 0x000EB0, "Member 'ACue_Ability_Loop_Morph::TimerHandle' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, MorphMesh) == 0x000EC8, "Member 'ACue_Ability_Loop_Morph::MorphMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, OwnerCharacter) == 0x000ED0, "Member 'ACue_Ability_Loop_Morph::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, bMorphSuccess) == 0x000ED8, "Member 'ACue_Ability_Loop_Morph::bMorphSuccess' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TimerSpent) == 0x000EDC, "Member 'ACue_Ability_Loop_Morph::TimerSpent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, TimerFrequence) == 0x000EE0, "Member 'ACue_Ability_Loop_Morph::TimerFrequence' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialBody) == 0x000EE8, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialBody' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialHead) == 0x000EF0, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialHead' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialBodyElementIndex) == 0x000EF8, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialBodyElementIndex' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_Morph, DynamicMaterialHeadElementIndex) == 0x000EFC, "Member 'ACue_Ability_Loop_Morph::DynamicMaterialHeadElementIndex' has a wrong offset!");

// Class Hero_1011.Ability_HulkSculpt
// 0x0000 (0x2808 - 0x2808)
class UAbility_HulkSculpt final : public UAbility_109
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_HulkSculpt">();
	}
	static class UAbility_HulkSculpt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_HulkSculpt>();
	}
};
static_assert(alignof(UAbility_HulkSculpt) == 0x000008, "Wrong alignment on UAbility_HulkSculpt");
static_assert(sizeof(UAbility_HulkSculpt) == 0x002808, "Wrong size on UAbility_HulkSculpt");

// Class Hero_1011.Cue_Weapon_Loop_101111
// 0x0048 (0x10A0 - 0x1058)
class ACue_Weapon_Loop_101111 final : public AMarvelCueNotify_Weapon_Loop
{
public:
	class UStaticMeshComponent*                   Container;                                         // 0x1058(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Mid;                                               // 0x1060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHulkBannerCharacter*                   BannerChar;                                        // 0x1068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x1070(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1088[0x18];                                    // 0x1088(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeContainerState();
	void OnOwnedTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Weapon_Loop_101111">();
	}
	static class ACue_Weapon_Loop_101111* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Weapon_Loop_101111>();
	}
};
static_assert(alignof(ACue_Weapon_Loop_101111) == 0x000008, "Wrong alignment on ACue_Weapon_Loop_101111");
static_assert(sizeof(ACue_Weapon_Loop_101111) == 0x0010A0, "Wrong size on ACue_Weapon_Loop_101111");
static_assert(offsetof(ACue_Weapon_Loop_101111, Container) == 0x001058, "Member 'ACue_Weapon_Loop_101111::Container' has a wrong offset!");
static_assert(offsetof(ACue_Weapon_Loop_101111, Mid) == 0x001060, "Member 'ACue_Weapon_Loop_101111::Mid' has a wrong offset!");
static_assert(offsetof(ACue_Weapon_Loop_101111, BannerChar) == 0x001068, "Member 'ACue_Weapon_Loop_101111::BannerChar' has a wrong offset!");
static_assert(offsetof(ACue_Weapon_Loop_101111, LoopTimerHandle) == 0x001070, "Member 'ACue_Weapon_Loop_101111::LoopTimerHandle' has a wrong offset!");

// Class Hero_1011.Config_101141
// 0x0030 (0x00C8 - 0x0098)
class UConfig_101141 final : public UMarvelAbilityConfig
{
public:
	int32                                         SelfSummonedID;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SelfBuffID;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TeammateSummonedID;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TeammateBuffID;                                    // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101141">();
	}
	static class UConfig_101141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101141>();
	}
};
static_assert(alignof(UConfig_101141) == 0x000008, "Wrong alignment on UConfig_101141");
static_assert(sizeof(UConfig_101141) == 0x0000C8, "Wrong size on UConfig_101141");
static_assert(offsetof(UConfig_101141, SelfSummonedID) == 0x000098, "Member 'UConfig_101141::SelfSummonedID' has a wrong offset!");
static_assert(offsetof(UConfig_101141, SelfBuffID) == 0x0000A0, "Member 'UConfig_101141::SelfBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101141, TeammateSummonedID) == 0x0000B0, "Member 'UConfig_101141::TeammateSummonedID' has a wrong offset!");
static_assert(offsetof(UConfig_101141, TeammateBuffID) == 0x0000B8, "Member 'UConfig_101141::TeammateBuffID' has a wrong offset!");

// Class Hero_1011.EffectiveComponent_10114101
// 0x0000 (0x1C00 - 0x1C00)
class UEffectiveComponent_10114101 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10114101">();
	}
	static class UEffectiveComponent_10114101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10114101>();
	}
};
static_assert(alignof(UEffectiveComponent_10114101) == 0x000010, "Wrong alignment on UEffectiveComponent_10114101");
static_assert(sizeof(UEffectiveComponent_10114101) == 0x001C00, "Wrong size on UEffectiveComponent_10114101");

// Class Hero_1011.Cue_Ability_Instant_10114101
// 0x0008 (0x0370 - 0x0368)
class UCue_Ability_Instant_10114101 final : public UMarvelCueNotify_Base
{
public:
	int32                                         ScopeId;                                           // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FXInitRadius;                                      // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Instant_10114101">();
	}
	static class UCue_Ability_Instant_10114101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Ability_Instant_10114101>();
	}
};
static_assert(alignof(UCue_Ability_Instant_10114101) == 0x000008, "Wrong alignment on UCue_Ability_Instant_10114101");
static_assert(sizeof(UCue_Ability_Instant_10114101) == 0x000370, "Wrong size on UCue_Ability_Instant_10114101");
static_assert(offsetof(UCue_Ability_Instant_10114101, ScopeId) == 0x000368, "Member 'UCue_Ability_Instant_10114101::ScopeId' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10114101, FXInitRadius) == 0x00036C, "Member 'UCue_Ability_Instant_10114101::FXInitRadius' has a wrong offset!");

// Class Hero_1011.Ability_101171
// 0x0008 (0x2558 - 0x2550)
class UAbility_101171 : public UMarvelGameplayAbility
{
public:
	class UMarvelAbilityTask_SelectTarget*        SelectTask;                                        // 0x2550(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector CalcSmashLocation(const class AActor* TargetActor, class AMarvelBaseCharacter* OutHulk);
	class AActor* GetTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101171">();
	}
	static class UAbility_101171* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101171>();
	}
};
static_assert(alignof(UAbility_101171) == 0x000008, "Wrong alignment on UAbility_101171");
static_assert(sizeof(UAbility_101171) == 0x002558, "Wrong size on UAbility_101171");
static_assert(offsetof(UAbility_101171, SelectTask) == 0x002550, "Member 'UAbility_101171::SelectTask' has a wrong offset!");

// Class Hero_1011.Config_101171
// 0x1078 (0x1110 - 0x0098)
class UConfig_101171 : public UMarvelAbilityConfig
{
public:
	float                                         SmashBeginTime;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SmashEndLocationOffset;                            // 0x00A0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashLookingPitch;                                 // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashTargetArmLength;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashSpringArmSpeed;                               // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmashCameraLagSpeed;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSelectTaskParam                       SelectTaskParam;                                   // 0x00D0(0x1040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101171">();
	}
	static class UConfig_101171* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101171>();
	}
};
static_assert(alignof(UConfig_101171) == 0x000010, "Wrong alignment on UConfig_101171");
static_assert(sizeof(UConfig_101171) == 0x001110, "Wrong size on UConfig_101171");
static_assert(offsetof(UConfig_101171, SmashBeginTime) == 0x000098, "Member 'UConfig_101171::SmashBeginTime' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SmashEndLocationOffset) == 0x0000A0, "Member 'UConfig_101171::SmashEndLocationOffset' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SmashLookingPitch) == 0x0000B8, "Member 'UConfig_101171::SmashLookingPitch' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SmashTargetArmLength) == 0x0000BC, "Member 'UConfig_101171::SmashTargetArmLength' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SmashSpringArmSpeed) == 0x0000C0, "Member 'UConfig_101171::SmashSpringArmSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SmashCameraLagSpeed) == 0x0000C4, "Member 'UConfig_101171::SmashCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101171, SelectTaskParam) == 0x0000D0, "Member 'UConfig_101171::SelectTaskParam' has a wrong offset!");

// Class Hero_1011.Cue_Buff_10117101
// 0x0088 (0x1070 - 0x0FE8)
class ACue_Buff_10117101 : public AMarvelCueNotify_Buff
{
public:
	class AActor*                                 OwnerCharacter;                                    // 0x0FE8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x0FF0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 OwnerCharacterMesh;                                // 0x0FF8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SmashMeshTransform;                                // 0x1000(0x0060)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSmashing;                                       // 0x1060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1061[0xF];                                     // 0x1061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnRecycle();
	void LoopCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10117101">();
	}
	static class ACue_Buff_10117101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10117101>();
	}
};
static_assert(alignof(ACue_Buff_10117101) == 0x000010, "Wrong alignment on ACue_Buff_10117101");
static_assert(sizeof(ACue_Buff_10117101) == 0x001070, "Wrong size on ACue_Buff_10117101");
static_assert(offsetof(ACue_Buff_10117101, OwnerCharacter) == 0x000FE8, "Member 'ACue_Buff_10117101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10117101, InstigatorCharacter) == 0x000FF0, "Member 'ACue_Buff_10117101::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10117101, OwnerCharacterMesh) == 0x000FF8, "Member 'ACue_Buff_10117101::OwnerCharacterMesh' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10117101, SmashMeshTransform) == 0x001000, "Member 'ACue_Buff_10117101::SmashMeshTransform' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10117101, bIsSmashing) == 0x001060, "Member 'ACue_Buff_10117101::bIsSmashing' has a wrong offset!");

// Class Hero_1011.EffectAbility_101171
// 0x0030 (0x1118 - 0x10E8)
class UEffectAbility_101171 : public UMarvelEffectGameplayAbility
{
public:
	int32                                         InstigatorAbilityId;                               // 0x10E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10EC[0x4];                                     // 0x10EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerCharacter;                                    // 0x10F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 OwnerCharacterMesh;                                // 0x10F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x1100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 InstigatorCharacterMesh;                           // 0x1108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReadyToSmash;                                   // 0x1110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1111[0x7];                                     // 0x1111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectAbility_101171">();
	}
	static class UEffectAbility_101171* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectAbility_101171>();
	}
};
static_assert(alignof(UEffectAbility_101171) == 0x000008, "Wrong alignment on UEffectAbility_101171");
static_assert(sizeof(UEffectAbility_101171) == 0x001118, "Wrong size on UEffectAbility_101171");
static_assert(offsetof(UEffectAbility_101171, InstigatorAbilityId) == 0x0010E8, "Member 'UEffectAbility_101171::InstigatorAbilityId' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101171, OwnerCharacter) == 0x0010F0, "Member 'UEffectAbility_101171::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101171, OwnerCharacterMesh) == 0x0010F8, "Member 'UEffectAbility_101171::OwnerCharacterMesh' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101171, InstigatorCharacter) == 0x001100, "Member 'UEffectAbility_101171::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101171, InstigatorCharacterMesh) == 0x001108, "Member 'UEffectAbility_101171::InstigatorCharacterMesh' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101171, bIsReadyToSmash) == 0x001110, "Member 'UEffectAbility_101171::bIsReadyToSmash' has a wrong offset!");

// Class Hero_1011.UIC_SelectTarget_101181
// 0x0000 (0x0158 - 0x0158)
class UUIC_SelectTarget_101181 final : public UUIC_SelectTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIC_SelectTarget_101181">();
	}
	static class UUIC_SelectTarget_101181* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIC_SelectTarget_101181>();
	}
};
static_assert(alignof(UUIC_SelectTarget_101181) == 0x000008, "Wrong alignment on UUIC_SelectTarget_101181");
static_assert(sizeof(UUIC_SelectTarget_101181) == 0x000158, "Wrong size on UUIC_SelectTarget_101181");

// Class Hero_1011.Cue_Projectile_Loop_101182
// 0x0068 (0x0E58 - 0x0DF0)
class ACue_Projectile_Loop_101182 final : public ACue_Physics_Projectile_Loop
{
public:
	TMap<EPhysicsWeaponType, float>               ParticleNumMap;                                    // 0x0DF0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   ParticleNumName;                                   // 0x0E40(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4C[0x4];                                      // 0x0E4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_Trajectory;                                     // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_101182">();
	}
	static class ACue_Projectile_Loop_101182* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_101182>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_101182) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_101182");
static_assert(sizeof(ACue_Projectile_Loop_101182) == 0x000E58, "Wrong size on ACue_Projectile_Loop_101182");
static_assert(offsetof(ACue_Projectile_Loop_101182, ParticleNumMap) == 0x000DF0, "Member 'ACue_Projectile_Loop_101182::ParticleNumMap' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_101182, ParticleNumName) == 0x000E40, "Member 'ACue_Projectile_Loop_101182::ParticleNumName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_101182, NS_Trajectory) == 0x000E50, "Member 'ACue_Projectile_Loop_101182::NS_Trajectory' has a wrong offset!");

// Class Hero_1011.Ability_101191
// 0x00B8 (0x2620 - 0x2568)
class UAbility_101191 : public UMarvelAbility_LongPressTrigger
{
public:
	class UHulkBannerMoveLogicBaseComponent*      MoveLogicCom;                                      // 0x2568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x2570(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         LaunchKey;                                         // 0x2578(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelBaseAbilitySystemComponent*      ASC;                                               // 0x2618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void K2_OnShiftJumpLaunched();
	void LaunchCharacter();
	void OnServerReceiveLaunchVelocity(const struct FGameplayAbilityTargetDataHandle& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101191">();
	}
	static class UAbility_101191* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101191>();
	}
};
static_assert(alignof(UAbility_101191) == 0x000008, "Wrong alignment on UAbility_101191");
static_assert(sizeof(UAbility_101191) == 0x002620, "Wrong size on UAbility_101191");
static_assert(offsetof(UAbility_101191, MoveLogicCom) == 0x002568, "Member 'UAbility_101191::MoveLogicCom' has a wrong offset!");
static_assert(offsetof(UAbility_101191, OwnerCharacter) == 0x002570, "Member 'UAbility_101191::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_101191, LaunchKey) == 0x002578, "Member 'UAbility_101191::LaunchKey' has a wrong offset!");
static_assert(offsetof(UAbility_101191, ASC) == 0x002618, "Member 'UAbility_101191::ASC' has a wrong offset!");

// Class Hero_1011.Cue_Ability_Loop_10119101
// 0x0068 (0x0E68 - 0x0E00)
class ACue_Ability_Loop_10119101 : public AMarvelCueNotify_Ability
{
public:
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x0E00(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumpLineVisible;                                // 0x0E18(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCharging;                                       // 0x0E19(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1A[0x6];                                      // 0x0E1A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelGameplayAbility*                 OwnerAbility;                                      // 0x0E20(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHulkBannerCharacter*                   OwnerCharacter;                                    // 0x0E28(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfigPressedSecondsMin;                           // 0x0E30(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E34[0x4];                                      // 0x0E34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULegacyCameraShake>         ConfigJumpLandCameraShakeClass;                    // 0x0E38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         ConfigJumpGrabHitCameraShakeClass;                 // 0x0E40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         ConfigGrabHitParticle;                             // 0x0E48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGrabHitParticleAttach;                          // 0x0E50(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E51[0x3];                                      // 0x0E51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OwningAbilityID;                                   // 0x0E54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JumpChargeAudioID;                                 // 0x0E58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5C[0x4];                                      // 0x0E5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_BasisTrack;                                     // 0x0E60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClearLoopTimer();
	class UMarvelGameplayAbility* GetOwnerAbility();
	class AHulkBannerCharacter* GetOwnerChar();
	void LoopSetJumpParams();
	void SetAudio(bool bReset);
	void SetJumpLineVisible(bool bIsVisible);
	void SetLoopTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10119101">();
	}
	static class ACue_Ability_Loop_10119101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10119101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10119101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10119101");
static_assert(sizeof(ACue_Ability_Loop_10119101) == 0x000E68, "Wrong size on ACue_Ability_Loop_10119101");
static_assert(offsetof(ACue_Ability_Loop_10119101, LoopTimerHandle) == 0x000E00, "Member 'ACue_Ability_Loop_10119101::LoopTimerHandle' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, bIsJumpLineVisible) == 0x000E18, "Member 'ACue_Ability_Loop_10119101::bIsJumpLineVisible' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, bIsCharging) == 0x000E19, "Member 'ACue_Ability_Loop_10119101::bIsCharging' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, OwnerAbility) == 0x000E20, "Member 'ACue_Ability_Loop_10119101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, OwnerCharacter) == 0x000E28, "Member 'ACue_Ability_Loop_10119101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, ConfigPressedSecondsMin) == 0x000E30, "Member 'ACue_Ability_Loop_10119101::ConfigPressedSecondsMin' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, ConfigJumpLandCameraShakeClass) == 0x000E38, "Member 'ACue_Ability_Loop_10119101::ConfigJumpLandCameraShakeClass' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, ConfigJumpGrabHitCameraShakeClass) == 0x000E40, "Member 'ACue_Ability_Loop_10119101::ConfigJumpGrabHitCameraShakeClass' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, ConfigGrabHitParticle) == 0x000E48, "Member 'ACue_Ability_Loop_10119101::ConfigGrabHitParticle' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, bIsGrabHitParticleAttach) == 0x000E50, "Member 'ACue_Ability_Loop_10119101::bIsGrabHitParticleAttach' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, OwningAbilityID) == 0x000E54, "Member 'ACue_Ability_Loop_10119101::OwningAbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, JumpChargeAudioID) == 0x000E58, "Member 'ACue_Ability_Loop_10119101::JumpChargeAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119101, NS_BasisTrack) == 0x000E60, "Member 'ACue_Ability_Loop_10119101::NS_BasisTrack' has a wrong offset!");

// Class Hero_1011.UIController_101191
// 0x0120 (0x0D78 - 0x0C58)
class UUIController_101191 : public UUIC_Ability
{
public:
	struct FTimerHandle                           LoopSetChargePerTimerHandle;                       // 0x0C58(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCueHintData                           HintData;                                          // 0x0C70(0x0098)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UWidget_AbilityEnergy*                  WidgetAbilityEnergyRight;                          // 0x0D08(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHulkBannerCharacter*                   HulkBannerChar;                                    // 0x0D10(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHulkBannerMoveLogicBaseComponent*      MoveLogic;                                         // 0x0D18(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinChargeHulk;                                     // 0x0D20(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxChargeHulk;                                     // 0x0D24(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinChargeMonster;                                  // 0x0D28(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxChargeMonster;                                  // 0x0D2C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelGameplayAbility*                 Ability101191;                                     // 0x0D30(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelGameplayAbility*                 Ability101193;                                     // 0x0D38(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCharge;                                         // 0x0D40(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClimbing;                                       // 0x0D41(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHanging;                                        // 0x0D42(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasShowHint;                                      // 0x0D43(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInitHulkParam;                                 // 0x0D44(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInitMonsterParam;                              // 0x0D45(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D46[0x2];                                      // 0x0D46(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelUserWidget*                      WidgetTipLeft;                                     // 0x0D48(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelUserWidget*                      WidgetTipRight;                                    // 0x0D50(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget_AbilityStatusPanel*             AbilityPanel;                                      // 0x0D58(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           LoopCheckTipsAndHintTimerHandle;                   // 0x0D60(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CanGetAbility();
	void Clear101191LoopTimer();
	void Clear101192LoopTimer();
	bool IsAbilityCharging();
	void LoopSetChargePer();
	bool PyInitChargeParam(bool bIsHulk);
	void Set101191LoopTimer();
	void Set101192LoopTimer();
	bool TryInitChargeParam(bool bIsHulk);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIController_101191">();
	}
	static class UUIController_101191* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIController_101191>();
	}
};
static_assert(alignof(UUIController_101191) == 0x000008, "Wrong alignment on UUIController_101191");
static_assert(sizeof(UUIController_101191) == 0x000D78, "Wrong size on UUIController_101191");
static_assert(offsetof(UUIController_101191, LoopSetChargePerTimerHandle) == 0x000C58, "Member 'UUIController_101191::LoopSetChargePerTimerHandle' has a wrong offset!");
static_assert(offsetof(UUIController_101191, HintData) == 0x000C70, "Member 'UUIController_101191::HintData' has a wrong offset!");
static_assert(offsetof(UUIController_101191, WidgetAbilityEnergyRight) == 0x000D08, "Member 'UUIController_101191::WidgetAbilityEnergyRight' has a wrong offset!");
static_assert(offsetof(UUIController_101191, HulkBannerChar) == 0x000D10, "Member 'UUIController_101191::HulkBannerChar' has a wrong offset!");
static_assert(offsetof(UUIController_101191, MoveLogic) == 0x000D18, "Member 'UUIController_101191::MoveLogic' has a wrong offset!");
static_assert(offsetof(UUIController_101191, MinChargeHulk) == 0x000D20, "Member 'UUIController_101191::MinChargeHulk' has a wrong offset!");
static_assert(offsetof(UUIController_101191, MaxChargeHulk) == 0x000D24, "Member 'UUIController_101191::MaxChargeHulk' has a wrong offset!");
static_assert(offsetof(UUIController_101191, MinChargeMonster) == 0x000D28, "Member 'UUIController_101191::MinChargeMonster' has a wrong offset!");
static_assert(offsetof(UUIController_101191, MaxChargeMonster) == 0x000D2C, "Member 'UUIController_101191::MaxChargeMonster' has a wrong offset!");
static_assert(offsetof(UUIController_101191, Ability101191) == 0x000D30, "Member 'UUIController_101191::Ability101191' has a wrong offset!");
static_assert(offsetof(UUIController_101191, Ability101193) == 0x000D38, "Member 'UUIController_101191::Ability101193' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bIsCharge) == 0x000D40, "Member 'UUIController_101191::bIsCharge' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bIsClimbing) == 0x000D41, "Member 'UUIController_101191::bIsClimbing' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bIsHanging) == 0x000D42, "Member 'UUIController_101191::bIsHanging' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bHasShowHint) == 0x000D43, "Member 'UUIController_101191::bHasShowHint' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bHasInitHulkParam) == 0x000D44, "Member 'UUIController_101191::bHasInitHulkParam' has a wrong offset!");
static_assert(offsetof(UUIController_101191, bHasInitMonsterParam) == 0x000D45, "Member 'UUIController_101191::bHasInitMonsterParam' has a wrong offset!");
static_assert(offsetof(UUIController_101191, WidgetTipLeft) == 0x000D48, "Member 'UUIController_101191::WidgetTipLeft' has a wrong offset!");
static_assert(offsetof(UUIController_101191, WidgetTipRight) == 0x000D50, "Member 'UUIController_101191::WidgetTipRight' has a wrong offset!");
static_assert(offsetof(UUIController_101191, AbilityPanel) == 0x000D58, "Member 'UUIController_101191::AbilityPanel' has a wrong offset!");
static_assert(offsetof(UUIController_101191, LoopCheckTipsAndHintTimerHandle) == 0x000D60, "Member 'UUIController_101191::LoopCheckTipsAndHintTimerHandle' has a wrong offset!");

// Class Hero_1011.Cue_Ability_Loop_10119103
// 0x0088 (0x0E88 - 0x0E00)
class ACue_Ability_Loop_10119103 : public AMarvelCueNotify_Ability
{
public:
	bool                                          IsAuxiliaryLineOn;                                 // 0x0E00(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E01[0x3];                                      // 0x0E01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PressedTimeInterpAlpha;                            // 0x0E04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSegmentLength;                                 // 0x0E08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpSeconds;                                    // 0x0E0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpHeightDown;                                 // 0x0E10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumOfSplineMeshUsed;                            // 0x0E14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            TailStaticMesh;                                    // 0x0E18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BodyStaticMesh;                                    // 0x0E20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            HeadStaticMesh;                                    // 0x0E28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartFromCapsuleBottom;                           // 0x0E30(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E31[0x3];                                      // 0x0E31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x0E34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Gathering;                                      // 0x0E38(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelSplineComponent*                 SplineComponent;                                   // 0x0E40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           SplineMeshCollection;                              // 0x0E48(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAbility_101191*                        OwnerAbility;                                      // 0x0E58(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHulkBannerCharacter*                   OwnerCharacter;                                    // 0x0E60(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHulkBannerMoveLogicBaseComponent*      MoveLogicComponent;                                // 0x0E68(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedCurve;                                        // 0x0E70(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressedSecondsMin;                                 // 0x0E78(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E7C[0xC];                                      // 0x0E7C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPressRelease(float TimeWaited);
	void OnPressTimeMin(float TimeWaited);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10119103">();
	}
	static class ACue_Ability_Loop_10119103* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10119103>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10119103) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10119103");
static_assert(sizeof(ACue_Ability_Loop_10119103) == 0x000E88, "Wrong size on ACue_Ability_Loop_10119103");
static_assert(offsetof(ACue_Ability_Loop_10119103, IsAuxiliaryLineOn) == 0x000E00, "Member 'ACue_Ability_Loop_10119103::IsAuxiliaryLineOn' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, PressedTimeInterpAlpha) == 0x000E04, "Member 'ACue_Ability_Loop_10119103::PressedTimeInterpAlpha' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, LastSegmentLength) == 0x000E08, "Member 'ACue_Ability_Loop_10119103::LastSegmentLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, MaxJumpSeconds) == 0x000E0C, "Member 'ACue_Ability_Loop_10119103::MaxJumpSeconds' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, MaxJumpHeightDown) == 0x000E10, "Member 'ACue_Ability_Loop_10119103::MaxJumpHeightDown' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, MaxNumOfSplineMeshUsed) == 0x000E14, "Member 'ACue_Ability_Loop_10119103::MaxNumOfSplineMeshUsed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, TailStaticMesh) == 0x000E18, "Member 'ACue_Ability_Loop_10119103::TailStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, BodyStaticMesh) == 0x000E20, "Member 'ACue_Ability_Loop_10119103::BodyStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, HeadStaticMesh) == 0x000E28, "Member 'ACue_Ability_Loop_10119103::HeadStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, bStartFromCapsuleBottom) == 0x000E30, "Member 'ACue_Ability_Loop_10119103::bStartFromCapsuleBottom' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, AbilityID) == 0x000E34, "Member 'ACue_Ability_Loop_10119103::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, NS_Gathering) == 0x000E38, "Member 'ACue_Ability_Loop_10119103::NS_Gathering' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, SplineComponent) == 0x000E40, "Member 'ACue_Ability_Loop_10119103::SplineComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, SplineMeshCollection) == 0x000E48, "Member 'ACue_Ability_Loop_10119103::SplineMeshCollection' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, OwnerAbility) == 0x000E58, "Member 'ACue_Ability_Loop_10119103::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, OwnerCharacter) == 0x000E60, "Member 'ACue_Ability_Loop_10119103::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, MoveLogicComponent) == 0x000E68, "Member 'ACue_Ability_Loop_10119103::MoveLogicComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, SpeedCurve) == 0x000E70, "Member 'ACue_Ability_Loop_10119103::SpeedCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10119103, PressedSecondsMin) == 0x000E78, "Member 'ACue_Ability_Loop_10119103::PressedSecondsMin' has a wrong offset!");

// Class Hero_1011.MovableSplineMeshComponent
// 0x0000 (0x0A20 - 0x0A20)
class UMovableSplineMeshComponent final : public USplineMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovableSplineMeshComponent">();
	}
	static class UMovableSplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovableSplineMeshComponent>();
	}
};
static_assert(alignof(UMovableSplineMeshComponent) == 0x000010, "Wrong alignment on UMovableSplineMeshComponent");
static_assert(sizeof(UMovableSplineMeshComponent) == 0x000A20, "Wrong size on UMovableSplineMeshComponent");

// Class Hero_1011.ConfigHulkClimb
// 0x0018 (0x00B0 - 0x0098)
class UConfigHulkClimb final : public UMarvelAbilityConfig
{
public:
	struct FHulkClimbParam                        ClimbParam;                                        // 0x0098(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ServerWaitCollisionTime;                           // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigHulkClimb">();
	}
	static class UConfigHulkClimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigHulkClimb>();
	}
};
static_assert(alignof(UConfigHulkClimb) == 0x000008, "Wrong alignment on UConfigHulkClimb");
static_assert(sizeof(UConfigHulkClimb) == 0x0000B0, "Wrong size on UConfigHulkClimb");
static_assert(offsetof(UConfigHulkClimb, ClimbParam) == 0x000098, "Member 'UConfigHulkClimb::ClimbParam' has a wrong offset!");
static_assert(offsetof(UConfigHulkClimb, ServerWaitCollisionTime) == 0x0000A8, "Member 'UConfigHulkClimb::ServerWaitCollisionTime' has a wrong offset!");

// Class Hero_1011.Ability_101192
// 0x0120 (0x2670 - 0x2550)
class UAbility_101192 : public UMarvelGameplayAbility
{
public:
	class UHulkBannerMoveLogicBaseComponent*      MoveLogicCom;                                      // 0x2550(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x2558(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfigHulkClimb*                       ClimbConfig;                                       // 0x2560(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClimbLocation;                                     // 0x2568(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  ClimbOrient;                                       // 0x2580(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A0[0x8];                                     // 0x25A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           WaitTimeOutTimer;                                  // 0x25A8(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         LeaveClimbKey;                                     // 0x25C0(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedCheckKey;                                     // 0x2660(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClimbKeyDown;                                     // 0x2661(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2662[0xE];                                     // 0x2662(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanActivateClimb();
	class UConfigHulkClimb* GetClimbConfig();
	class UHulkBannerMoveLogicBaseComponent* GetMoveComponent();
	class AMarvelBaseCharacter* GetOwnerChar();
	void OnClimbKeyPress(float Time);
	void OnClimbKeyRelease(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101192">();
	}
	static class UAbility_101192* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101192>();
	}
};
static_assert(alignof(UAbility_101192) == 0x000010, "Wrong alignment on UAbility_101192");
static_assert(sizeof(UAbility_101192) == 0x002670, "Wrong size on UAbility_101192");
static_assert(offsetof(UAbility_101192, MoveLogicCom) == 0x002550, "Member 'UAbility_101192::MoveLogicCom' has a wrong offset!");
static_assert(offsetof(UAbility_101192, OwnerCharacter) == 0x002558, "Member 'UAbility_101192::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_101192, ClimbConfig) == 0x002560, "Member 'UAbility_101192::ClimbConfig' has a wrong offset!");
static_assert(offsetof(UAbility_101192, ClimbLocation) == 0x002568, "Member 'UAbility_101192::ClimbLocation' has a wrong offset!");
static_assert(offsetof(UAbility_101192, ClimbOrient) == 0x002580, "Member 'UAbility_101192::ClimbOrient' has a wrong offset!");
static_assert(offsetof(UAbility_101192, WaitTimeOutTimer) == 0x0025A8, "Member 'UAbility_101192::WaitTimeOutTimer' has a wrong offset!");
static_assert(offsetof(UAbility_101192, LeaveClimbKey) == 0x0025C0, "Member 'UAbility_101192::LeaveClimbKey' has a wrong offset!");
static_assert(offsetof(UAbility_101192, bNeedCheckKey) == 0x002660, "Member 'UAbility_101192::bNeedCheckKey' has a wrong offset!");
static_assert(offsetof(UAbility_101192, bClimbKeyDown) == 0x002661, "Member 'UAbility_101192::bClimbKeyDown' has a wrong offset!");

// Class Hero_1011.Ability_101198
// 0x0018 (0x25C8 - 0x25B0)
class UAbility_101198 : public UAbility_100016
{
public:
	EAbilityState_101198                          CurrentAbilityState;                               // 0x25B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityState_101198                          LastAbilityState;                                  // 0x25B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B2[0x6];                                     // 0x25B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x25B8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                                      // 0x25C0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SwitchTimelineTask(const class FName& SectionName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101198">();
	}
	static class UAbility_101198* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101198>();
	}
};
static_assert(alignof(UAbility_101198) == 0x000008, "Wrong alignment on UAbility_101198");
static_assert(sizeof(UAbility_101198) == 0x0025C8, "Wrong size on UAbility_101198");
static_assert(offsetof(UAbility_101198, CurrentAbilityState) == 0x0025B0, "Member 'UAbility_101198::CurrentAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_101198, LastAbilityState) == 0x0025B1, "Member 'UAbility_101198::LastAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_101198, OwnerChar) == 0x0025B8, "Member 'UAbility_101198::OwnerChar' has a wrong offset!");
static_assert(offsetof(UAbility_101198, TimelineTask) == 0x0025C0, "Member 'UAbility_101198::TimelineTask' has a wrong offset!");

// Class Hero_1011.EpicMomentAction_1011
// 0x0088 (0x01A8 - 0x0120)
class UEpicMomentAction_1011 : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0xC];                                      // 0x0120(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    GrabConfig;                                        // 0x012C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    GrabKillConfig;                                    // 0x0138(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    GammaShieldConfig;                                 // 0x0144(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    RadiationCageConfig;                               // 0x0150(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GrabKillInterval;                                  // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 GrabBuffIDs;                                       // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         GammaShieldBlockDamageThreshold;                   // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 GammaShieldIDs;                                    // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 RadiationCageInterruptAbilities;                   // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 RadiationCageBuffIDs;                              // 0x0198(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void OnActorAbilityCancel(class AActor* Source, int32 AbilityID, const class FString& SessionID, class UMarvelGameplayAbility* SourceAbility);
	void OnActorTakeDamage(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnEffectImmunityOrInhibitedCallback(class AActor* Source, const struct FGameplayEffectSpec& BlockedSpec);
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1011">();
	}
	static class UEpicMomentAction_1011* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1011>();
	}
};
static_assert(alignof(UEpicMomentAction_1011) == 0x000008, "Wrong alignment on UEpicMomentAction_1011");
static_assert(sizeof(UEpicMomentAction_1011) == 0x0001A8, "Wrong size on UEpicMomentAction_1011");
static_assert(offsetof(UEpicMomentAction_1011, GrabConfig) == 0x00012C, "Member 'UEpicMomentAction_1011::GrabConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GrabKillConfig) == 0x000138, "Member 'UEpicMomentAction_1011::GrabKillConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GammaShieldConfig) == 0x000144, "Member 'UEpicMomentAction_1011::GammaShieldConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, RadiationCageConfig) == 0x000150, "Member 'UEpicMomentAction_1011::RadiationCageConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GrabKillInterval) == 0x00015C, "Member 'UEpicMomentAction_1011::GrabKillInterval' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GrabBuffIDs) == 0x000160, "Member 'UEpicMomentAction_1011::GrabBuffIDs' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GammaShieldBlockDamageThreshold) == 0x000170, "Member 'UEpicMomentAction_1011::GammaShieldBlockDamageThreshold' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, GammaShieldIDs) == 0x000178, "Member 'UEpicMomentAction_1011::GammaShieldIDs' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, RadiationCageInterruptAbilities) == 0x000188, "Member 'UEpicMomentAction_1011::RadiationCageInterruptAbilities' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1011, RadiationCageBuffIDs) == 0x000198, "Member 'UEpicMomentAction_1011::RadiationCageBuffIDs' has a wrong offset!");

// Class Hero_1011.HulkAnimInstance
// 0x0130 (0x0A30 - 0x0900)
class UHulkAnimInstance : public UMarvelAnimInstance
{
public:
	struct FGameplayTag                           SynergyRideTag;                                    // 0x0900(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SynergyRideGatheringTag;                           // 0x090C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VJumpLandAnimStartHeight;                          // 0x0918(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbilityYawInterpSpeed;                             // 0x091C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedToClipLowerBodyYaw;                           // 0x0920(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_921[0x3];                                      // 0x0921(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LandMovementToGround;                              // 0x0924(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VIsClimbing;                                       // 0x0928(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VShiftJumpfromWall;                                // 0x0929(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92A[0x2];                                      // 0x092A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VClimbDirection;                                   // 0x092C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RootYawForTransition;                              // 0x0930(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VIsInShiftJump;                                    // 0x0934(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VIsInShiftJumpLand;                                // 0x0935(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_936[0x2];                                      // 0x0936(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShiftJumpDirection;                                // 0x0938(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSynergyRideState;                               // 0x093C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_93D[0x1];                                      // 0x093D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInSynergyRideStateBlend;                          // 0x093E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSynergyRideStartBlend;                          // 0x093F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSynergyRideState_Enter;                           // 0x0940(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSynergyRideState_Exit;                            // 0x0941(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSynergyRideState_Gathering;                     // 0x0942(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SynergyRideState_BeRide;                           // 0x0943(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFullSpace_ShiftJumps_To_Ground;                   // 0x0944(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFullSpace_ShiftJumps_To_LandRecovery;             // 0x0945(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFullSpace_LandRecovery_To_Ground;                 // 0x0946(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShiftJumps_Start_To_Other;                        // 0x0947(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_Center_To_ToLeft;                           // 0x0948(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_CenterToLeft_To_LeftIdle;                   // 0x0949(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_CenterToLeft_To_Center;                     // 0x094A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_LeftIdle_To_ReverseToLeft;                  // 0x094B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_LeftIdle_To_LeftToCenter;                   // 0x094C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_LeftToCenter_To_Center;                     // 0x094D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_Center_To_ToRight;                          // 0x094E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_RightIdle_To_RightToCenter;                 // 0x094F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_RightIdle_To_ReverseToRight;                // 0x0950(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_LeftToRightConduit_To_Center;               // 0x0951(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClimb_LeftToRightConduit_To_RightIdle;            // 0x0952(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseAO;                                      // 0x0953(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_954[0x4];                                      // 0x0954(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SynergyRideStartBlendDistanceRange;                // 0x0958(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_968[0x90];                                     // 0x0968(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UHulkBannerMoveLogicBaseComponent*      HulkMoveLogicBaseComponent;                        // 0x09F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A00[0x18];                                     // 0x0A00(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_101198*                        Ability_101198;                                    // 0x0A18(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A20[0x10];                                     // 0x0A20(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterFury(bool bOp);
	void FClipLowerBodyYawByDirection();
	void FShiftSecondJump();
	void GetSynergyRideAnimation(const struct FAnimUpdateContext& PoseContext);
	void GetSynergyRideStartAnimation(const struct FAnimUpdateContext& PoseContext);
	void OnTagUpdated(const struct FGameplayTag& TagUpdated, bool TagExists);
	void UpdateSynergyRideStartNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkAnimInstance">();
	}
	static class UHulkAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkAnimInstance>();
	}
};
static_assert(alignof(UHulkAnimInstance) == 0x000010, "Wrong alignment on UHulkAnimInstance");
static_assert(sizeof(UHulkAnimInstance) == 0x000A30, "Wrong size on UHulkAnimInstance");
static_assert(offsetof(UHulkAnimInstance, SynergyRideTag) == 0x000900, "Member 'UHulkAnimInstance::SynergyRideTag' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, SynergyRideGatheringTag) == 0x00090C, "Member 'UHulkAnimInstance::SynergyRideGatheringTag' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VJumpLandAnimStartHeight) == 0x000918, "Member 'UHulkAnimInstance::VJumpLandAnimStartHeight' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, AbilityYawInterpSpeed) == 0x00091C, "Member 'UHulkAnimInstance::AbilityYawInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bNeedToClipLowerBodyYaw) == 0x000920, "Member 'UHulkAnimInstance::bNeedToClipLowerBodyYaw' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, LandMovementToGround) == 0x000924, "Member 'UHulkAnimInstance::LandMovementToGround' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VIsClimbing) == 0x000928, "Member 'UHulkAnimInstance::VIsClimbing' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VShiftJumpfromWall) == 0x000929, "Member 'UHulkAnimInstance::VShiftJumpfromWall' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VClimbDirection) == 0x00092C, "Member 'UHulkAnimInstance::VClimbDirection' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, RootYawForTransition) == 0x000930, "Member 'UHulkAnimInstance::RootYawForTransition' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VIsInShiftJump) == 0x000934, "Member 'UHulkAnimInstance::VIsInShiftJump' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, VIsInShiftJumpLand) == 0x000935, "Member 'UHulkAnimInstance::VIsInShiftJumpLand' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, ShiftJumpDirection) == 0x000938, "Member 'UHulkAnimInstance::ShiftJumpDirection' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bInSynergyRideState) == 0x00093C, "Member 'UHulkAnimInstance::bInSynergyRideState' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bInSynergyRideStateBlend) == 0x00093E, "Member 'UHulkAnimInstance::bInSynergyRideStateBlend' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bInSynergyRideStartBlend) == 0x00093F, "Member 'UHulkAnimInstance::bInSynergyRideStartBlend' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bSynergyRideState_Enter) == 0x000940, "Member 'UHulkAnimInstance::bSynergyRideState_Enter' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bSynergyRideState_Exit) == 0x000941, "Member 'UHulkAnimInstance::bSynergyRideState_Exit' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bInSynergyRideState_Gathering) == 0x000942, "Member 'UHulkAnimInstance::bInSynergyRideState_Gathering' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, SynergyRideState_BeRide) == 0x000943, "Member 'UHulkAnimInstance::SynergyRideState_BeRide' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bFullSpace_ShiftJumps_To_Ground) == 0x000944, "Member 'UHulkAnimInstance::bFullSpace_ShiftJumps_To_Ground' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bFullSpace_ShiftJumps_To_LandRecovery) == 0x000945, "Member 'UHulkAnimInstance::bFullSpace_ShiftJumps_To_LandRecovery' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bFullSpace_LandRecovery_To_Ground) == 0x000946, "Member 'UHulkAnimInstance::bFullSpace_LandRecovery_To_Ground' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bShiftJumps_Start_To_Other) == 0x000947, "Member 'UHulkAnimInstance::bShiftJumps_Start_To_Other' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_Center_To_ToLeft) == 0x000948, "Member 'UHulkAnimInstance::bClimb_Center_To_ToLeft' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_CenterToLeft_To_LeftIdle) == 0x000949, "Member 'UHulkAnimInstance::bClimb_CenterToLeft_To_LeftIdle' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_CenterToLeft_To_Center) == 0x00094A, "Member 'UHulkAnimInstance::bClimb_CenterToLeft_To_Center' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_LeftIdle_To_ReverseToLeft) == 0x00094B, "Member 'UHulkAnimInstance::bClimb_LeftIdle_To_ReverseToLeft' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_LeftIdle_To_LeftToCenter) == 0x00094C, "Member 'UHulkAnimInstance::bClimb_LeftIdle_To_LeftToCenter' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_LeftToCenter_To_Center) == 0x00094D, "Member 'UHulkAnimInstance::bClimb_LeftToCenter_To_Center' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_Center_To_ToRight) == 0x00094E, "Member 'UHulkAnimInstance::bClimb_Center_To_ToRight' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_RightIdle_To_RightToCenter) == 0x00094F, "Member 'UHulkAnimInstance::bClimb_RightIdle_To_RightToCenter' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_RightIdle_To_ReverseToRight) == 0x000950, "Member 'UHulkAnimInstance::bClimb_RightIdle_To_ReverseToRight' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_LeftToRightConduit_To_Center) == 0x000951, "Member 'UHulkAnimInstance::bClimb_LeftToRightConduit_To_Center' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bClimb_LeftToRightConduit_To_RightIdle) == 0x000952, "Member 'UHulkAnimInstance::bClimb_LeftToRightConduit_To_RightIdle' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, bShouldUseAO) == 0x000953, "Member 'UHulkAnimInstance::bShouldUseAO' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, SynergyRideStartBlendDistanceRange) == 0x000958, "Member 'UHulkAnimInstance::SynergyRideStartBlendDistanceRange' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, HulkMoveLogicBaseComponent) == 0x0009F8, "Member 'UHulkAnimInstance::HulkMoveLogicBaseComponent' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance, Ability_101198) == 0x000A18, "Member 'UHulkAnimInstance::Ability_101198' has a wrong offset!");

// Class Hero_1011.HulkAnimInstance_101197
// 0x0020 (0x0440 - 0x0420)
class UHulkAnimInstance_101197 final : public UAnimInstance
{
public:
	uint8                                         Pad_418[0x18];                                     // 0x0418(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsAccelerating;                                    // 0x0430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState;                               // 0x0431(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState_Gathering;                     // 0x0432(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState_Turning;                       // 0x0433(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState_Gathering_Turning;             // 0x0434(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForward;                                        // 0x0435(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_436[0x2];                                      // 0x0436(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Velocity;                                          // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReleantSynergyRideNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkAnimInstance_101197">();
	}
	static class UHulkAnimInstance_101197* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkAnimInstance_101197>();
	}
};
static_assert(alignof(UHulkAnimInstance_101197) == 0x000010, "Wrong alignment on UHulkAnimInstance_101197");
static_assert(sizeof(UHulkAnimInstance_101197) == 0x000440, "Wrong size on UHulkAnimInstance_101197");
static_assert(offsetof(UHulkAnimInstance_101197, IsAccelerating) == 0x000430, "Member 'UHulkAnimInstance_101197::IsAccelerating' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, bInSynergyRideState) == 0x000431, "Member 'UHulkAnimInstance_101197::bInSynergyRideState' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, bInSynergyRideState_Gathering) == 0x000432, "Member 'UHulkAnimInstance_101197::bInSynergyRideState_Gathering' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, bInSynergyRideState_Turning) == 0x000433, "Member 'UHulkAnimInstance_101197::bInSynergyRideState_Turning' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, bInSynergyRideState_Gathering_Turning) == 0x000434, "Member 'UHulkAnimInstance_101197::bInSynergyRideState_Gathering_Turning' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, bIsForward) == 0x000435, "Member 'UHulkAnimInstance_101197::bIsForward' has a wrong offset!");
static_assert(offsetof(UHulkAnimInstance_101197, Velocity) == 0x000438, "Member 'UHulkAnimInstance_101197::Velocity' has a wrong offset!");

// Class Hero_1011.HulkBannerAnimInstance
// 0x0010 (0x0910 - 0x0900)
class UHulkBannerAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsBattlingOrUsingWeapon;                          // 0x0900(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_901[0xF];                                      // 0x0901(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetermineGroundMotionAnim_Implementation(int32* AnimIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkBannerAnimInstance">();
	}
	static class UHulkBannerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkBannerAnimInstance>();
	}
};
static_assert(alignof(UHulkBannerAnimInstance) == 0x000010, "Wrong alignment on UHulkBannerAnimInstance");
static_assert(sizeof(UHulkBannerAnimInstance) == 0x000910, "Wrong size on UHulkBannerAnimInstance");
static_assert(offsetof(UHulkBannerAnimInstance, bIsBattlingOrUsingWeapon) == 0x000900, "Member 'UHulkBannerAnimInstance::bIsBattlingOrUsingWeapon' has a wrong offset!");

// Class Hero_1011.Projectile_101121_AnimInstance
// 0x0010 (0x0910 - 0x0900)
class UProjectile_101121_AnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         CurrentTime;                                       // 0x0900(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendValue;                                        // 0x0904(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BlendAlphaCurve;                                   // 0x0908(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_101121_AnimInstance">();
	}
	static class UProjectile_101121_AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectile_101121_AnimInstance>();
	}
};
static_assert(alignof(UProjectile_101121_AnimInstance) == 0x000010, "Wrong alignment on UProjectile_101121_AnimInstance");
static_assert(sizeof(UProjectile_101121_AnimInstance) == 0x000910, "Wrong size on UProjectile_101121_AnimInstance");
static_assert(offsetof(UProjectile_101121_AnimInstance, CurrentTime) == 0x000900, "Member 'UProjectile_101121_AnimInstance::CurrentTime' has a wrong offset!");
static_assert(offsetof(UProjectile_101121_AnimInstance, BlendValue) == 0x000904, "Member 'UProjectile_101121_AnimInstance::BlendValue' has a wrong offset!");
static_assert(offsetof(UProjectile_101121_AnimInstance, BlendAlphaCurve) == 0x000908, "Member 'UProjectile_101121_AnimInstance::BlendAlphaCurve' has a wrong offset!");

// Class Hero_1011.HulkBannerCharacter
// 0x00A0 (0x1860 - 0x17C0)
class AHulkBannerCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bNeedResetRoolbackInfo;                            // 0x17B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B9[0x7];                                     // 0x17B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRecoverBuffApplyFailedDelegate;                  // 0x17C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BannaerTag;                                        // 0x17D0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HeroHulkTag;                                       // 0x17DC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MonsterHulkTag;                                    // 0x17E8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MorphTag;                                          // 0x17F4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HeroToBannerID;                                    // 0x1800(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MonsterToHeroID;                                   // 0x1804(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MonsterToBannerID;                                 // 0x1808(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BannerSculptAbility;                               // 0x180C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerStartSmashTime;                              // 0x1810(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviousSculptID;                                  // 0x1814(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRecoverBuffApplyFailed;                         // 0x1818(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1819[0x3];                                     // 0x1819(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnergyRegenStartTime;                              // 0x181C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1820[0x8];                                     // 0x1820(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHulkBannerMoveLogicBaseComponent*      HulkBannerMoveLogic;                               // 0x1828(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelMultiCapsuleComponent*           SynergyExtraCapsuleComponent;                      // 0x1830(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SynergyRideTag;                                    // 0x1838(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1844[0x4];                                     // 0x1844(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SynergyExtraCapsuleRelativeLocation;               // 0x1848(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetServerStartSmashTime();
	bool IsRecoverBuffApplyFailed();
	bool IsShiftJump();
	void K2_CacheEnergyData();
	void OnRep_IsRecoverBuffApplyFailed();
	void OnSculptChanged(const int32 SculptID);
	void OnSingleAbilityInitialized(int32 AbilityID);
	void RecoverEnergyFromPreviousDeath();
	void RecoverHealthFromMonster(float InHealth);
	void SetEnergyWhenSpawn();
	void SetHeroHulkCachedEnergy(float InValue);
	void SetIsRecoverBuffApplyFailed(bool InFailed);
	void SetServerStartSmashTime(float InTime);
	void SetSynergyExtraCapsuleComponentEnabled(bool bEnabled);
	void TryCancelAbility(const TArray<int32>& AbilityIDs);
	void TryToClimbWhenHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

	float GetHeroHulkCachedEnergy() const;
	bool IsBanner() const;
	bool IsHeroHulk() const;
	bool IsMonsterHulk() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkBannerCharacter">();
	}
	static class AHulkBannerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHulkBannerCharacter>();
	}
};
static_assert(alignof(AHulkBannerCharacter) == 0x000010, "Wrong alignment on AHulkBannerCharacter");
static_assert(sizeof(AHulkBannerCharacter) == 0x001860, "Wrong size on AHulkBannerCharacter");
static_assert(offsetof(AHulkBannerCharacter, bNeedResetRoolbackInfo) == 0x0017B8, "Member 'AHulkBannerCharacter::bNeedResetRoolbackInfo' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, OnRecoverBuffApplyFailedDelegate) == 0x0017C0, "Member 'AHulkBannerCharacter::OnRecoverBuffApplyFailedDelegate' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, BannaerTag) == 0x0017D0, "Member 'AHulkBannerCharacter::BannaerTag' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, HeroHulkTag) == 0x0017DC, "Member 'AHulkBannerCharacter::HeroHulkTag' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, MonsterHulkTag) == 0x0017E8, "Member 'AHulkBannerCharacter::MonsterHulkTag' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, MorphTag) == 0x0017F4, "Member 'AHulkBannerCharacter::MorphTag' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, HeroToBannerID) == 0x001800, "Member 'AHulkBannerCharacter::HeroToBannerID' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, MonsterToHeroID) == 0x001804, "Member 'AHulkBannerCharacter::MonsterToHeroID' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, MonsterToBannerID) == 0x001808, "Member 'AHulkBannerCharacter::MonsterToBannerID' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, BannerSculptAbility) == 0x00180C, "Member 'AHulkBannerCharacter::BannerSculptAbility' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, ServerStartSmashTime) == 0x001810, "Member 'AHulkBannerCharacter::ServerStartSmashTime' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, PreviousSculptID) == 0x001814, "Member 'AHulkBannerCharacter::PreviousSculptID' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, bIsRecoverBuffApplyFailed) == 0x001818, "Member 'AHulkBannerCharacter::bIsRecoverBuffApplyFailed' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, EnergyRegenStartTime) == 0x00181C, "Member 'AHulkBannerCharacter::EnergyRegenStartTime' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, HulkBannerMoveLogic) == 0x001828, "Member 'AHulkBannerCharacter::HulkBannerMoveLogic' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, SynergyExtraCapsuleComponent) == 0x001830, "Member 'AHulkBannerCharacter::SynergyExtraCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, SynergyRideTag) == 0x001838, "Member 'AHulkBannerCharacter::SynergyRideTag' has a wrong offset!");
static_assert(offsetof(AHulkBannerCharacter, SynergyExtraCapsuleRelativeLocation) == 0x001848, "Member 'AHulkBannerCharacter::SynergyExtraCapsuleRelativeLocation' has a wrong offset!");

// Class Hero_1011.HulkBannerChildActor
// 0x0000 (0x0A40 - 0x0A40)
class AHulkBannerChildActor : public AMarvelCharacterChildActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkBannerChildActor">();
	}
	static class AHulkBannerChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHulkBannerChildActor>();
	}
};
static_assert(alignof(AHulkBannerChildActor) == 0x000008, "Wrong alignment on AHulkBannerChildActor");
static_assert(sizeof(AHulkBannerChildActor) == 0x000A40, "Wrong size on AHulkBannerChildActor");

// Class Hero_1011.BannerBaseChildActor
// 0x0028 (0x0A68 - 0x0A40)
class ABannerBaseChildActor : public AHulkBannerChildActor
{
public:
	class USkeletalMeshComponent*                 GrenadeAMesh;                                      // 0x0A40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0A48(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           LoopTimerHandle;                                   // 0x0A50(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ChangeContainerState();
	void ClearLoopTimer();
	void SetLoopTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannerBaseChildActor">();
	}
	static class ABannerBaseChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABannerBaseChildActor>();
	}
};
static_assert(alignof(ABannerBaseChildActor) == 0x000008, "Wrong alignment on ABannerBaseChildActor");
static_assert(sizeof(ABannerBaseChildActor) == 0x000A68, "Wrong size on ABannerBaseChildActor");
static_assert(offsetof(ABannerBaseChildActor, GrenadeAMesh) == 0x000A40, "Member 'ABannerBaseChildActor::GrenadeAMesh' has a wrong offset!");
static_assert(offsetof(ABannerBaseChildActor, Mid) == 0x000A48, "Member 'ABannerBaseChildActor::Mid' has a wrong offset!");
static_assert(offsetof(ABannerBaseChildActor, LoopTimerHandle) == 0x000A50, "Member 'ABannerBaseChildActor::LoopTimerHandle' has a wrong offset!");

// Class Hero_1011.HulkBannerAudioComponent
// 0x0000 (0x0C98 - 0x0C98)
class UHulkBannerAudioComponent final : public UCharacterAudioComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkBannerAudioComponent">();
	}
	static class UHulkBannerAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkBannerAudioComponent>();
	}
};
static_assert(alignof(UHulkBannerAudioComponent) == 0x000008, "Wrong alignment on UHulkBannerAudioComponent");
static_assert(sizeof(UHulkBannerAudioComponent) == 0x000C98, "Wrong size on UHulkBannerAudioComponent");

// Class Hero_1011.HulkBannerMoveLogicBaseComponent
// 0x0260 (0x0650 - 0x03F0)
class UHulkBannerMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	struct FHulkJumpParam                         JumpParam;                                         // 0x03F0(0x0078)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VRunningAbilityYaw;                                // 0x0468(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VLowerBodyYaw;                                     // 0x046C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInShiftJump;                                    // 0x0470(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShiftJumpLaunched;                              // 0x0471(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInShiftJumpUpState;                             // 0x0472(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_473[0x1];                                      // 0x0473(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShiftJumpInitialSpeed;                             // 0x0474(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShiftJumpInitialPitch;                             // 0x0478(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterShiftJumpLand;                            // 0x047C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47D[0x3];                                      // 0x047D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpPrediction_UpHeight;                           // 0x0480(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpPrediction_DownHeight;                         // 0x0484(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpPrediction_UpSeconds;                          // 0x0488(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpPrediction_DownSeconds;                        // 0x048C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ShiftJumpPawnCollisionRecoveryTimer;               // 0x0490(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ShiftJumpRecoveryTimer;                            // 0x04A8(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShiftJumpAilityCancelled;                       // 0x04C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHulkShiftJumpLaunched;                           // 0x04C8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHulkShiftJumpLanded;                             // 0x04D8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHulkShiftJumpInterrupted;                        // 0x04E8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHulkShiftJumpStopped;                            // 0x04F8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         ShiftJumpCurrentCount;                             // 0x0508(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShiftJumpMaxCount;                                 // 0x050C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CacheGravityScale;                                 // 0x0510(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasRecoveryShiftJumpCamera;                       // 0x0514(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_515[0x3];                                      // 0x0515(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CacheMaxAcceleration;                              // 0x0518(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedLandAnimInShiftJump;                          // 0x051C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPreShiftJump;                                   // 0x051D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51E[0x2];                                      // 0x051E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShiftJumpHoldingTime;                              // 0x0520(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFallingBlocked;                                 // 0x0524(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_525[0x3];                                      // 0x0525(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      HulkClimbableTypes;                                // 0x0528(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsClimbDebugDrawEnable;                           // 0x0538(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_539[0x7];                                      // 0x0539(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        CheckPointRelaitiveLocations;                      // 0x0540(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHulkClimbParam                        ClimbParam;                                        // 0x0550(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_560[0x10];                                     // 0x0560(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EMovementMode                                 MovementMode;                                      // 0x0570(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x1F];                                     // 0x0571(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	ECLIMBSTATE                                   CLIMBSTATE;                                        // 0x0590(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_591[0x3];                                      // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbYaw;                                          // 0x0594(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       SphereComponent;                                   // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A0[0x4];                                      // 0x05A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsShiftJumpfromWall;                              // 0x05A4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A5[0x3];                                      // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           IgnorePawnCollisionTag;                            // 0x05A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x14];                                     // 0x05B4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ClimbCompCache;                                    // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             ClimbCompTransform;                                // 0x05D0(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ClimbLocation;                                     // 0x0630(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckClimbedWallValid();
	void ClientEnterClimb(const struct FVector& Location, const struct FQuat& Rotation);
	void ClientLeaveClimb(const struct FVector& Location);
	void ClientOnLanded(const struct FHitResult& Hit, bool IsServerShiftJumpCancelled);
	void IgnorePawnCollision(bool bIgnoreCollision);
	bool IsShiftJumping();
	void MulticastActivateShiftJump(float JumpUpSeconds, float JumpDownSeconds, float JumpUpHeight, float JumpDownHeight, bool bInOnWall);
	void MulticastCancelShiftJump();
	void OnFallingBlockedCallback(const struct FHitResult& Hit);
	void OnLandedCallback(const struct FHitResult& Hit);
	void OnRep_InShiftJumpUpState();
	void OnTagUpdated(const struct FGameplayTag& TagUpdated, bool TagExists);
	void PredictShiftJumpDataWhenPressed(const struct FVector& PredictVelocity, bool bFromWall, TArray<struct FVector>* PredictionPath, float MaxFallSeconds, float MaxJumpHeightDown);
	struct FVector PredictShiftJumpVelocity(float PredictSpeed, bool bRemoteRole, const struct FRotator& InRotator);
	void ResetCachedMoveParam();
	void ServerSetClimbDirection(float Yaw);
	void ServerSetClimbState(ECLIMBSTATE State);
	void SetClimbParam(const struct FHulkClimbParam& InClimbParam);
	void SetGravityScale(float InGravityScale);
	void SetHulkJumpParam(const struct FHulkJumpParam& InJumpParam);
	void ShiftJump(bool bInOnWall, float PawnCollisionIgnoreDuration);
	void ShiftJumpLaunchCharacter();
	void ShiftJumpWithCustomSpeed(float InitSpeed, bool bIsOnWall, float PawnCollisionIgnoreDuration);
	void StopShiftJump(bool bCancelNormalJump, bool bResetCacheParam);
	void StopShiftJumpMoving();
	void TriggerClimbToShiftTurn();
	void TryToClimb();
	void UpdateClimbCustomMove(float DeltaTime);
	void UpdateShiftJumpUpState(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);

	bool IsClimbing() const;
	bool IsClimbingWithAbilityStateCheck() const;
	bool IsHanging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkBannerMoveLogicBaseComponent">();
	}
	static class UHulkBannerMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkBannerMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UHulkBannerMoveLogicBaseComponent) == 0x000010, "Wrong alignment on UHulkBannerMoveLogicBaseComponent");
static_assert(sizeof(UHulkBannerMoveLogicBaseComponent) == 0x000650, "Wrong size on UHulkBannerMoveLogicBaseComponent");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, JumpParam) == 0x0003F0, "Member 'UHulkBannerMoveLogicBaseComponent::JumpParam' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, VRunningAbilityYaw) == 0x000468, "Member 'UHulkBannerMoveLogicBaseComponent::VRunningAbilityYaw' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, VLowerBodyYaw) == 0x00046C, "Member 'UHulkBannerMoveLogicBaseComponent::VLowerBodyYaw' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsInShiftJump) == 0x000470, "Member 'UHulkBannerMoveLogicBaseComponent::bIsInShiftJump' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsShiftJumpLaunched) == 0x000471, "Member 'UHulkBannerMoveLogicBaseComponent::bIsShiftJumpLaunched' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsInShiftJumpUpState) == 0x000472, "Member 'UHulkBannerMoveLogicBaseComponent::bIsInShiftJumpUpState' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpInitialSpeed) == 0x000474, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpInitialSpeed' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpInitialPitch) == 0x000478, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpInitialPitch' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bCanEnterShiftJumpLand) == 0x00047C, "Member 'UHulkBannerMoveLogicBaseComponent::bCanEnterShiftJumpLand' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, JumpPrediction_UpHeight) == 0x000480, "Member 'UHulkBannerMoveLogicBaseComponent::JumpPrediction_UpHeight' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, JumpPrediction_DownHeight) == 0x000484, "Member 'UHulkBannerMoveLogicBaseComponent::JumpPrediction_DownHeight' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, JumpPrediction_UpSeconds) == 0x000488, "Member 'UHulkBannerMoveLogicBaseComponent::JumpPrediction_UpSeconds' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, JumpPrediction_DownSeconds) == 0x00048C, "Member 'UHulkBannerMoveLogicBaseComponent::JumpPrediction_DownSeconds' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpPawnCollisionRecoveryTimer) == 0x000490, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpPawnCollisionRecoveryTimer' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpRecoveryTimer) == 0x0004A8, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpRecoveryTimer' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsShiftJumpAilityCancelled) == 0x0004C0, "Member 'UHulkBannerMoveLogicBaseComponent::bIsShiftJumpAilityCancelled' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, OnHulkShiftJumpLaunched) == 0x0004C8, "Member 'UHulkBannerMoveLogicBaseComponent::OnHulkShiftJumpLaunched' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, OnHulkShiftJumpLanded) == 0x0004D8, "Member 'UHulkBannerMoveLogicBaseComponent::OnHulkShiftJumpLanded' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, OnHulkShiftJumpInterrupted) == 0x0004E8, "Member 'UHulkBannerMoveLogicBaseComponent::OnHulkShiftJumpInterrupted' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, OnHulkShiftJumpStopped) == 0x0004F8, "Member 'UHulkBannerMoveLogicBaseComponent::OnHulkShiftJumpStopped' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpCurrentCount) == 0x000508, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpCurrentCount' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpMaxCount) == 0x00050C, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpMaxCount' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, CacheGravityScale) == 0x000510, "Member 'UHulkBannerMoveLogicBaseComponent::CacheGravityScale' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bHasRecoveryShiftJumpCamera) == 0x000514, "Member 'UHulkBannerMoveLogicBaseComponent::bHasRecoveryShiftJumpCamera' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, CacheMaxAcceleration) == 0x000518, "Member 'UHulkBannerMoveLogicBaseComponent::CacheMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bNeedLandAnimInShiftJump) == 0x00051C, "Member 'UHulkBannerMoveLogicBaseComponent::bNeedLandAnimInShiftJump' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsPreShiftJump) == 0x00051D, "Member 'UHulkBannerMoveLogicBaseComponent::bIsPreShiftJump' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ShiftJumpHoldingTime) == 0x000520, "Member 'UHulkBannerMoveLogicBaseComponent::ShiftJumpHoldingTime' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsFallingBlocked) == 0x000524, "Member 'UHulkBannerMoveLogicBaseComponent::bIsFallingBlocked' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, HulkClimbableTypes) == 0x000528, "Member 'UHulkBannerMoveLogicBaseComponent::HulkClimbableTypes' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsClimbDebugDrawEnable) == 0x000538, "Member 'UHulkBannerMoveLogicBaseComponent::bIsClimbDebugDrawEnable' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, CheckPointRelaitiveLocations) == 0x000540, "Member 'UHulkBannerMoveLogicBaseComponent::CheckPointRelaitiveLocations' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ClimbParam) == 0x000550, "Member 'UHulkBannerMoveLogicBaseComponent::ClimbParam' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, MovementMode) == 0x000570, "Member 'UHulkBannerMoveLogicBaseComponent::MovementMode' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, CLIMBSTATE) == 0x000590, "Member 'UHulkBannerMoveLogicBaseComponent::CLIMBSTATE' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ClimbYaw) == 0x000594, "Member 'UHulkBannerMoveLogicBaseComponent::ClimbYaw' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, SphereComponent) == 0x000598, "Member 'UHulkBannerMoveLogicBaseComponent::SphereComponent' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, bIsShiftJumpfromWall) == 0x0005A4, "Member 'UHulkBannerMoveLogicBaseComponent::bIsShiftJumpfromWall' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, IgnorePawnCollisionTag) == 0x0005A8, "Member 'UHulkBannerMoveLogicBaseComponent::IgnorePawnCollisionTag' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ClimbCompCache) == 0x0005C8, "Member 'UHulkBannerMoveLogicBaseComponent::ClimbCompCache' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ClimbCompTransform) == 0x0005D0, "Member 'UHulkBannerMoveLogicBaseComponent::ClimbCompTransform' has a wrong offset!");
static_assert(offsetof(UHulkBannerMoveLogicBaseComponent, ClimbLocation) == 0x000630, "Member 'UHulkBannerMoveLogicBaseComponent::ClimbLocation' has a wrong offset!");

// Class Hero_1011.HulkCharacterMovementComponent
// 0x0000 (0x1AF0 - 0x1AF0)
class UHulkCharacterMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkCharacterMovementComponent">();
	}
	static class UHulkCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkCharacterMovementComponent>();
	}
};
static_assert(alignof(UHulkCharacterMovementComponent) == 0x000010, "Wrong alignment on UHulkCharacterMovementComponent");
static_assert(sizeof(UHulkCharacterMovementComponent) == 0x001AF0, "Wrong size on UHulkCharacterMovementComponent");

// Class Hero_1011.HulkHeroAnimInstance
// 0x0010 (0x0A40 - 0x0A30)
class UHulkHeroAnimInstance final : public UHulkAnimInstance
{
public:
	bool                                          bVClimbDirectionGreaterThan180;                    // 0x0A30(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShiftJumpHoldTimeGreaterThanZero;                 // 0x0A31(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A32[0xE];                                      // 0x0A32(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkHeroAnimInstance">();
	}
	static class UHulkHeroAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkHeroAnimInstance>();
	}
};
static_assert(alignof(UHulkHeroAnimInstance) == 0x000010, "Wrong alignment on UHulkHeroAnimInstance");
static_assert(sizeof(UHulkHeroAnimInstance) == 0x000A40, "Wrong size on UHulkHeroAnimInstance");
static_assert(offsetof(UHulkHeroAnimInstance, bVClimbDirectionGreaterThan180) == 0x000A30, "Member 'UHulkHeroAnimInstance::bVClimbDirectionGreaterThan180' has a wrong offset!");
static_assert(offsetof(UHulkHeroAnimInstance, bShiftJumpHoldTimeGreaterThanZero) == 0x000A31, "Member 'UHulkHeroAnimInstance::bShiftJumpHoldTimeGreaterThanZero' has a wrong offset!");

// Class Hero_1011.HulkMonsterAnimInstance
// 0x0010 (0x0A40 - 0x0A30)
class UHulkMonsterAnimInstance final : public UHulkAnimInstance
{
public:
	bool                                          bVClimbDirectionGreaterThan180;                    // 0x0A30(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShiftJumpHoldTimeGreaterThanZero;                 // 0x0A31(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A32[0xE];                                      // 0x0A32(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HulkMonsterAnimInstance">();
	}
	static class UHulkMonsterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHulkMonsterAnimInstance>();
	}
};
static_assert(alignof(UHulkMonsterAnimInstance) == 0x000010, "Wrong alignment on UHulkMonsterAnimInstance");
static_assert(sizeof(UHulkMonsterAnimInstance) == 0x000A40, "Wrong size on UHulkMonsterAnimInstance");
static_assert(offsetof(UHulkMonsterAnimInstance, bVClimbDirectionGreaterThan180) == 0x000A30, "Member 'UHulkMonsterAnimInstance::bVClimbDirectionGreaterThan180' has a wrong offset!");
static_assert(offsetof(UHulkMonsterAnimInstance, bShiftJumpHoldTimeGreaterThanZero) == 0x000A31, "Member 'UHulkMonsterAnimInstance::bShiftJumpHoldTimeGreaterThanZero' has a wrong offset!");

// Class Hero_1011.TabData_1011
// 0x0000 (0x0050 - 0x0050)
class UTabData_1011 : public UHeroTabDataBase
{
public:
	void AddTabDataValue(class AActor* InSource, class AActor* InTarget, int32 BuffID);
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnBuffApplied(class UAbilitySystemComponent* Source, class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecStackHandle, const struct FActiveGameplayEffectHandle& EffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1011">();
	}
	static class UTabData_1011* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1011>();
	}
};
static_assert(alignof(UTabData_1011) == 0x000008, "Wrong alignment on UTabData_1011");
static_assert(sizeof(UTabData_1011) == 0x000050, "Wrong size on UTabData_1011");

}

