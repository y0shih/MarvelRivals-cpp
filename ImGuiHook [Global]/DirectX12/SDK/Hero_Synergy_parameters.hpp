#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_Synergy

#include "Basic.hpp"

#include "Marvel_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Hero_Synergy_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK::Params
{

// Function Hero_Synergy.MarvelBackTrackAbility.DelayStartRecord
// 0x0001 (0x0001 - 0x0000)
struct MarvelBackTrackAbility_DelayStartRecord final
{
public:
	bool                                          bSetDelay;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_DelayStartRecord) == 0x000001, "Wrong alignment on MarvelBackTrackAbility_DelayStartRecord");
static_assert(sizeof(MarvelBackTrackAbility_DelayStartRecord) == 0x000001, "Wrong size on MarvelBackTrackAbility_DelayStartRecord");
static_assert(offsetof(MarvelBackTrackAbility_DelayStartRecord, bSetDelay) == 0x000000, "Member 'MarvelBackTrackAbility_DelayStartRecord::bSetDelay' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.IsHoldMode
// 0x0001 (0x0001 - 0x0000)
struct MarvelBackTrackAbility_IsHoldMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_IsHoldMode) == 0x000001, "Wrong alignment on MarvelBackTrackAbility_IsHoldMode");
static_assert(sizeof(MarvelBackTrackAbility_IsHoldMode) == 0x000001, "Wrong size on MarvelBackTrackAbility_IsHoldMode");
static_assert(offsetof(MarvelBackTrackAbility_IsHoldMode, ReturnValue) == 0x000000, "Member 'MarvelBackTrackAbility_IsHoldMode::ReturnValue' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.OnCharacterMovementPreUpdated
// 0x0004 (0x0004 - 0x0000)
struct MarvelBackTrackAbility_OnCharacterMovementPreUpdated final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_OnCharacterMovementPreUpdated) == 0x000004, "Wrong alignment on MarvelBackTrackAbility_OnCharacterMovementPreUpdated");
static_assert(sizeof(MarvelBackTrackAbility_OnCharacterMovementPreUpdated) == 0x000004, "Wrong size on MarvelBackTrackAbility_OnCharacterMovementPreUpdated");
static_assert(offsetof(MarvelBackTrackAbility_OnCharacterMovementPreUpdated, DeltaTime) == 0x000000, "Member 'MarvelBackTrackAbility_OnCharacterMovementPreUpdated::DeltaTime' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.OnCharTranslatedByPortal
// 0x0008 (0x0008 - 0x0000)
struct MarvelBackTrackAbility_OnCharTranslatedByPortal final
{
public:
	class APortalViewActor*                       InPortalActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_OnCharTranslatedByPortal) == 0x000008, "Wrong alignment on MarvelBackTrackAbility_OnCharTranslatedByPortal");
static_assert(sizeof(MarvelBackTrackAbility_OnCharTranslatedByPortal) == 0x000008, "Wrong size on MarvelBackTrackAbility_OnCharTranslatedByPortal");
static_assert(offsetof(MarvelBackTrackAbility_OnCharTranslatedByPortal, InPortalActor) == 0x000000, "Member 'MarvelBackTrackAbility_OnCharTranslatedByPortal::InPortalActor' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.OnClientAckMoveWithStamp
// 0x0020 (0x0020 - 0x0000)
struct MarvelBackTrackAbility_OnClientAckMoveWithStamp final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_OnClientAckMoveWithStamp) == 0x000008, "Wrong alignment on MarvelBackTrackAbility_OnClientAckMoveWithStamp");
static_assert(sizeof(MarvelBackTrackAbility_OnClientAckMoveWithStamp) == 0x000020, "Wrong size on MarvelBackTrackAbility_OnClientAckMoveWithStamp");
static_assert(offsetof(MarvelBackTrackAbility_OnClientAckMoveWithStamp, Timestamp) == 0x000000, "Member 'MarvelBackTrackAbility_OnClientAckMoveWithStamp::Timestamp' has a wrong offset!");
static_assert(offsetof(MarvelBackTrackAbility_OnClientAckMoveWithStamp, Location) == 0x000008, "Member 'MarvelBackTrackAbility_OnClientAckMoveWithStamp::Location' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.OnLivingStateChanged
// 0x0001 (0x0001 - 0x0000)
struct MarvelBackTrackAbility_OnLivingStateChanged final
{
public:
	EPlayerLivingState                            LivingState;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_OnLivingStateChanged) == 0x000001, "Wrong alignment on MarvelBackTrackAbility_OnLivingStateChanged");
static_assert(sizeof(MarvelBackTrackAbility_OnLivingStateChanged) == 0x000001, "Wrong size on MarvelBackTrackAbility_OnLivingStateChanged");
static_assert(offsetof(MarvelBackTrackAbility_OnLivingStateChanged, LivingState) == 0x000000, "Member 'MarvelBackTrackAbility_OnLivingStateChanged::LivingState' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.OnLongPressRelease
// 0x0004 (0x0004 - 0x0000)
struct MarvelBackTrackAbility_OnLongPressRelease final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_OnLongPressRelease) == 0x000004, "Wrong alignment on MarvelBackTrackAbility_OnLongPressRelease");
static_assert(sizeof(MarvelBackTrackAbility_OnLongPressRelease) == 0x000004, "Wrong size on MarvelBackTrackAbility_OnLongPressRelease");
static_assert(offsetof(MarvelBackTrackAbility_OnLongPressRelease, TimeHeld) == 0x000000, "Member 'MarvelBackTrackAbility_OnLongPressRelease::TimeHeld' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.OnLongPressTimeOverMaxHoldTime
// 0x0004 (0x0004 - 0x0000)
struct MarvelBackTrackAbility_OnLongPressTimeOverMaxHoldTime final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_OnLongPressTimeOverMaxHoldTime) == 0x000004, "Wrong alignment on MarvelBackTrackAbility_OnLongPressTimeOverMaxHoldTime");
static_assert(sizeof(MarvelBackTrackAbility_OnLongPressTimeOverMaxHoldTime) == 0x000004, "Wrong size on MarvelBackTrackAbility_OnLongPressTimeOverMaxHoldTime");
static_assert(offsetof(MarvelBackTrackAbility_OnLongPressTimeOverMaxHoldTime, TimeHeld) == 0x000000, "Member 'MarvelBackTrackAbility_OnLongPressTimeOverMaxHoldTime::TimeHeld' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.OnServerHandleClientMoveWithStamp
// 0x0020 (0x0020 - 0x0000)
struct MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp) == 0x000008, "Wrong alignment on MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp");
static_assert(sizeof(MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp) == 0x000020, "Wrong size on MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp");
static_assert(offsetof(MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp, Timestamp) == 0x000000, "Member 'MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp::Timestamp' has a wrong offset!");
static_assert(offsetof(MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp, Location) == 0x000008, "Member 'MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp::Location' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.RecordState
// 0x0020 (0x0020 - 0x0000)
struct MarvelBackTrackAbility_RecordState final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_RecordState) == 0x000008, "Wrong alignment on MarvelBackTrackAbility_RecordState");
static_assert(sizeof(MarvelBackTrackAbility_RecordState) == 0x000020, "Wrong size on MarvelBackTrackAbility_RecordState");
static_assert(offsetof(MarvelBackTrackAbility_RecordState, Timestamp) == 0x000000, "Member 'MarvelBackTrackAbility_RecordState::Timestamp' has a wrong offset!");
static_assert(offsetof(MarvelBackTrackAbility_RecordState, Location) == 0x000008, "Member 'MarvelBackTrackAbility_RecordState::Location' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.ServerCheckClientLocValid
// 0x0020 (0x0020 - 0x0000)
struct MarvelBackTrackAbility_ServerCheckClientLocValid final
{
public:
	struct FVector                                InTargetLoc;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStrictCheck;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MarvelBackTrackAbility_ServerCheckClientLocValid) == 0x000008, "Wrong alignment on MarvelBackTrackAbility_ServerCheckClientLocValid");
static_assert(sizeof(MarvelBackTrackAbility_ServerCheckClientLocValid) == 0x000020, "Wrong size on MarvelBackTrackAbility_ServerCheckClientLocValid");
static_assert(offsetof(MarvelBackTrackAbility_ServerCheckClientLocValid, InTargetLoc) == 0x000000, "Member 'MarvelBackTrackAbility_ServerCheckClientLocValid::InTargetLoc' has a wrong offset!");
static_assert(offsetof(MarvelBackTrackAbility_ServerCheckClientLocValid, bStrictCheck) == 0x000018, "Member 'MarvelBackTrackAbility_ServerCheckClientLocValid::bStrictCheck' has a wrong offset!");
static_assert(offsetof(MarvelBackTrackAbility_ServerCheckClientLocValid, ReturnValue) == 0x000019, "Member 'MarvelBackTrackAbility_ServerCheckClientLocValid::ReturnValue' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.ServerInterrupt
// 0x0018 (0x0018 - 0x0000)
struct MarvelBackTrackAbility_ServerInterrupt final
{
public:
	struct FVector                                InClientLocation;                                  // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_ServerInterrupt) == 0x000008, "Wrong alignment on MarvelBackTrackAbility_ServerInterrupt");
static_assert(sizeof(MarvelBackTrackAbility_ServerInterrupt) == 0x000018, "Wrong size on MarvelBackTrackAbility_ServerInterrupt");
static_assert(offsetof(MarvelBackTrackAbility_ServerInterrupt, InClientLocation) == 0x000000, "Member 'MarvelBackTrackAbility_ServerInterrupt::InClientLocation' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.StopRecordState
// 0x0001 (0x0001 - 0x0000)
struct MarvelBackTrackAbility_StopRecordState final
{
public:
	bool                                          bClearData;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarvelBackTrackAbility_StopRecordState) == 0x000001, "Wrong alignment on MarvelBackTrackAbility_StopRecordState");
static_assert(sizeof(MarvelBackTrackAbility_StopRecordState) == 0x000001, "Wrong size on MarvelBackTrackAbility_StopRecordState");
static_assert(offsetof(MarvelBackTrackAbility_StopRecordState, bClearData) == 0x000000, "Member 'MarvelBackTrackAbility_StopRecordState::bClearData' has a wrong offset!");

// Function Hero_Synergy.MarvelBackTrackAbility.SafeMoveTo
// 0x0180 (0x0180 - 0x0000)
struct MarvelBackTrackAbility_SafeMoveTo final
{
public:
	struct FVector                                TargetLoc;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             OutHit;                                            // 0x0018(0x0160)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0178(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0179(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A[0x6];                                      // 0x017A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MarvelBackTrackAbility_SafeMoveTo) == 0x000008, "Wrong alignment on MarvelBackTrackAbility_SafeMoveTo");
static_assert(sizeof(MarvelBackTrackAbility_SafeMoveTo) == 0x000180, "Wrong size on MarvelBackTrackAbility_SafeMoveTo");
static_assert(offsetof(MarvelBackTrackAbility_SafeMoveTo, TargetLoc) == 0x000000, "Member 'MarvelBackTrackAbility_SafeMoveTo::TargetLoc' has a wrong offset!");
static_assert(offsetof(MarvelBackTrackAbility_SafeMoveTo, OutHit) == 0x000018, "Member 'MarvelBackTrackAbility_SafeMoveTo::OutHit' has a wrong offset!");
static_assert(offsetof(MarvelBackTrackAbility_SafeMoveTo, bSweep) == 0x000178, "Member 'MarvelBackTrackAbility_SafeMoveTo::bSweep' has a wrong offset!");
static_assert(offsetof(MarvelBackTrackAbility_SafeMoveTo, ReturnValue) == 0x000179, "Member 'MarvelBackTrackAbility_SafeMoveTo::ReturnValue' has a wrong offset!");

// Function Hero_Synergy.TraceComponent_100009.OnPreOutTraceResults
// 0x0168 (0x0168 - 0x0000)
struct TraceComponent_100009_OnPreOutTraceResults final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0160)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0160(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TraceComponent_100009_OnPreOutTraceResults) == 0x000008, "Wrong alignment on TraceComponent_100009_OnPreOutTraceResults");
static_assert(sizeof(TraceComponent_100009_OnPreOutTraceResults) == 0x000168, "Wrong size on TraceComponent_100009_OnPreOutTraceResults");
static_assert(offsetof(TraceComponent_100009_OnPreOutTraceResults, Hit) == 0x000000, "Member 'TraceComponent_100009_OnPreOutTraceResults::Hit' has a wrong offset!");
static_assert(offsetof(TraceComponent_100009_OnPreOutTraceResults, ReturnValue) == 0x000160, "Member 'TraceComponent_100009_OnPreOutTraceResults::ReturnValue' has a wrong offset!");

// Function Hero_Synergy.BuffManagerAbility_100009.OnAbilityActivate
// 0x0004 (0x0004 - 0x0000)
struct BuffManagerAbility_100009_OnAbilityActivate final
{
public:
	int32                                         AbilityID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BuffManagerAbility_100009_OnAbilityActivate) == 0x000004, "Wrong alignment on BuffManagerAbility_100009_OnAbilityActivate");
static_assert(sizeof(BuffManagerAbility_100009_OnAbilityActivate) == 0x000004, "Wrong size on BuffManagerAbility_100009_OnAbilityActivate");
static_assert(offsetof(BuffManagerAbility_100009_OnAbilityActivate, AbilityID) == 0x000000, "Member 'BuffManagerAbility_100009_OnAbilityActivate::AbilityID' has a wrong offset!");

// Function Hero_Synergy.BuffManagerAbility_100009.OnAbilityEnded
// 0x0004 (0x0004 - 0x0000)
struct BuffManagerAbility_100009_OnAbilityEnded final
{
public:
	int32                                         AbilityID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BuffManagerAbility_100009_OnAbilityEnded) == 0x000004, "Wrong alignment on BuffManagerAbility_100009_OnAbilityEnded");
static_assert(sizeof(BuffManagerAbility_100009_OnAbilityEnded) == 0x000004, "Wrong size on BuffManagerAbility_100009_OnAbilityEnded");
static_assert(offsetof(BuffManagerAbility_100009_OnAbilityEnded, AbilityID) == 0x000000, "Member 'BuffManagerAbility_100009_OnAbilityEnded::AbilityID' has a wrong offset!");

// Function Hero_Synergy.BuffManagerAbility_100009.OnBuffExecuted
// 0x0018 (0x0018 - 0x0000)
struct BuffManagerAbility_100009_OnBuffExecuted final
{
public:
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecStackHandle         EffectSpecHandle;                                  // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BuffManagerAbility_100009_OnBuffExecuted) == 0x000008, "Wrong alignment on BuffManagerAbility_100009_OnBuffExecuted");
static_assert(sizeof(BuffManagerAbility_100009_OnBuffExecuted) == 0x000018, "Wrong size on BuffManagerAbility_100009_OnBuffExecuted");
static_assert(offsetof(BuffManagerAbility_100009_OnBuffExecuted, AbilitySystemComponent) == 0x000000, "Member 'BuffManagerAbility_100009_OnBuffExecuted::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(BuffManagerAbility_100009_OnBuffExecuted, EffectSpecHandle) == 0x000008, "Member 'BuffManagerAbility_100009_OnBuffExecuted::EffectSpecHandle' has a wrong offset!");
static_assert(offsetof(BuffManagerAbility_100009_OnBuffExecuted, EffectHandle) == 0x000010, "Member 'BuffManagerAbility_100009_OnBuffExecuted::EffectHandle' has a wrong offset!");

// Function Hero_Synergy.BuffManagerAbility_100009.OnBuffRemoved
// 0x0768 (0x0768 - 0x0000)
struct BuffManagerAbility_100009_OnBuffRemoved final
{
public:
	struct FGameplayEffectSpec                    RemovedSpec;                                       // 0x0000(0x0760)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bPrematureRemoval;                                 // 0x0760(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_761[0x7];                                      // 0x0761(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BuffManagerAbility_100009_OnBuffRemoved) == 0x000008, "Wrong alignment on BuffManagerAbility_100009_OnBuffRemoved");
static_assert(sizeof(BuffManagerAbility_100009_OnBuffRemoved) == 0x000768, "Wrong size on BuffManagerAbility_100009_OnBuffRemoved");
static_assert(offsetof(BuffManagerAbility_100009_OnBuffRemoved, RemovedSpec) == 0x000000, "Member 'BuffManagerAbility_100009_OnBuffRemoved::RemovedSpec' has a wrong offset!");
static_assert(offsetof(BuffManagerAbility_100009_OnBuffRemoved, bPrematureRemoval) == 0x000760, "Member 'BuffManagerAbility_100009_OnBuffRemoved::bPrematureRemoval' has a wrong offset!");

// Function Hero_Synergy.BuffManagerAbility_100009.OnOwnerCollide
// 0x0190 (0x0190 - 0x0000)
struct BuffManagerAbility_100009_OnOwnerCollide final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0030(0x0160)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BuffManagerAbility_100009_OnOwnerCollide) == 0x000008, "Wrong alignment on BuffManagerAbility_100009_OnOwnerCollide");
static_assert(sizeof(BuffManagerAbility_100009_OnOwnerCollide) == 0x000190, "Wrong size on BuffManagerAbility_100009_OnOwnerCollide");
static_assert(offsetof(BuffManagerAbility_100009_OnOwnerCollide, HitComponent) == 0x000000, "Member 'BuffManagerAbility_100009_OnOwnerCollide::HitComponent' has a wrong offset!");
static_assert(offsetof(BuffManagerAbility_100009_OnOwnerCollide, OtherActor) == 0x000008, "Member 'BuffManagerAbility_100009_OnOwnerCollide::OtherActor' has a wrong offset!");
static_assert(offsetof(BuffManagerAbility_100009_OnOwnerCollide, OtherComp) == 0x000010, "Member 'BuffManagerAbility_100009_OnOwnerCollide::OtherComp' has a wrong offset!");
static_assert(offsetof(BuffManagerAbility_100009_OnOwnerCollide, NormalImpulse) == 0x000018, "Member 'BuffManagerAbility_100009_OnOwnerCollide::NormalImpulse' has a wrong offset!");
static_assert(offsetof(BuffManagerAbility_100009_OnOwnerCollide, Hit) == 0x000030, "Member 'BuffManagerAbility_100009_OnOwnerCollide::Hit' has a wrong offset!");

// Function Hero_Synergy.BuffManagerAbility_100009.OnOwnerTakeDamage
// 0x0028 (0x0028 - 0x0000)
struct BuffManagerAbility_100009_OnOwnerTakeDamage final
{
public:
	class AActor*                                 InSourceAvatar;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetAvatar;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeModifierHandle               ModifierParameterHandle;                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BuffManagerAbility_100009_OnOwnerTakeDamage) == 0x000008, "Wrong alignment on BuffManagerAbility_100009_OnOwnerTakeDamage");
static_assert(sizeof(BuffManagerAbility_100009_OnOwnerTakeDamage) == 0x000028, "Wrong size on BuffManagerAbility_100009_OnOwnerTakeDamage");
static_assert(offsetof(BuffManagerAbility_100009_OnOwnerTakeDamage, InSourceAvatar) == 0x000000, "Member 'BuffManagerAbility_100009_OnOwnerTakeDamage::InSourceAvatar' has a wrong offset!");
static_assert(offsetof(BuffManagerAbility_100009_OnOwnerTakeDamage, InTargetAvatar) == 0x000008, "Member 'BuffManagerAbility_100009_OnOwnerTakeDamage::InTargetAvatar' has a wrong offset!");
static_assert(offsetof(BuffManagerAbility_100009_OnOwnerTakeDamage, ModifierParameterHandle) == 0x000010, "Member 'BuffManagerAbility_100009_OnOwnerTakeDamage::ModifierParameterHandle' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.AddWavingData
// 0x0160 (0x0160 - 0x0000)
struct Ability_100015_AddWavingData final
{
public:
	struct FHitResult                             InHitResult;                                       // 0x0000(0x0160)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_AddWavingData) == 0x000008, "Wrong alignment on Ability_100015_AddWavingData");
static_assert(sizeof(Ability_100015_AddWavingData) == 0x000160, "Wrong size on Ability_100015_AddWavingData");
static_assert(offsetof(Ability_100015_AddWavingData, InHitResult) == 0x000000, "Member 'Ability_100015_AddWavingData::InHitResult' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.CancelRelevantSynergyAbility
// 0x0001 (0x0001 - 0x0000)
struct Ability_100015_CancelRelevantSynergyAbility final
{
public:
	bool                                          bNormalEnd;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_CancelRelevantSynergyAbility) == 0x000001, "Wrong alignment on Ability_100015_CancelRelevantSynergyAbility");
static_assert(sizeof(Ability_100015_CancelRelevantSynergyAbility) == 0x000001, "Wrong size on Ability_100015_CancelRelevantSynergyAbility");
static_assert(offsetof(Ability_100015_CancelRelevantSynergyAbility, bNormalEnd) == 0x000000, "Member 'Ability_100015_CancelRelevantSynergyAbility::bNormalEnd' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.CustomCommitSynergyCoolDown
// 0x0001 (0x0001 - 0x0000)
struct Ability_100015_CustomCommitSynergyCoolDown final
{
public:
	bool                                          bNormalEnd;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_CustomCommitSynergyCoolDown) == 0x000001, "Wrong alignment on Ability_100015_CustomCommitSynergyCoolDown");
static_assert(sizeof(Ability_100015_CustomCommitSynergyCoolDown) == 0x000001, "Wrong size on Ability_100015_CustomCommitSynergyCoolDown");
static_assert(offsetof(Ability_100015_CustomCommitSynergyCoolDown, bNormalEnd) == 0x000000, "Member 'Ability_100015_CustomCommitSynergyCoolDown::bNormalEnd' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.GetDashPortalSegments
// 0x0020 (0x0020 - 0x0000)
struct Ability_100015_GetDashPortalSegments final
{
public:
	struct FPortalSegments                        ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_GetDashPortalSegments) == 0x000008, "Wrong alignment on Ability_100015_GetDashPortalSegments");
static_assert(sizeof(Ability_100015_GetDashPortalSegments) == 0x000020, "Wrong size on Ability_100015_GetDashPortalSegments");
static_assert(offsetof(Ability_100015_GetDashPortalSegments, ReturnValue) == 0x000000, "Member 'Ability_100015_GetDashPortalSegments::ReturnValue' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.GetRelevantSynergyAbility
// 0x0010 (0x0010 - 0x0000)
struct Ability_100015_GetRelevantSynergyAbility final
{
public:
	class AMarvelBaseCharacter*                   InCharacter;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbility_100015*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_GetRelevantSynergyAbility) == 0x000008, "Wrong alignment on Ability_100015_GetRelevantSynergyAbility");
static_assert(sizeof(Ability_100015_GetRelevantSynergyAbility) == 0x000010, "Wrong size on Ability_100015_GetRelevantSynergyAbility");
static_assert(offsetof(Ability_100015_GetRelevantSynergyAbility, InCharacter) == 0x000000, "Member 'Ability_100015_GetRelevantSynergyAbility::InCharacter' has a wrong offset!");
static_assert(offsetof(Ability_100015_GetRelevantSynergyAbility, ReturnValue) == 0x000008, "Member 'Ability_100015_GetRelevantSynergyAbility::ReturnValue' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.HasActiveBond
// 0x0001 (0x0001 - 0x0000)
struct Ability_100015_HasActiveBond final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_HasActiveBond) == 0x000001, "Wrong alignment on Ability_100015_HasActiveBond");
static_assert(sizeof(Ability_100015_HasActiveBond) == 0x000001, "Wrong size on Ability_100015_HasActiveBond");
static_assert(offsetof(Ability_100015_HasActiveBond, ReturnValue) == 0x000000, "Member 'Ability_100015_HasActiveBond::ReturnValue' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.IsAbilityNormalEnd
// 0x0001 (0x0001 - 0x0000)
struct Ability_100015_IsAbilityNormalEnd final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_IsAbilityNormalEnd) == 0x000001, "Wrong alignment on Ability_100015_IsAbilityNormalEnd");
static_assert(sizeof(Ability_100015_IsAbilityNormalEnd) == 0x000001, "Wrong size on Ability_100015_IsAbilityNormalEnd");
static_assert(offsetof(Ability_100015_IsAbilityNormalEnd, ReturnValue) == 0x000000, "Member 'Ability_100015_IsAbilityNormalEnd::ReturnValue' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.OnCoopAbilityTickStateChanged
// 0x0001 (0x0001 - 0x0000)
struct Ability_100015_OnCoopAbilityTickStateChanged final
{
public:
	bool                                          bShouldAbilityTick;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_OnCoopAbilityTickStateChanged) == 0x000001, "Wrong alignment on Ability_100015_OnCoopAbilityTickStateChanged");
static_assert(sizeof(Ability_100015_OnCoopAbilityTickStateChanged) == 0x000001, "Wrong size on Ability_100015_OnCoopAbilityTickStateChanged");
static_assert(offsetof(Ability_100015_OnCoopAbilityTickStateChanged, bShouldAbilityTick) == 0x000000, "Member 'Ability_100015_OnCoopAbilityTickStateChanged::bShouldAbilityTick' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.OnOwnerGameplayTagUpdate
// 0x0010 (0x0010 - 0x0000)
struct Ability_100015_OnOwnerGameplayTagUpdate final
{
public:
	struct FGameplayTag                           InTag;                                             // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTagExists;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Ability_100015_OnOwnerGameplayTagUpdate) == 0x000004, "Wrong alignment on Ability_100015_OnOwnerGameplayTagUpdate");
static_assert(sizeof(Ability_100015_OnOwnerGameplayTagUpdate) == 0x000010, "Wrong size on Ability_100015_OnOwnerGameplayTagUpdate");
static_assert(offsetof(Ability_100015_OnOwnerGameplayTagUpdate, InTag) == 0x000000, "Member 'Ability_100015_OnOwnerGameplayTagUpdate::InTag' has a wrong offset!");
static_assert(offsetof(Ability_100015_OnOwnerGameplayTagUpdate, bTagExists) == 0x00000C, "Member 'Ability_100015_OnOwnerGameplayTagUpdate::bTagExists' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.OnRideCancel
// 0x0004 (0x0004 - 0x0000)
struct Ability_100015_OnRideCancel final
{
public:
	float                                         StateIntervalTime;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_OnRideCancel) == 0x000004, "Wrong alignment on Ability_100015_OnRideCancel");
static_assert(sizeof(Ability_100015_OnRideCancel) == 0x000004, "Wrong size on Ability_100015_OnRideCancel");
static_assert(offsetof(Ability_100015_OnRideCancel, StateIntervalTime) == 0x000000, "Member 'Ability_100015_OnRideCancel::StateIntervalTime' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.SetCurrentWavingCharacter
// 0x0008 (0x0008 - 0x0000)
struct Ability_100015_SetCurrentWavingCharacter final
{
public:
	const class AActor*                           TargetActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_SetCurrentWavingCharacter) == 0x000008, "Wrong alignment on Ability_100015_SetCurrentWavingCharacter");
static_assert(sizeof(Ability_100015_SetCurrentWavingCharacter) == 0x000008, "Wrong size on Ability_100015_SetCurrentWavingCharacter");
static_assert(offsetof(Ability_100015_SetCurrentWavingCharacter, TargetActor) == 0x000000, "Member 'Ability_100015_SetCurrentWavingCharacter::TargetActor' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.SetWavingConfirmedByCharacter
// 0x0008 (0x0008 - 0x0000)
struct Ability_100015_SetWavingConfirmedByCharacter final
{
public:
	class AMarvelBaseCharacter*                   InCharacter;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_SetWavingConfirmedByCharacter) == 0x000008, "Wrong alignment on Ability_100015_SetWavingConfirmedByCharacter");
static_assert(sizeof(Ability_100015_SetWavingConfirmedByCharacter) == 0x000008, "Wrong size on Ability_100015_SetWavingConfirmedByCharacter");
static_assert(offsetof(Ability_100015_SetWavingConfirmedByCharacter, InCharacter) == 0x000000, "Member 'Ability_100015_SetWavingConfirmedByCharacter::InCharacter' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.SetWavingState
// 0x0001 (0x0001 - 0x0000)
struct Ability_100015_SetWavingState final
{
public:
	ESynergyWavingState                           InNewState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_SetWavingState) == 0x000001, "Wrong alignment on Ability_100015_SetWavingState");
static_assert(sizeof(Ability_100015_SetWavingState) == 0x000001, "Wrong size on Ability_100015_SetWavingState");
static_assert(offsetof(Ability_100015_SetWavingState, InNewState) == 0x000000, "Member 'Ability_100015_SetWavingState::InNewState' has a wrong offset!");

// Function Hero_Synergy.Ability_100015.GetWavingState
// 0x0001 (0x0001 - 0x0000)
struct Ability_100015_GetWavingState final
{
public:
	ESynergyWavingState                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100015_GetWavingState) == 0x000001, "Wrong alignment on Ability_100015_GetWavingState");
static_assert(sizeof(Ability_100015_GetWavingState) == 0x000001, "Wrong size on Ability_100015_GetWavingState");
static_assert(offsetof(Ability_100015_GetWavingState, ReturnValue) == 0x000000, "Member 'Ability_100015_GetWavingState::ReturnValue' has a wrong offset!");

// Function Hero_Synergy.Ability_100016.BroadcastThrowSplineHudEnabled
// 0x0001 (0x0001 - 0x0000)
struct Ability_100016_BroadcastThrowSplineHudEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100016_BroadcastThrowSplineHudEnabled) == 0x000001, "Wrong alignment on Ability_100016_BroadcastThrowSplineHudEnabled");
static_assert(sizeof(Ability_100016_BroadcastThrowSplineHudEnabled) == 0x000001, "Wrong size on Ability_100016_BroadcastThrowSplineHudEnabled");
static_assert(offsetof(Ability_100016_BroadcastThrowSplineHudEnabled, bEnabled) == 0x000000, "Member 'Ability_100016_BroadcastThrowSplineHudEnabled::bEnabled' has a wrong offset!");

// Function Hero_Synergy.Ability_100016.OnThrowCharacterCoopRideStateChanged
// 0x0010 (0x0010 - 0x0000)
struct Ability_100016_OnThrowCharacterCoopRideStateChanged final
{
public:
	bool                                          bIsRiding;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   RideCharacter;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100016_OnThrowCharacterCoopRideStateChanged) == 0x000008, "Wrong alignment on Ability_100016_OnThrowCharacterCoopRideStateChanged");
static_assert(sizeof(Ability_100016_OnThrowCharacterCoopRideStateChanged) == 0x000010, "Wrong size on Ability_100016_OnThrowCharacterCoopRideStateChanged");
static_assert(offsetof(Ability_100016_OnThrowCharacterCoopRideStateChanged, bIsRiding) == 0x000000, "Member 'Ability_100016_OnThrowCharacterCoopRideStateChanged::bIsRiding' has a wrong offset!");
static_assert(offsetof(Ability_100016_OnThrowCharacterCoopRideStateChanged, RideCharacter) == 0x000008, "Member 'Ability_100016_OnThrowCharacterCoopRideStateChanged::RideCharacter' has a wrong offset!");

// Function Hero_Synergy.Ability_100016.PredictThrowDataWhenPressed
// 0x0030 (0x0030 - 0x0000)
struct Ability_100016_PredictThrowDataWhenPressed final
{
public:
	struct FVector                                PredictVelocity;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PredictionPath;                                    // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MaxFallSeconds;                                    // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpHeightDown;                                 // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100016_PredictThrowDataWhenPressed) == 0x000008, "Wrong alignment on Ability_100016_PredictThrowDataWhenPressed");
static_assert(sizeof(Ability_100016_PredictThrowDataWhenPressed) == 0x000030, "Wrong size on Ability_100016_PredictThrowDataWhenPressed");
static_assert(offsetof(Ability_100016_PredictThrowDataWhenPressed, PredictVelocity) == 0x000000, "Member 'Ability_100016_PredictThrowDataWhenPressed::PredictVelocity' has a wrong offset!");
static_assert(offsetof(Ability_100016_PredictThrowDataWhenPressed, PredictionPath) == 0x000018, "Member 'Ability_100016_PredictThrowDataWhenPressed::PredictionPath' has a wrong offset!");
static_assert(offsetof(Ability_100016_PredictThrowDataWhenPressed, MaxFallSeconds) == 0x000028, "Member 'Ability_100016_PredictThrowDataWhenPressed::MaxFallSeconds' has a wrong offset!");
static_assert(offsetof(Ability_100016_PredictThrowDataWhenPressed, MaxJumpHeightDown) == 0x00002C, "Member 'Ability_100016_PredictThrowDataWhenPressed::MaxJumpHeightDown' has a wrong offset!");

// Function Hero_Synergy.Ability_100016.PredictThrowVelocity
// 0x0038 (0x0038 - 0x0000)
struct Ability_100016_PredictThrowVelocity final
{
public:
	float                                         PredictSpeed;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoteRole;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               InRotator;                                         // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Ability_100016_PredictThrowVelocity) == 0x000008, "Wrong alignment on Ability_100016_PredictThrowVelocity");
static_assert(sizeof(Ability_100016_PredictThrowVelocity) == 0x000038, "Wrong size on Ability_100016_PredictThrowVelocity");
static_assert(offsetof(Ability_100016_PredictThrowVelocity, PredictSpeed) == 0x000000, "Member 'Ability_100016_PredictThrowVelocity::PredictSpeed' has a wrong offset!");
static_assert(offsetof(Ability_100016_PredictThrowVelocity, bRemoteRole) == 0x000004, "Member 'Ability_100016_PredictThrowVelocity::bRemoteRole' has a wrong offset!");
static_assert(offsetof(Ability_100016_PredictThrowVelocity, InRotator) == 0x000008, "Member 'Ability_100016_PredictThrowVelocity::InRotator' has a wrong offset!");
static_assert(offsetof(Ability_100016_PredictThrowVelocity, ReturnValue) == 0x000020, "Member 'Ability_100016_PredictThrowVelocity::ReturnValue' has a wrong offset!");

// Function Hero_Synergy.Cue_Ability_Loop_100016.OnOwnerAbilityThrowSplineHudEnabledChanged
// 0x0001 (0x0001 - 0x0000)
struct Cue_Ability_Loop_100016_OnOwnerAbilityThrowSplineHudEnabledChanged final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_100016_OnOwnerAbilityThrowSplineHudEnabledChanged) == 0x000001, "Wrong alignment on Cue_Ability_Loop_100016_OnOwnerAbilityThrowSplineHudEnabledChanged");
static_assert(sizeof(Cue_Ability_Loop_100016_OnOwnerAbilityThrowSplineHudEnabledChanged) == 0x000001, "Wrong size on Cue_Ability_Loop_100016_OnOwnerAbilityThrowSplineHudEnabledChanged");
static_assert(offsetof(Cue_Ability_Loop_100016_OnOwnerAbilityThrowSplineHudEnabledChanged, bEnabled) == 0x000000, "Member 'Cue_Ability_Loop_100016_OnOwnerAbilityThrowSplineHudEnabledChanged::bEnabled' has a wrong offset!");

// Function Hero_Synergy.Cue_Ability_Loop_100016.OnPressRelease
// 0x0004 (0x0004 - 0x0000)
struct Cue_Ability_Loop_100016_OnPressRelease final
{
public:
	float                                         TimeWaited;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_100016_OnPressRelease) == 0x000004, "Wrong alignment on Cue_Ability_Loop_100016_OnPressRelease");
static_assert(sizeof(Cue_Ability_Loop_100016_OnPressRelease) == 0x000004, "Wrong size on Cue_Ability_Loop_100016_OnPressRelease");
static_assert(offsetof(Cue_Ability_Loop_100016_OnPressRelease, TimeWaited) == 0x000000, "Member 'Cue_Ability_Loop_100016_OnPressRelease::TimeWaited' has a wrong offset!");

// Function Hero_Synergy.Cue_Ability_Loop_100016.OnPressTimeMin
// 0x0004 (0x0004 - 0x0000)
struct Cue_Ability_Loop_100016_OnPressTimeMin final
{
public:
	float                                         TimeWaited;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cue_Ability_Loop_100016_OnPressTimeMin) == 0x000004, "Wrong alignment on Cue_Ability_Loop_100016_OnPressTimeMin");
static_assert(sizeof(Cue_Ability_Loop_100016_OnPressTimeMin) == 0x000004, "Wrong size on Cue_Ability_Loop_100016_OnPressTimeMin");
static_assert(offsetof(Cue_Ability_Loop_100016_OnPressTimeMin, TimeWaited) == 0x000000, "Member 'Cue_Ability_Loop_100016_OnPressTimeMin::TimeWaited' has a wrong offset!");

}

