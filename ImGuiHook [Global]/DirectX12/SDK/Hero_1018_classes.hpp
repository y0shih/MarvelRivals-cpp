#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1018

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Hero_1018_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1018.Projectile_101811
// 0x0050 (0x2FB0 - 0x2F60)
class AProjectile_101811 : public AMarvelAbilityTargetActor_Projectile
{
public:
	bool                                          bIsCauserChanged;                                  // 0x2F60(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F61[0x4F];                                    // 0x2F61(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FVector GetAimDirection();
	const struct FVector GetAimStart();
	void ResetDefaut();
	void ResetTimeElapsed();
	void SetAimLine(const struct FVector& InAimStart, const struct FVector& InAimDirection);
	void SetProjectileSpreadRotateInfo(const struct FProjectileSpreadRotateInfo& InProjectileSpreadRotateInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_101811">();
	}
	static class AProjectile_101811* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_101811>();
	}
};
static_assert(alignof(AProjectile_101811) == 0x000010, "Wrong alignment on AProjectile_101811");
static_assert(sizeof(AProjectile_101811) == 0x002FB0, "Wrong size on AProjectile_101811");
static_assert(offsetof(AProjectile_101811, bIsCauserChanged) == 0x002F60, "Member 'AProjectile_101811::bIsCauserChanged' has a wrong offset!");

// Class Hero_1018.Cue_Ability_Loop_10181901
// 0x00B0 (0x0EB0 - 0x0E00)
class ACue_Ability_Loop_10181901 final : public AMarvelCueNotify_Ability
{
public:
	TMap<class USkeletalMeshComponent*, struct FCustomMeshMaterialMap> HandShadowMeshMaterialMap;                         // 0x0E00(0x0050)(BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<uint8, struct FCustomMaterialCurveMap>   MaterialParamMap;                                  // 0x0E50(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 MaterialMultiFactorList;                           // 0x0EA0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void CreateCustomMaterial(class USkeletalMeshComponent* InHandShadowComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10181901">();
	}
	static class ACue_Ability_Loop_10181901* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10181901>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10181901) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10181901");
static_assert(sizeof(ACue_Ability_Loop_10181901) == 0x000EB0, "Wrong size on ACue_Ability_Loop_10181901");
static_assert(offsetof(ACue_Ability_Loop_10181901, HandShadowMeshMaterialMap) == 0x000E00, "Member 'ACue_Ability_Loop_10181901::HandShadowMeshMaterialMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10181901, MaterialParamMap) == 0x000E50, "Member 'ACue_Ability_Loop_10181901::MaterialParamMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10181901, MaterialMultiFactorList) == 0x000EA0, "Member 'ACue_Ability_Loop_10181901::MaterialMultiFactorList' has a wrong offset!");

// Class Hero_1018.Cue_Ability_Loop_10182101
// 0x0020 (0x0E20 - 0x0E00)
class ACue_Ability_Loop_10182101 final : public AMarvelCueNotify_Ability
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMesh1;                                     // 0x0E08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddLength;                                         // 0x0E10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E14[0x4];                                      // 0x0E14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         HitFXSystemAsset;                                  // 0x0E18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10182101">();
	}
	static class ACue_Ability_Loop_10182101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10182101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10182101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10182101");
static_assert(sizeof(ACue_Ability_Loop_10182101) == 0x000E20, "Wrong size on ACue_Ability_Loop_10182101");
static_assert(offsetof(ACue_Ability_Loop_10182101, SkeletalMesh) == 0x000E00, "Member 'ACue_Ability_Loop_10182101::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10182101, SkeletalMesh1) == 0x000E08, "Member 'ACue_Ability_Loop_10182101::SkeletalMesh1' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10182101, AddLength) == 0x000E10, "Member 'ACue_Ability_Loop_10182101::AddLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10182101, HitFXSystemAsset) == 0x000E18, "Member 'ACue_Ability_Loop_10182101::HitFXSystemAsset' has a wrong offset!");

// Class Hero_1018.Config_101841
// 0x1ED8 (0x1F70 - 0x0098)
class UConfig_101841 : public UMarvelAbilityConfig
{
public:
	struct FVector                                BarrierOffset;                                     // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestoreSpeed;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitSpeed;                                        // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAngle;                                          // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSkyMinAngle;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSkyMaxAngle;                                     // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierGroundTraceLength;                          // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierRadius;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierHeight;                                     // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeedAdjustCollisionAngle;                          // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardOffset;                                     // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierRecoveryDelay;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierReactiveDelay;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateCollisionTime;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FreeCamBuffID;                                     // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierMoveCollisionRadius;                        // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             MoveCollisionTraceContext;                         // 0x00F0(0x0F30)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                MoveCollisionOffset;                               // 0x1020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1038[0x8];                                     // 0x1038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x1040(0x0F30)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101841">();
	}
	static class UConfig_101841* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101841>();
	}
};
static_assert(alignof(UConfig_101841) == 0x000010, "Wrong alignment on UConfig_101841");
static_assert(sizeof(UConfig_101841) == 0x001F70, "Wrong size on UConfig_101841");
static_assert(offsetof(UConfig_101841, BarrierOffset) == 0x000098, "Member 'UConfig_101841::BarrierOffset' has a wrong offset!");
static_assert(offsetof(UConfig_101841, RestoreSpeed) == 0x0000B0, "Member 'UConfig_101841::RestoreSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101841, LimitSpeed) == 0x0000B4, "Member 'UConfig_101841::LimitSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_101841, MinAngle) == 0x0000B8, "Member 'UConfig_101841::MinAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101841, MaxAngle) == 0x0000BC, "Member 'UConfig_101841::MaxAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101841, InSkyMinAngle) == 0x0000C0, "Member 'UConfig_101841::InSkyMinAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101841, InSkyMaxAngle) == 0x0000C4, "Member 'UConfig_101841::InSkyMaxAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierGroundTraceLength) == 0x0000C8, "Member 'UConfig_101841::BarrierGroundTraceLength' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierRadius) == 0x0000CC, "Member 'UConfig_101841::BarrierRadius' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierHeight) == 0x0000D0, "Member 'UConfig_101841::BarrierHeight' has a wrong offset!");
static_assert(offsetof(UConfig_101841, NeedAdjustCollisionAngle) == 0x0000D4, "Member 'UConfig_101841::NeedAdjustCollisionAngle' has a wrong offset!");
static_assert(offsetof(UConfig_101841, ForwardOffset) == 0x0000D8, "Member 'UConfig_101841::ForwardOffset' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierRecoveryDelay) == 0x0000DC, "Member 'UConfig_101841::BarrierRecoveryDelay' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierReactiveDelay) == 0x0000E0, "Member 'UConfig_101841::BarrierReactiveDelay' has a wrong offset!");
static_assert(offsetof(UConfig_101841, UpdateCollisionTime) == 0x0000E4, "Member 'UConfig_101841::UpdateCollisionTime' has a wrong offset!");
static_assert(offsetof(UConfig_101841, FreeCamBuffID) == 0x0000E8, "Member 'UConfig_101841::FreeCamBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_101841, BarrierMoveCollisionRadius) == 0x0000EC, "Member 'UConfig_101841::BarrierMoveCollisionRadius' has a wrong offset!");
static_assert(offsetof(UConfig_101841, MoveCollisionTraceContext) == 0x0000F0, "Member 'UConfig_101841::MoveCollisionTraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_101841, MoveCollisionOffset) == 0x001020, "Member 'UConfig_101841::MoveCollisionOffset' has a wrong offset!");
static_assert(offsetof(UConfig_101841, TraceContext) == 0x001040, "Member 'UConfig_101841::TraceContext' has a wrong offset!");

// Class Hero_1018.Summoned_10184101
// 0x00A0 (0x08F0 - 0x0850)
class ASummoned_10184101 : public AMarvelBarrierBase
{
public:
	class UConfig_101841*                         AbilityConfig;                                     // 0x0850(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   SummonerInstigator;                                // 0x0858(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelGameplayAbility*                 OwningSummonerAbility;                             // 0x0860(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierTraceDistance;                              // 0x0868(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86C[0x4];                                      // 0x086C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CameraRotator;                                     // 0x0870(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentRotator;                                    // 0x0888(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                InitLocation;                                      // 0x08A0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalInitLocation;                                 // 0x08B8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAngle;                                       // 0x08D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x08D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CollisionInitRelativeLocation;                     // 0x08D8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool BarrierTraceGround();
	class AMarvelBaseCharacter* GetOwnerCharacter();
	class UMarvelBaseGameplayAbility* GetOwningAbility();
	class UMarvelAbilityConfig* GetOwningAbilityConfig();
	bool HasFreeCamBuff();
	void K2_OnBeginAgentTask();
	void K2_SetAlive(bool bInAlive);
	void SetBarrierTrans();
	void SetInstigatorAOYaw();
	void SetPitchLimit(float DeltaTime);
	void UpdateBarrierCollisionOffset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10184101">();
	}
	static class ASummoned_10184101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10184101>();
	}
};
static_assert(alignof(ASummoned_10184101) == 0x000010, "Wrong alignment on ASummoned_10184101");
static_assert(sizeof(ASummoned_10184101) == 0x0008F0, "Wrong size on ASummoned_10184101");
static_assert(offsetof(ASummoned_10184101, AbilityConfig) == 0x000850, "Member 'ASummoned_10184101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, SummonerInstigator) == 0x000858, "Member 'ASummoned_10184101::SummonerInstigator' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, OwningSummonerAbility) == 0x000860, "Member 'ASummoned_10184101::OwningSummonerAbility' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, BarrierTraceDistance) == 0x000868, "Member 'ASummoned_10184101::BarrierTraceDistance' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, CameraRotator) == 0x000870, "Member 'ASummoned_10184101::CameraRotator' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, CurrentRotator) == 0x000888, "Member 'ASummoned_10184101::CurrentRotator' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, InitLocation) == 0x0008A0, "Member 'ASummoned_10184101::InitLocation' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, LocalInitLocation) == 0x0008B8, "Member 'ASummoned_10184101::LocalInitLocation' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, OffsetAngle) == 0x0008D0, "Member 'ASummoned_10184101::OffsetAngle' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, Length) == 0x0008D4, "Member 'ASummoned_10184101::Length' has a wrong offset!");
static_assert(offsetof(ASummoned_10184101, CollisionInitRelativeLocation) == 0x0008D8, "Member 'ASummoned_10184101::CollisionInitRelativeLocation' has a wrong offset!");

// Class Hero_1018.SummonedComp_10184101
// 0x0010 (0x0CA0 - 0x0C90)
class USummonedComp_10184101 : public UMarvelSummonedComponent
{
public:
	int32                                         OwningAbilityID;                                   // 0x0C88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8C[0x4];                                      // 0x0C8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASummoned_10184101*                     OwnerBarrierSummoned;                              // 0x0C90(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C98[0x8];                                      // 0x0C98(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10184101">();
	}
	static class USummonedComp_10184101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10184101>();
	}
};
static_assert(alignof(USummonedComp_10184101) == 0x000010, "Wrong alignment on USummonedComp_10184101");
static_assert(sizeof(USummonedComp_10184101) == 0x000CA0, "Wrong size on USummonedComp_10184101");
static_assert(offsetof(USummonedComp_10184101, OwningAbilityID) == 0x000C88, "Member 'USummonedComp_10184101::OwningAbilityID' has a wrong offset!");
static_assert(offsetof(USummonedComp_10184101, OwnerBarrierSummoned) == 0x000C90, "Member 'USummonedComp_10184101::OwnerBarrierSummoned' has a wrong offset!");

// Class Hero_1018.Config_101851
// 0x0008 (0x00A0 - 0x0098)
class UConfig_101851 : public UMarvelAbilityConfig
{
public:
	float                                         DarkHealthRate;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkDamageRate;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101851">();
	}
	static class UConfig_101851* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101851>();
	}
};
static_assert(alignof(UConfig_101851) == 0x000008, "Wrong alignment on UConfig_101851");
static_assert(sizeof(UConfig_101851) == 0x0000A0, "Wrong size on UConfig_101851");
static_assert(offsetof(UConfig_101851, DarkHealthRate) == 0x000098, "Member 'UConfig_101851::DarkHealthRate' has a wrong offset!");
static_assert(offsetof(UConfig_101851, DarkDamageRate) == 0x00009C, "Member 'UConfig_101851::DarkDamageRate' has a wrong offset!");

// Class Hero_1018.Ability_101851
// 0x0008 (0x2560 - 0x2558)
class UAbility_101851 : public UAbility_108
{
public:
	uint8                                         Pad_2558[0x8];                                     // 0x2558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCurrentDarkManaValue();
	float GetDarkManaValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101851">();
	}
	static class UAbility_101851* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101851>();
	}
};
static_assert(alignof(UAbility_101851) == 0x000008, "Wrong alignment on UAbility_101851");
static_assert(sizeof(UAbility_101851) == 0x002560, "Wrong size on UAbility_101851");

// Class Hero_1018.Scope_10185101
// 0x0010 (0x16D0 - 0x16C0)
class AScope_10185101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	uint8                                         Pad_16C0[0x10];                                    // 0x16C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10185101">();
	}
	static class AScope_10185101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10185101>();
	}
};
static_assert(alignof(AScope_10185101) == 0x000010, "Wrong alignment on AScope_10185101");
static_assert(sizeof(AScope_10185101) == 0x0016D0, "Wrong size on AScope_10185101");

// Class Hero_1018.Config_101861
// 0x0090 (0x0128 - 0x0098)
class UConfig_101861 final : public UMarvelAbilityConfig
{
public:
	struct FVector                                LandscapeCameraTranslation;                        // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FirstDefaultPlacedTranslation;                     // 0x00B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterToLandscapeInterp;                        // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandscapeToCharacterInterp;                        // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 CameraMovingMaxSpeeds;                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DefaultSpeedLevel;                                 // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandscapeCullDistanceSquared;                      // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TracePortalRadius;                                 // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalSummonerId;                                  // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSolvePenetration;                                 // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionShrinkFactor;                             // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionBoostFactor;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     BlockChannels;                                     // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATracePortalCameraActor_101861> CameraActorClass;                                  // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PrePlaceActorClass;                                // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101861">();
	}
	static class UConfig_101861* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101861>();
	}
};
static_assert(alignof(UConfig_101861) == 0x000008, "Wrong alignment on UConfig_101861");
static_assert(sizeof(UConfig_101861) == 0x000128, "Wrong size on UConfig_101861");
static_assert(offsetof(UConfig_101861, LandscapeCameraTranslation) == 0x000098, "Member 'UConfig_101861::LandscapeCameraTranslation' has a wrong offset!");
static_assert(offsetof(UConfig_101861, FirstDefaultPlacedTranslation) == 0x0000B0, "Member 'UConfig_101861::FirstDefaultPlacedTranslation' has a wrong offset!");
static_assert(offsetof(UConfig_101861, CharacterToLandscapeInterp) == 0x0000C8, "Member 'UConfig_101861::CharacterToLandscapeInterp' has a wrong offset!");
static_assert(offsetof(UConfig_101861, LandscapeToCharacterInterp) == 0x0000CC, "Member 'UConfig_101861::LandscapeToCharacterInterp' has a wrong offset!");
static_assert(offsetof(UConfig_101861, CameraMovingMaxSpeeds) == 0x0000D0, "Member 'UConfig_101861::CameraMovingMaxSpeeds' has a wrong offset!");
static_assert(offsetof(UConfig_101861, DefaultSpeedLevel) == 0x0000E0, "Member 'UConfig_101861::DefaultSpeedLevel' has a wrong offset!");
static_assert(offsetof(UConfig_101861, LandscapeCullDistanceSquared) == 0x0000E4, "Member 'UConfig_101861::LandscapeCullDistanceSquared' has a wrong offset!");
static_assert(offsetof(UConfig_101861, TracePortalRadius) == 0x0000E8, "Member 'UConfig_101861::TracePortalRadius' has a wrong offset!");
static_assert(offsetof(UConfig_101861, PortalSummonerId) == 0x0000EC, "Member 'UConfig_101861::PortalSummonerId' has a wrong offset!");
static_assert(offsetof(UConfig_101861, bSolvePenetration) == 0x0000F0, "Member 'UConfig_101861::bSolvePenetration' has a wrong offset!");
static_assert(offsetof(UConfig_101861, CollisionShrinkFactor) == 0x0000F4, "Member 'UConfig_101861::CollisionShrinkFactor' has a wrong offset!");
static_assert(offsetof(UConfig_101861, CollisionBoostFactor) == 0x0000F8, "Member 'UConfig_101861::CollisionBoostFactor' has a wrong offset!");
static_assert(offsetof(UConfig_101861, BlockChannels) == 0x000100, "Member 'UConfig_101861::BlockChannels' has a wrong offset!");
static_assert(offsetof(UConfig_101861, TraceChannel) == 0x000110, "Member 'UConfig_101861::TraceChannel' has a wrong offset!");
static_assert(offsetof(UConfig_101861, CameraActorClass) == 0x000118, "Member 'UConfig_101861::CameraActorClass' has a wrong offset!");
static_assert(offsetof(UConfig_101861, PrePlaceActorClass) == 0x000120, "Member 'UConfig_101861::PrePlaceActorClass' has a wrong offset!");

// Class Hero_1018.Ability_101861
// 0x0190 (0x26E0 - 0x2550)
class UAbility_101861 : public UMarvelGameplayAbility
{
public:
	class UConfig_101861*                         Config;                                            // 0x2550(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATracePortalCameraActor_101861*         CameraActor;                                       // 0x2558(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlacedPortalActor_101861*              PrePlaceActor;                                     // 0x2560(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeyReleaseEndAbilityAudioID;                       // 0x2568(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_256C[0x4];                                     // 0x256C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnExpectPlaceEventChange;                          // 0x2570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APortalViewActor*                       StartPortal;                                       // 0x2580(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APortalViewActor*                       EndPortal;                                         // 0x2588(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2590[0x10];                                    // 0x2590(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityPlaceMsg_101861                PlaceMsg;                                          // 0x25A0(0x0130)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_26D0[0x10];                                    // 0x26D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EmptyEventOnPressOrReleaseInput(float TimeWaited);
	void OnPressCameraDrop(float TimeWaited);
	void OnPressCameraRise(float TimeWaited);
	void OnPressCameraSpeedDown(float TimeWaited);
	void OnPressCameraSpeedUp(float TimeWaited);
	void OnPressEndAbility(float TimeWaited);
	void OnReleaseCameraDrop(float TimeWaited);
	void OnReleaseCameraRise(float TimeWaited);
	void OnReleaseEndAbility(float TimeWaited);
	void OnReleasePlaceOrRemovePortal(float TimeWaited);
	void OnRep_ReplicateCameraActor();
	void OnServerSpawnPortalSuccess(class AActor* SpawnActor);
	void OnViewingCharacterChanged(class AMarvelBaseCharacter* ViewingTarget);
	void ServerHandleEventAndMsg(EPlaceEvent_101861 NewPlaceEvent, const struct FAbilityPlaceMsg_101861& NewPlaceMsg);
	void SimulatedHandleEventAndMsg(EPlaceEvent_101861 NewPlaceEvent, const struct FAbilityPlaceMsg_101861& NewPlaceMsg);

	EPlaceEvent_101861 GetPlaceEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101861">();
	}
	static class UAbility_101861* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101861>();
	}
};
static_assert(alignof(UAbility_101861) == 0x000010, "Wrong alignment on UAbility_101861");
static_assert(sizeof(UAbility_101861) == 0x0026E0, "Wrong size on UAbility_101861");
static_assert(offsetof(UAbility_101861, Config) == 0x002550, "Member 'UAbility_101861::Config' has a wrong offset!");
static_assert(offsetof(UAbility_101861, CameraActor) == 0x002558, "Member 'UAbility_101861::CameraActor' has a wrong offset!");
static_assert(offsetof(UAbility_101861, PrePlaceActor) == 0x002560, "Member 'UAbility_101861::PrePlaceActor' has a wrong offset!");
static_assert(offsetof(UAbility_101861, KeyReleaseEndAbilityAudioID) == 0x002568, "Member 'UAbility_101861::KeyReleaseEndAbilityAudioID' has a wrong offset!");
static_assert(offsetof(UAbility_101861, OnExpectPlaceEventChange) == 0x002570, "Member 'UAbility_101861::OnExpectPlaceEventChange' has a wrong offset!");
static_assert(offsetof(UAbility_101861, StartPortal) == 0x002580, "Member 'UAbility_101861::StartPortal' has a wrong offset!");
static_assert(offsetof(UAbility_101861, EndPortal) == 0x002588, "Member 'UAbility_101861::EndPortal' has a wrong offset!");
static_assert(offsetof(UAbility_101861, PlaceMsg) == 0x0025A0, "Member 'UAbility_101861::PlaceMsg' has a wrong offset!");

// Class Hero_1018.TracePortalCameraActor_101861
// 0x00F0 (0x0F70 - 0x0E80)
class ATracePortalCameraActor_101861 : public AMovingCameraActor
{
public:
	uint8                                         Pad_E78[0x8];                                      // 0x0E78(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsActive;                                         // 0x0E80(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTracingPlacedPortal;                              // 0x0E81(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E82[0x6];                                      // 0x0E82(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_101861*                        OwningAbility;                                     // 0x0E88(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_101861*                         AbilityConfig;                                     // 0x0E90(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateChange;                                     // 0x0E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComp;                                          // 0x0EA8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    SpringArmComponent;                                // 0x0EB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LastHitActor;                                      // 0x0EB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class AActor*>                           IntersectedTransparentActors;                      // 0x0EC0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_F10[0x60];                                     // 0x0F10(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBirthBaseActiveDispatch(class AActor* InBirthBase);
	void OnRep_bIsActive();
	void OnRep_OwningAbility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TracePortalCameraActor_101861">();
	}
	static class ATracePortalCameraActor_101861* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATracePortalCameraActor_101861>();
	}
};
static_assert(alignof(ATracePortalCameraActor_101861) == 0x000010, "Wrong alignment on ATracePortalCameraActor_101861");
static_assert(sizeof(ATracePortalCameraActor_101861) == 0x000F70, "Wrong size on ATracePortalCameraActor_101861");
static_assert(offsetof(ATracePortalCameraActor_101861, bIsActive) == 0x000E80, "Member 'ATracePortalCameraActor_101861::bIsActive' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, bTracingPlacedPortal) == 0x000E81, "Member 'ATracePortalCameraActor_101861::bTracingPlacedPortal' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, OwningAbility) == 0x000E88, "Member 'ATracePortalCameraActor_101861::OwningAbility' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, AbilityConfig) == 0x000E90, "Member 'ATracePortalCameraActor_101861::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, OnStateChange) == 0x000E98, "Member 'ATracePortalCameraActor_101861::OnStateChange' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, MeshComp) == 0x000EA8, "Member 'ATracePortalCameraActor_101861::MeshComp' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, SpringArmComponent) == 0x000EB0, "Member 'ATracePortalCameraActor_101861::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, LastHitActor) == 0x000EB8, "Member 'ATracePortalCameraActor_101861::LastHitActor' has a wrong offset!");
static_assert(offsetof(ATracePortalCameraActor_101861, IntersectedTransparentActors) == 0x000EC0, "Member 'ATracePortalCameraActor_101861::IntersectedTransparentActors' has a wrong offset!");

// Class Hero_1018.PlacedPortalActor_101861
// 0x0040 (0x04B0 - 0x0470)
class APlacedPortalActor_101861 : public AActor
{
public:
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CueTag;                                            // 0x0480(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStateChange;                                     // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USphereComponent*                       RootSphereComp;                                    // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A9[0x7];                                      // 0x04A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bIsActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacedPortalActor_101861">();
	}
	static class APlacedPortalActor_101861* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlacedPortalActor_101861>();
	}
};
static_assert(alignof(APlacedPortalActor_101861) == 0x000008, "Wrong alignment on APlacedPortalActor_101861");
static_assert(sizeof(APlacedPortalActor_101861) == 0x0004B0, "Wrong size on APlacedPortalActor_101861");
static_assert(offsetof(APlacedPortalActor_101861, CueTag) == 0x000480, "Member 'APlacedPortalActor_101861::CueTag' has a wrong offset!");
static_assert(offsetof(APlacedPortalActor_101861, OnStateChange) == 0x000490, "Member 'APlacedPortalActor_101861::OnStateChange' has a wrong offset!");
static_assert(offsetof(APlacedPortalActor_101861, RootSphereComp) == 0x0004A0, "Member 'APlacedPortalActor_101861::RootSphereComp' has a wrong offset!");
static_assert(offsetof(APlacedPortalActor_101861, bIsActive) == 0x0004A8, "Member 'APlacedPortalActor_101861::bIsActive' has a wrong offset!");

// Class Hero_1018.Cue_Ability_Loop_10186101
// 0x0008 (0x0E08 - 0x0E00)
class ACue_Ability_Loop_10186101 final : public AMarvelCueNotify_Ability
{
public:
	int32                                         CameraMoveAudio;                                   // 0x0E00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E04[0x4];                                      // 0x0E04(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10186101">();
	}
	static class ACue_Ability_Loop_10186101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10186101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10186101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10186101");
static_assert(sizeof(ACue_Ability_Loop_10186101) == 0x000E08, "Wrong size on ACue_Ability_Loop_10186101");
static_assert(offsetof(ACue_Ability_Loop_10186101, CameraMoveAudio) == 0x000E00, "Member 'ACue_Ability_Loop_10186101::CameraMoveAudio' has a wrong offset!");

// Class Hero_1018.Ability_101871
// 0x0008 (0x2560 - 0x2558)
class UAbility_101871 : public UAbility_108
{
public:
	uint8                                         Pad_2558[0x8];                                     // 0x2558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101871">();
	}
	static class UAbility_101871* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101871>();
	}
};
static_assert(alignof(UAbility_101871) == 0x000008, "Wrong alignment on UAbility_101871");
static_assert(sizeof(UAbility_101871) == 0x002560, "Wrong size on UAbility_101871");

// Class Hero_1018.Summoned_10187101
// 0x0000 (0x0800 - 0x0800)
class ASummoned_10187101 : public AMarvelSummonerBase
{
public:
	class UCapsuleComponent*                      SoulCollision;                                     // 0x07F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10187101">();
	}
	static class ASummoned_10187101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10187101>();
	}
};
static_assert(alignof(ASummoned_10187101) == 0x000010, "Wrong alignment on ASummoned_10187101");
static_assert(sizeof(ASummoned_10187101) == 0x000800, "Wrong size on ASummoned_10187101");
static_assert(offsetof(ASummoned_10187101, SoulCollision) == 0x0007F8, "Member 'ASummoned_10187101::SoulCollision' has a wrong offset!");

// Class Hero_1018.SummonedMovementComponent_10187101
// 0x0010 (0x09E0 - 0x09D0)
class USummonedMovementComponent_10187101 final : public USummonedMovementComponent
{
public:
	float                                         DownTraceDistance;                                 // 0x09D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D4[0xC];                                      // 0x09D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedMovementComponent_10187101">();
	}
	static class USummonedMovementComponent_10187101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedMovementComponent_10187101>();
	}
};
static_assert(alignof(USummonedMovementComponent_10187101) == 0x000010, "Wrong alignment on USummonedMovementComponent_10187101");
static_assert(sizeof(USummonedMovementComponent_10187101) == 0x0009E0, "Wrong size on USummonedMovementComponent_10187101");
static_assert(offsetof(USummonedMovementComponent_10187101, DownTraceDistance) == 0x0009D0, "Member 'USummonedMovementComponent_10187101::DownTraceDistance' has a wrong offset!");

// Class Hero_1018.SummonedComp_10187101
// 0x0FF0 (0x1C80 - 0x0C90)
class USummonedComp_10187101 : public UMarvelSummonedComponent
{
public:
	float                                         DamageRatio;                                       // 0x0C88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8C[0x4];                                      // 0x0C8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           SoulOffsetCurve;                                   // 0x0C90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C98[0x8];                                      // 0x0C98(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             CollisionCheckContext;                             // 0x0CA0(0x0F30)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         CapsuleHalfHeightCut;                              // 0x1BD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BD4[0x4];                                     // 0x1BD4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         UpdateOffsetKey;                                   // 0x1BD8(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C78[0x8];                                     // 0x1C78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSoulOffset(const struct FVector& OutValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10187101">();
	}
	static class USummonedComp_10187101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10187101>();
	}
};
static_assert(alignof(USummonedComp_10187101) == 0x000010, "Wrong alignment on USummonedComp_10187101");
static_assert(sizeof(USummonedComp_10187101) == 0x001C80, "Wrong size on USummonedComp_10187101");
static_assert(offsetof(USummonedComp_10187101, DamageRatio) == 0x000C88, "Member 'USummonedComp_10187101::DamageRatio' has a wrong offset!");
static_assert(offsetof(USummonedComp_10187101, SoulOffsetCurve) == 0x000C90, "Member 'USummonedComp_10187101::SoulOffsetCurve' has a wrong offset!");
static_assert(offsetof(USummonedComp_10187101, CollisionCheckContext) == 0x000CA0, "Member 'USummonedComp_10187101::CollisionCheckContext' has a wrong offset!");
static_assert(offsetof(USummonedComp_10187101, CapsuleHalfHeightCut) == 0x001BD0, "Member 'USummonedComp_10187101::CapsuleHalfHeightCut' has a wrong offset!");
static_assert(offsetof(USummonedComp_10187101, UpdateOffsetKey) == 0x001BD8, "Member 'USummonedComp_10187101::UpdateOffsetKey' has a wrong offset!");

// Class Hero_1018.EffectAbility_101871
// 0x0018 (0x1100 - 0x10E8)
class UEffectAbility_101871 final : public UMarvelEffectGameplayAbility
{
public:
	int32                                         SummonID;                                          // 0x10E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10EC[0x4];                                     // 0x10EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_101871*                        OwnAbility;                                        // 0x10F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   SourceCharacter;                                   // 0x10F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCharacterPreDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectAbility_101871">();
	}
	static class UEffectAbility_101871* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectAbility_101871>();
	}
};
static_assert(alignof(UEffectAbility_101871) == 0x000008, "Wrong alignment on UEffectAbility_101871");
static_assert(sizeof(UEffectAbility_101871) == 0x001100, "Wrong size on UEffectAbility_101871");
static_assert(offsetof(UEffectAbility_101871, SummonID) == 0x0010E8, "Member 'UEffectAbility_101871::SummonID' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101871, OwnAbility) == 0x0010F0, "Member 'UEffectAbility_101871::OwnAbility' has a wrong offset!");
static_assert(offsetof(UEffectAbility_101871, SourceCharacter) == 0x0010F8, "Member 'UEffectAbility_101871::SourceCharacter' has a wrong offset!");

// Class Hero_1018.MarvelCueNotify_101871_Actor
// 0x0070 (0x0CE8 - 0x0C78)
class AMarvelCueNotify_101871_Actor final : public AMarvelCueNotify_Actor
{
public:
	int32                                         CameraControlPriority;                             // 0x0C78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInterpSpringArmLength;                      // 0x0C7C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C7D[0x3];                                      // 0x0C7D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpringArmTargetLength;                             // 0x0C80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmInterpInitSpeed;                          // 0x0C84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmInterpMaxSpeed;                           // 0x0C88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmInterpAcceleration;                       // 0x0C8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmRecoveryInterpInitSpeed;                  // 0x0C90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmRecoveryInterpMaxSpeed;                   // 0x0C94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmRecoveryInterpAcceleration;               // 0x0C98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInterpSpringArmSocketOffset;                // 0x0C9C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9D[0x3];                                      // 0x0C9D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpringArmSocketOffset;                             // 0x0CA0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmSocketInterpSpeed;                        // 0x0CB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmSocketInterpRecoverySpeed;                // 0x0CBC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFOVInterp;                                  // 0x0CC0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC1[0x3];                                      // 0x0CC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOVTarget;                                         // 0x0CC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVInterpSpeed;                                    // 0x0CC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVInterpRecoverSpeed;                             // 0x0CCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               PPMInstanceDynamic;                                // 0x0CD0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD8[0x10];                                     // 0x0CD8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelCueNotify_101871_Actor">();
	}
	static class AMarvelCueNotify_101871_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelCueNotify_101871_Actor>();
	}
};
static_assert(alignof(AMarvelCueNotify_101871_Actor) == 0x000008, "Wrong alignment on AMarvelCueNotify_101871_Actor");
static_assert(sizeof(AMarvelCueNotify_101871_Actor) == 0x000CE8, "Wrong size on AMarvelCueNotify_101871_Actor");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, CameraControlPriority) == 0x000C78, "Member 'AMarvelCueNotify_101871_Actor::CameraControlPriority' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, bEnableInterpSpringArmLength) == 0x000C7C, "Member 'AMarvelCueNotify_101871_Actor::bEnableInterpSpringArmLength' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmTargetLength) == 0x000C80, "Member 'AMarvelCueNotify_101871_Actor::SpringArmTargetLength' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmInterpInitSpeed) == 0x000C84, "Member 'AMarvelCueNotify_101871_Actor::SpringArmInterpInitSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmInterpMaxSpeed) == 0x000C88, "Member 'AMarvelCueNotify_101871_Actor::SpringArmInterpMaxSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmInterpAcceleration) == 0x000C8C, "Member 'AMarvelCueNotify_101871_Actor::SpringArmInterpAcceleration' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmRecoveryInterpInitSpeed) == 0x000C90, "Member 'AMarvelCueNotify_101871_Actor::SpringArmRecoveryInterpInitSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmRecoveryInterpMaxSpeed) == 0x000C94, "Member 'AMarvelCueNotify_101871_Actor::SpringArmRecoveryInterpMaxSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmRecoveryInterpAcceleration) == 0x000C98, "Member 'AMarvelCueNotify_101871_Actor::SpringArmRecoveryInterpAcceleration' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, bEnableInterpSpringArmSocketOffset) == 0x000C9C, "Member 'AMarvelCueNotify_101871_Actor::bEnableInterpSpringArmSocketOffset' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmSocketOffset) == 0x000CA0, "Member 'AMarvelCueNotify_101871_Actor::SpringArmSocketOffset' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmSocketInterpSpeed) == 0x000CB8, "Member 'AMarvelCueNotify_101871_Actor::SpringArmSocketInterpSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, SpringArmSocketInterpRecoverySpeed) == 0x000CBC, "Member 'AMarvelCueNotify_101871_Actor::SpringArmSocketInterpRecoverySpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, bEnableFOVInterp) == 0x000CC0, "Member 'AMarvelCueNotify_101871_Actor::bEnableFOVInterp' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, FOVTarget) == 0x000CC4, "Member 'AMarvelCueNotify_101871_Actor::FOVTarget' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, FOVInterpSpeed) == 0x000CC8, "Member 'AMarvelCueNotify_101871_Actor::FOVInterpSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, FOVInterpRecoverSpeed) == 0x000CCC, "Member 'AMarvelCueNotify_101871_Actor::FOVInterpRecoverSpeed' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_101871_Actor, PPMInstanceDynamic) == 0x000CD0, "Member 'AMarvelCueNotify_101871_Actor::PPMInstanceDynamic' has a wrong offset!");

// Class Hero_1018.Cue_Summoner_Loop_10187101
// 0x0008 (0x0E38 - 0x0E30)
class ACue_Summoner_Loop_10187101 final : public AMarvelCueNotify_Summoned
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0E30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<class FName> GetHideBones(class USkeletalMeshComponent* TargetMesh);
	void SetMaterialHidden(class USkeletalMeshComponent* SkeletalMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10187101">();
	}
	static class ACue_Summoner_Loop_10187101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10187101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10187101) == 0x000008, "Wrong alignment on ACue_Summoner_Loop_10187101");
static_assert(sizeof(ACue_Summoner_Loop_10187101) == 0x000E38, "Wrong size on ACue_Summoner_Loop_10187101");
static_assert(offsetof(ACue_Summoner_Loop_10187101, SkeletalMesh) == 0x000E30, "Member 'ACue_Summoner_Loop_10187101::SkeletalMesh' has a wrong offset!");

// Class Hero_1018.Config_101881
// 0x00A0 (0x0138 - 0x0098)
class UConfig_101881 final : public UMarvelAbilityConfig
{
public:
	float                                         StartDecreasingAfterSeconds;                       // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkManaDecreasingVelocity;                        // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DarkManaMaxLimit;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkManaAfterReachMaxDecreasingVelocity;           // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayDecreasingTime;                               // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbilityManaConfig_101881>      DarkManaIncreasementConfig;                        // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BondAbilityTags;                                   // 0x00C0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BondAbilityManaIncreaseVelocity;                   // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTriggerFastDecreasingOnBondState;           // 0x012C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTriggerDeBuffOnBondState;                   // 0x012D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12E[0x2];                                      // 0x012E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnergyMultiplierOnBondState;                       // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayDecreasingTimeOnBondState;                    // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_101881">();
	}
	static class UConfig_101881* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_101881>();
	}
};
static_assert(alignof(UConfig_101881) == 0x000008, "Wrong alignment on UConfig_101881");
static_assert(sizeof(UConfig_101881) == 0x000138, "Wrong size on UConfig_101881");
static_assert(offsetof(UConfig_101881, StartDecreasingAfterSeconds) == 0x000098, "Member 'UConfig_101881::StartDecreasingAfterSeconds' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DarkManaDecreasingVelocity) == 0x00009C, "Member 'UConfig_101881::DarkManaDecreasingVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DarkManaMaxLimit) == 0x0000A0, "Member 'UConfig_101881::DarkManaMaxLimit' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DarkManaAfterReachMaxDecreasingVelocity) == 0x0000A4, "Member 'UConfig_101881::DarkManaAfterReachMaxDecreasingVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DelayDecreasingTime) == 0x0000A8, "Member 'UConfig_101881::DelayDecreasingTime' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DarkManaIncreasementConfig) == 0x0000B0, "Member 'UConfig_101881::DarkManaIncreasementConfig' has a wrong offset!");
static_assert(offsetof(UConfig_101881, BondAbilityTags) == 0x0000C0, "Member 'UConfig_101881::BondAbilityTags' has a wrong offset!");
static_assert(offsetof(UConfig_101881, BondAbilityManaIncreaseVelocity) == 0x000128, "Member 'UConfig_101881::BondAbilityManaIncreaseVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_101881, bShouldTriggerFastDecreasingOnBondState) == 0x00012C, "Member 'UConfig_101881::bShouldTriggerFastDecreasingOnBondState' has a wrong offset!");
static_assert(offsetof(UConfig_101881, bShouldTriggerDeBuffOnBondState) == 0x00012D, "Member 'UConfig_101881::bShouldTriggerDeBuffOnBondState' has a wrong offset!");
static_assert(offsetof(UConfig_101881, EnergyMultiplierOnBondState) == 0x000130, "Member 'UConfig_101881::EnergyMultiplierOnBondState' has a wrong offset!");
static_assert(offsetof(UConfig_101881, DelayDecreasingTimeOnBondState) == 0x000134, "Member 'UConfig_101881::DelayDecreasingTimeOnBondState' has a wrong offset!");

// Class Hero_1018.Ability_101881
// 0x0148 (0x2698 - 0x2550)
class UAbility_101881 : public UMarvelGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             DarkManaValueChangedDelegate;                      // 0x2550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	EAbilityState_101881                          AbilityState;                                      // 0x2560(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2561[0x7];                                     // 0x2561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             AbilityStateChangedDelegate;                       // 0x2568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBondAbilityStateChanged;                         // 0x2578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UConfig_101881*                         Config;                                            // 0x2588(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2590[0x108];                                   // 0x2590(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAntiHealBuff();
	void ClearDarkMana();
	float GetCurrentDarkMana();
	float GetCurrentManaPercentage();
	void OnAbilityDamage(class UGameplayAbility* Ability, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnAbilityHit(class UGameplayAbility* Ability, const TArray<struct FHitResult>& HitResults);
	void OnAbilityStateUpdate();
	void OnBondAbilityTagUpdate(const struct FGameplayTag& Tag, bool TagExists);
	void OnManaAttributeChanged(class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnManaReachMax();
	void OnOwnerAbilityMissile(class UGameplayAbility* Ability);
	void OnOwnerActivateAbility(int32 AbilityID);
	void OnOwnerCharactorReborn(class AActor* TargetActor, const struct FCharacterRebornParam& Param);
	void OnOwnerDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void ServerClearDarkMana();
	void SetDarkManaValue(float InDarkManaValue);

	bool IsBondAbilityState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_101881">();
	}
	static class UAbility_101881* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_101881>();
	}
};
static_assert(alignof(UAbility_101881) == 0x000008, "Wrong alignment on UAbility_101881");
static_assert(sizeof(UAbility_101881) == 0x002698, "Wrong size on UAbility_101881");
static_assert(offsetof(UAbility_101881, DarkManaValueChangedDelegate) == 0x002550, "Member 'UAbility_101881::DarkManaValueChangedDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_101881, AbilityState) == 0x002560, "Member 'UAbility_101881::AbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_101881, AbilityStateChangedDelegate) == 0x002568, "Member 'UAbility_101881::AbilityStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_101881, OnBondAbilityStateChanged) == 0x002578, "Member 'UAbility_101881::OnBondAbilityStateChanged' has a wrong offset!");
static_assert(offsetof(UAbility_101881, Config) == 0x002588, "Member 'UAbility_101881::Config' has a wrong offset!");

// Class Hero_1018.Cue_Ability_Loop_10188101
// 0x0148 (0x0F48 - 0x0E00)
class ACue_Ability_Loop_10188101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E00[0x8];                                      // 0x0E00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeginAppearValue;                                  // 0x0E08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0C[0x4];                                      // 0x0E0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ManaCurveFloat;                                    // 0x0E10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaterialStartCurve;                                // 0x0E18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaterialEndCurve;                                  // 0x0E20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaterialIntervalCurve;                             // 0x0E28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialStartAudioID;                              // 0x0E30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialEndAudioID;                                // 0x0E34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RTPCAudioName;                                     // 0x0E38(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TipsAudioID;                                       // 0x0E48(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FullAudioID;                                       // 0x0E4C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TipsAudioTrigger;                                  // 0x0E50(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECueAbilityState_101881                       EffectState;                                       // 0x0E54(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E55[0x3];                                      // 0x0E55(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   MyCharacter;                                       // 0x0E58(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbility_101881*                        Ability_101881;                                    // 0x0E60(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 CurrentMesh;                                       // 0x0E68(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BondAbilitySwitchCurve;                            // 0x0E70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloakColorParameterName;                           // 0x0E78(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBondAbility;                                   // 0x0E84(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerFullAudio;                                 // 0x0E85(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E86[0xC2];                                     // 0x0E86(0x00C2)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBondAbilityStateChanged();
	void OnBondAbilityTagUpdate(const struct FGameplayTag& Tag, bool TagExists);
	void OnChildActorResetMaterial();
	void OnCloakColorChanged(class FName TrackName, class FName PropertyName, float OutValue);
	void OnCloakColorChangedEnd();
	void OnDarkManaValueChanged(float ManaPercentage);
	void SetCloseState();
	void SetEndCenterEdgeMaterialValue(class FName TrackName, class FName PropertyName, float OutValue);
	void SetOpenState();
	void SetStartCenterEdgeMaterialValue(class FName TrackName, class FName PropertyName, float OutValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10188101">();
	}
	static class ACue_Ability_Loop_10188101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10188101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10188101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10188101");
static_assert(sizeof(ACue_Ability_Loop_10188101) == 0x000F48, "Wrong size on ACue_Ability_Loop_10188101");
static_assert(offsetof(ACue_Ability_Loop_10188101, BeginAppearValue) == 0x000E08, "Member 'ACue_Ability_Loop_10188101::BeginAppearValue' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, ManaCurveFloat) == 0x000E10, "Member 'ACue_Ability_Loop_10188101::ManaCurveFloat' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MaterialStartCurve) == 0x000E18, "Member 'ACue_Ability_Loop_10188101::MaterialStartCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MaterialEndCurve) == 0x000E20, "Member 'ACue_Ability_Loop_10188101::MaterialEndCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MaterialIntervalCurve) == 0x000E28, "Member 'ACue_Ability_Loop_10188101::MaterialIntervalCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MaterialStartAudioID) == 0x000E30, "Member 'ACue_Ability_Loop_10188101::MaterialStartAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MaterialEndAudioID) == 0x000E34, "Member 'ACue_Ability_Loop_10188101::MaterialEndAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, RTPCAudioName) == 0x000E38, "Member 'ACue_Ability_Loop_10188101::RTPCAudioName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, TipsAudioID) == 0x000E48, "Member 'ACue_Ability_Loop_10188101::TipsAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, FullAudioID) == 0x000E4C, "Member 'ACue_Ability_Loop_10188101::FullAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, TipsAudioTrigger) == 0x000E50, "Member 'ACue_Ability_Loop_10188101::TipsAudioTrigger' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, EffectState) == 0x000E54, "Member 'ACue_Ability_Loop_10188101::EffectState' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, MyCharacter) == 0x000E58, "Member 'ACue_Ability_Loop_10188101::MyCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, Ability_101881) == 0x000E60, "Member 'ACue_Ability_Loop_10188101::Ability_101881' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, CurrentMesh) == 0x000E68, "Member 'ACue_Ability_Loop_10188101::CurrentMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, BondAbilitySwitchCurve) == 0x000E70, "Member 'ACue_Ability_Loop_10188101::BondAbilitySwitchCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, CloakColorParameterName) == 0x000E78, "Member 'ACue_Ability_Loop_10188101::CloakColorParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, bHasBondAbility) == 0x000E84, "Member 'ACue_Ability_Loop_10188101::bHasBondAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10188101, bTriggerFullAudio) == 0x000E85, "Member 'ACue_Ability_Loop_10188101::bTriggerFullAudio' has a wrong offset!");

// Class Hero_1018.DoctorStrangeAnimInstance
// 0x0020 (0x0920 - 0x0900)
class UDoctorStrangeAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsFlying;                                         // 0x0900(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFloating;                                       // 0x0901(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDefending;                                      // 0x0902(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_903[0x1];                                      // 0x0903(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AimOffsetAnimIndex;                                // 0x0904(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFloatDefending;                                   // 0x0908(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_909[0x3];                                      // 0x0909(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VFloatForward;                                     // 0x090C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VFloatRight;                                       // 0x0910(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKnockWhenDefence;                                 // 0x0914(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_915[0xB];                                      // 0x0915(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStrangeAnimInstance">();
	}
	static class UDoctorStrangeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorStrangeAnimInstance>();
	}
};
static_assert(alignof(UDoctorStrangeAnimInstance) == 0x000010, "Wrong alignment on UDoctorStrangeAnimInstance");
static_assert(sizeof(UDoctorStrangeAnimInstance) == 0x000920, "Wrong size on UDoctorStrangeAnimInstance");
static_assert(offsetof(UDoctorStrangeAnimInstance, bIsFlying) == 0x000900, "Member 'UDoctorStrangeAnimInstance::bIsFlying' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, bIsFloating) == 0x000901, "Member 'UDoctorStrangeAnimInstance::bIsFloating' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, bIsDefending) == 0x000902, "Member 'UDoctorStrangeAnimInstance::bIsDefending' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, AimOffsetAnimIndex) == 0x000904, "Member 'UDoctorStrangeAnimInstance::AimOffsetAnimIndex' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, bFloatDefending) == 0x000908, "Member 'UDoctorStrangeAnimInstance::bFloatDefending' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, VFloatForward) == 0x00090C, "Member 'UDoctorStrangeAnimInstance::VFloatForward' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, VFloatRight) == 0x000910, "Member 'UDoctorStrangeAnimInstance::VFloatRight' has a wrong offset!");
static_assert(offsetof(UDoctorStrangeAnimInstance, bKnockWhenDefence) == 0x000914, "Member 'UDoctorStrangeAnimInstance::bKnockWhenDefence' has a wrong offset!");

// Class Hero_1018.DoctorStrangeChildActor
// 0x0020 (0x0A60 - 0x0A40)
class ADoctorStrangeChildActor final : public AMarvelCharacterChildActor
{
public:
	class UPhysicalAnimationComponent*            PhysicalAnimation;                                 // 0x0A40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneName;                                          // 0x0A48(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_A58[0x8];                                      // 0x0A58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPhysicalAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStrangeChildActor">();
	}
	static class ADoctorStrangeChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoctorStrangeChildActor>();
	}
};
static_assert(alignof(ADoctorStrangeChildActor) == 0x000008, "Wrong alignment on ADoctorStrangeChildActor");
static_assert(sizeof(ADoctorStrangeChildActor) == 0x000A60, "Wrong size on ADoctorStrangeChildActor");
static_assert(offsetof(ADoctorStrangeChildActor, PhysicalAnimation) == 0x000A40, "Member 'ADoctorStrangeChildActor::PhysicalAnimation' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeChildActor, BoneName) == 0x000A48, "Member 'ADoctorStrangeChildActor::BoneName' has a wrong offset!");

// Class Hero_1018.DoctorStrangeCharacter
// 0x0080 (0x1840 - 0x17C0)
class ADoctorStrangeCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bIsDefending;                                      // 0x17B8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlying;                                         // 0x17B9(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x17BA(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17BB[0x1];                                     // 0x17BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentPitch;                                      // 0x17BC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDoctorStrangeMoveLogicBaseComponent*   DoctorStrangeMoveLogic;                            // 0x17C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelMultiCapsuleComponent*           ShieldCollision;                                   // 0x17C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17D0[0x70];                                    // 0x17D0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagUpdate(const struct FGameplayTag& Tag, bool bTagExists);
	void SetIsDefending(bool bInShield);
	void SetIsFloating(bool bIsFloating_0);
	void SetIsFlying(bool bFlying);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStrangeCharacter">();
	}
	static class ADoctorStrangeCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoctorStrangeCharacter>();
	}
};
static_assert(alignof(ADoctorStrangeCharacter) == 0x000010, "Wrong alignment on ADoctorStrangeCharacter");
static_assert(sizeof(ADoctorStrangeCharacter) == 0x001840, "Wrong size on ADoctorStrangeCharacter");
static_assert(offsetof(ADoctorStrangeCharacter, bIsDefending) == 0x0017B8, "Member 'ADoctorStrangeCharacter::bIsDefending' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeCharacter, bIsFlying) == 0x0017B9, "Member 'ADoctorStrangeCharacter::bIsFlying' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeCharacter, bIsFloating) == 0x0017BA, "Member 'ADoctorStrangeCharacter::bIsFloating' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeCharacter, CurrentPitch) == 0x0017BC, "Member 'ADoctorStrangeCharacter::CurrentPitch' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeCharacter, DoctorStrangeMoveLogic) == 0x0017C0, "Member 'ADoctorStrangeCharacter::DoctorStrangeMoveLogic' has a wrong offset!");
static_assert(offsetof(ADoctorStrangeCharacter, ShieldCollision) == 0x0017C8, "Member 'ADoctorStrangeCharacter::ShieldCollision' has a wrong offset!");

// Class Hero_1018.DoctorStrangeMoveLogicBaseComponent
// 0x0008 (0x03F8 - 0x03F0)
class UDoctorStrangeMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	TWeakObjectPtr<class AMovingCameraActor>      LandscapeCamera;                                   // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStrangeMoveLogicBaseComponent">();
	}
	static class UDoctorStrangeMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorStrangeMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UDoctorStrangeMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UDoctorStrangeMoveLogicBaseComponent");
static_assert(sizeof(UDoctorStrangeMoveLogicBaseComponent) == 0x0003F8, "Wrong size on UDoctorStrangeMoveLogicBaseComponent");
static_assert(offsetof(UDoctorStrangeMoveLogicBaseComponent, LandscapeCamera) == 0x0003F0, "Member 'UDoctorStrangeMoveLogicBaseComponent::LandscapeCamera' has a wrong offset!");

// Class Hero_1018.DoctorStrangeMovementComponent
// 0x0000 (0x1AF0 - 0x1AF0)
class UDoctorStrangeMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStrangeMovementComponent">();
	}
	static class UDoctorStrangeMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorStrangeMovementComponent>();
	}
};
static_assert(alignof(UDoctorStrangeMovementComponent) == 0x000010, "Wrong alignment on UDoctorStrangeMovementComponent");
static_assert(sizeof(UDoctorStrangeMovementComponent) == 0x001AF0, "Wrong size on UDoctorStrangeMovementComponent");

// Class Hero_1018.EpicMomentAction_1018
// 0x0050 (0x0170 - 0x0120)
class UEpicMomentAction_1018 : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0x28];                                     // 0x0120(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    QConfig;                                           // 0x0148(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    ShieldBlockConfig;                                 // 0x0154(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         QBuffID;                                           // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QBuffCount;                                        // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldSummonerID;                                  // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldSummonerBlockDamageThreshold;                // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnActorTakeDamage(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1018">();
	}
	static class UEpicMomentAction_1018* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1018>();
	}
};
static_assert(alignof(UEpicMomentAction_1018) == 0x000008, "Wrong alignment on UEpicMomentAction_1018");
static_assert(sizeof(UEpicMomentAction_1018) == 0x000170, "Wrong size on UEpicMomentAction_1018");
static_assert(offsetof(UEpicMomentAction_1018, QConfig) == 0x000148, "Member 'UEpicMomentAction_1018::QConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1018, ShieldBlockConfig) == 0x000154, "Member 'UEpicMomentAction_1018::ShieldBlockConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1018, QBuffID) == 0x000160, "Member 'UEpicMomentAction_1018::QBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1018, QBuffCount) == 0x000164, "Member 'UEpicMomentAction_1018::QBuffCount' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1018, ShieldSummonerID) == 0x000168, "Member 'UEpicMomentAction_1018::ShieldSummonerID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1018, ShieldSummonerBlockDamageThreshold) == 0x00016C, "Member 'UEpicMomentAction_1018::ShieldSummonerBlockDamageThreshold' has a wrong offset!");

// Class Hero_1018.TabData_1018
// 0x0000 (0x0050 - 0x0050)
class UTabData_1018 : public UHeroTabDataBase
{
public:
	void OnActorPreDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnActorTakeDamage(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1018">();
	}
	static class UTabData_1018* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1018>();
	}
};
static_assert(alignof(UTabData_1018) == 0x000008, "Wrong alignment on UTabData_1018");
static_assert(sizeof(UTabData_1018) == 0x000050, "Wrong size on UTabData_1018");

}

