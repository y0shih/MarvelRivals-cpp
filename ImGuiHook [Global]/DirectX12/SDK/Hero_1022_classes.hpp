#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1022

#include "Basic.hpp"

#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "Hero_1022_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Class Hero_1022.Cue_Projectile_Loop_10223301
// 0x0088 (0x0DE8 - 0x0D60)
class ACue_Projectile_Loop_10223301 final : public AMarvelCueNotify_Projectile
{
public:
	class UNiagaraComponent*                      NS_Loop1;                                          // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Loop2;                                          // 0x0D68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0D70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceTime;                                         // 0x0D74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0D78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HomingAttachMeshComName;                           // 0x0D7C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ThreeEffectOffset;                                 // 0x0D88(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FourEffectOffset;                                  // 0x0DA0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB8[0x20];                                     // 0x0DB8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        HomingAttachMeshCom;                               // 0x0DD8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      CurrentNiagara;                                    // 0x0DE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DelayShowFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10223301">();
	}
	static class ACue_Projectile_Loop_10223301* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10223301>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10223301) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10223301");
static_assert(sizeof(ACue_Projectile_Loop_10223301) == 0x000DE8, "Wrong size on ACue_Projectile_Loop_10223301");
static_assert(offsetof(ACue_Projectile_Loop_10223301, NS_Loop1) == 0x000D60, "Member 'ACue_Projectile_Loop_10223301::NS_Loop1' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, NS_Loop2) == 0x000D68, "Member 'ACue_Projectile_Loop_10223301::NS_Loop2' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, DelayTime) == 0x000D70, "Member 'ACue_Projectile_Loop_10223301::DelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, TraceTime) == 0x000D74, "Member 'ACue_Projectile_Loop_10223301::TraceTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, EndDistance) == 0x000D78, "Member 'ACue_Projectile_Loop_10223301::EndDistance' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, HomingAttachMeshComName) == 0x000D7C, "Member 'ACue_Projectile_Loop_10223301::HomingAttachMeshComName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, ThreeEffectOffset) == 0x000D88, "Member 'ACue_Projectile_Loop_10223301::ThreeEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, FourEffectOffset) == 0x000DA0, "Member 'ACue_Projectile_Loop_10223301::FourEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, HomingAttachMeshCom) == 0x000DD8, "Member 'ACue_Projectile_Loop_10223301::HomingAttachMeshCom' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, CurrentNiagara) == 0x000DE0, "Member 'ACue_Projectile_Loop_10223301::CurrentNiagara' has a wrong offset!");

// Class Hero_1022.Config_102261
// 0x0FB8 (0x1050 - 0x0098)
class UConfig_102261 : public UMarvelAbilityConfig
{
public:
	float                                         MaxFlyRadius;                                      // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingSpeed;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingAcceleration;                                // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionPerBounce1;                         // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionPerBounce2;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionPerBounce3;                         // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00B0(0x0F30)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CancelHomingTag;                                   // 0x0FE0(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1048[0x8];                                     // 0x1048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102261">();
	}
	static class UConfig_102261* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102261>();
	}
};
static_assert(alignof(UConfig_102261) == 0x000010, "Wrong alignment on UConfig_102261");
static_assert(sizeof(UConfig_102261) == 0x001050, "Wrong size on UConfig_102261");
static_assert(offsetof(UConfig_102261, MaxFlyRadius) == 0x000098, "Member 'UConfig_102261::MaxFlyRadius' has a wrong offset!");
static_assert(offsetof(UConfig_102261, HomingSpeed) == 0x00009C, "Member 'UConfig_102261::HomingSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_102261, HomingAcceleration) == 0x0000A0, "Member 'UConfig_102261::HomingAcceleration' has a wrong offset!");
static_assert(offsetof(UConfig_102261, DamageReductionPerBounce1) == 0x0000A4, "Member 'UConfig_102261::DamageReductionPerBounce1' has a wrong offset!");
static_assert(offsetof(UConfig_102261, DamageReductionPerBounce2) == 0x0000A8, "Member 'UConfig_102261::DamageReductionPerBounce2' has a wrong offset!");
static_assert(offsetof(UConfig_102261, DamageReductionPerBounce3) == 0x0000AC, "Member 'UConfig_102261::DamageReductionPerBounce3' has a wrong offset!");
static_assert(offsetof(UConfig_102261, TraceContext) == 0x0000B0, "Member 'UConfig_102261::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_102261, CancelHomingTag) == 0x000FE0, "Member 'UConfig_102261::CancelHomingTag' has a wrong offset!");

// Class Hero_1022.Config_102235
// 0x0F30 (0x1F80 - 0x1050)
class UConfig_102235 : public UConfig_102261
{
public:
	struct FMarvelAbilityTraceContext             BeginTraceContext;                                 // 0x1050(0x0F30)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102235">();
	}
	static class UConfig_102235* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102235>();
	}
};
static_assert(alignof(UConfig_102235) == 0x000010, "Wrong alignment on UConfig_102235");
static_assert(sizeof(UConfig_102235) == 0x001F80, "Wrong size on UConfig_102235");
static_assert(offsetof(UConfig_102235, BeginTraceContext) == 0x001050, "Member 'UConfig_102235::BeginTraceContext' has a wrong offset!");

// Class Hero_1022.Projectile_10226101
// 0x0030 (0x2F90 - 0x2F60)
class AProjectile_10226101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	TArray<class ACharacter*>                     VisitedTargets;                                    // 0x2F60(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F70[0x18];                                    // 0x2F70(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelBaseAbilitySystemComponent*      CurrentASC;                                        // 0x2F88(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOwnerTagUpdate(const struct FGameplayTag& Tag, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10226101">();
	}
	static class AProjectile_10226101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10226101>();
	}
};
static_assert(alignof(AProjectile_10226101) == 0x000010, "Wrong alignment on AProjectile_10226101");
static_assert(sizeof(AProjectile_10226101) == 0x002F90, "Wrong size on AProjectile_10226101");
static_assert(offsetof(AProjectile_10226101, VisitedTargets) == 0x002F60, "Member 'AProjectile_10226101::VisitedTargets' has a wrong offset!");
static_assert(offsetof(AProjectile_10226101, CurrentASC) == 0x002F88, "Member 'AProjectile_10226101::CurrentASC' has a wrong offset!");

// Class Hero_1022.Projectile_10223101
// 0x0000 (0x2F90 - 0x2F90)
class AProjectile_10223101 final : public AProjectile_10226101
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10223101">();
	}
	static class AProjectile_10223101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10223101>();
	}
};
static_assert(alignof(AProjectile_10223101) == 0x000010, "Wrong alignment on AProjectile_10223101");
static_assert(sizeof(AProjectile_10223101) == 0x002F90, "Wrong size on AProjectile_10223101");

// Class Hero_1022.UIC_Controller_102235
// 0x0028 (0x0C80 - 0x0C58)
class UUIC_Controller_102235 : public UUIC_Ability
{
public:
	struct FGameplayTag                           AbilityCountTag;                                   // 0x0C58(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuffTag;                                           // 0x0C64(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C70[0x10];                                     // 0x0C70(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityCountUpdate(const struct FGameplayTag& Tag, int32 NewCount);
	void OnBuffTagUpdate(const struct FGameplayTag& Tag, int32 NewCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIC_Controller_102235">();
	}
	static class UUIC_Controller_102235* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIC_Controller_102235>();
	}
};
static_assert(alignof(UUIC_Controller_102235) == 0x000008, "Wrong alignment on UUIC_Controller_102235");
static_assert(sizeof(UUIC_Controller_102235) == 0x000C80, "Wrong size on UUIC_Controller_102235");
static_assert(offsetof(UUIC_Controller_102235, AbilityCountTag) == 0x000C58, "Member 'UUIC_Controller_102235::AbilityCountTag' has a wrong offset!");
static_assert(offsetof(UUIC_Controller_102235, BuffTag) == 0x000C64, "Member 'UUIC_Controller_102235::BuffTag' has a wrong offset!");

// Class Hero_1022.Config_102241
// 0x0018 (0x00B0 - 0x0098)
class UConfig_102241 : public UMarvelAbilityConfig
{
public:
	bool                                          bEnableAttachSocket;                               // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackwardWalkSpeedRatio;                            // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 BuffList;                                          // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102241">();
	}
	static class UConfig_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102241>();
	}
};
static_assert(alignof(UConfig_102241) == 0x000008, "Wrong alignment on UConfig_102241");
static_assert(sizeof(UConfig_102241) == 0x0000B0, "Wrong size on UConfig_102241");
static_assert(offsetof(UConfig_102241, bEnableAttachSocket) == 0x000098, "Member 'UConfig_102241::bEnableAttachSocket' has a wrong offset!");
static_assert(offsetof(UConfig_102241, BackwardWalkSpeedRatio) == 0x00009C, "Member 'UConfig_102241::BackwardWalkSpeedRatio' has a wrong offset!");
static_assert(offsetof(UConfig_102241, BuffList) == 0x0000A0, "Member 'UConfig_102241::BuffList' has a wrong offset!");

// Class Hero_1022.ReflexReceiverComponent_102241
// 0x0000 (0x03D0 - 0x03D0)
class UReflexReceiverComponent_102241 final : public UMarvelReflexReceiverComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReflexReceiverComponent_102241">();
	}
	static class UReflexReceiverComponent_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReflexReceiverComponent_102241>();
	}
};
static_assert(alignof(UReflexReceiverComponent_102241) == 0x000008, "Wrong alignment on UReflexReceiverComponent_102241");
static_assert(sizeof(UReflexReceiverComponent_102241) == 0x0003D0, "Wrong size on UReflexReceiverComponent_102241");

// Class Hero_1022.SummonedComp_102241
// 0x0000 (0x0C90 - 0x0C90)
class USummonedComp_102241 : public UMarvelSummonedComponent
{
public:
	void OnApplyBuff(class UAbilitySystemComponent* Source, class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_102241">();
	}
	static class USummonedComp_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_102241>();
	}
};
static_assert(alignof(USummonedComp_102241) == 0x000010, "Wrong alignment on USummonedComp_102241");
static_assert(sizeof(USummonedComp_102241) == 0x000C90, "Wrong size on USummonedComp_102241");

// Class Hero_1022.Summoned_102241
// 0x0070 (0x0870 - 0x0800)
class ASummoned_102241 : public AMarvelSummonerBase
{
public:
	class UReflexReceiverComponent_102241*        ReflexReceiverComponent;                           // 0x07F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldActive;                                   // 0x0800(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_801[0x7];                                      // 0x0801(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BodyOffset;                                        // 0x0808(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BodyRotation;                                      // 0x0820(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalOriginCoordinates;                            // 0x0838(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0850(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x0854(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitch;                                          // 0x0858(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85C[0x4];                                      // 0x085C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_102241*                         AbilityConfig;                                     // 0x0860(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UConfig_102241* GetConfig();
	void K2_SetAlive(bool bInAlive);
	void OnRep_IsShieldActive();
	void OnSummonedCompBeginAgentTask();
	void OnSummonedCompEndAgentTask();
	void ResetHealth();
	void SetShieldActive(bool bIsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_102241">();
	}
	static class ASummoned_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_102241>();
	}
};
static_assert(alignof(ASummoned_102241) == 0x000010, "Wrong alignment on ASummoned_102241");
static_assert(sizeof(ASummoned_102241) == 0x000870, "Wrong size on ASummoned_102241");
static_assert(offsetof(ASummoned_102241, ReflexReceiverComponent) == 0x0007F8, "Member 'ASummoned_102241::ReflexReceiverComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, bIsShieldActive) == 0x000800, "Member 'ASummoned_102241::bIsShieldActive' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, BodyOffset) == 0x000808, "Member 'ASummoned_102241::BodyOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, BodyRotation) == 0x000820, "Member 'ASummoned_102241::BodyRotation' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, LocalOriginCoordinates) == 0x000838, "Member 'ASummoned_102241::LocalOriginCoordinates' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, Length) == 0x000850, "Member 'ASummoned_102241::Length' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, MaxPitch) == 0x000854, "Member 'ASummoned_102241::MaxPitch' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, MinPitch) == 0x000858, "Member 'ASummoned_102241::MinPitch' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, AbilityConfig) == 0x000860, "Member 'ASummoned_102241::AbilityConfig' has a wrong offset!");

// Class Hero_1022.Cue_Summoner_Damaged_10224102
// 0x0010 (0x04E0 - 0x04D0)
class UCue_Summoner_Damaged_10224102 final : public UMarvelCueNotify_HitImpact
{
public:
	TArray<struct FAmplitudeRange>                AmplitudeRangeArray;                               // 0x04D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Damaged_10224102">();
	}
	static class UCue_Summoner_Damaged_10224102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Summoner_Damaged_10224102>();
	}
};
static_assert(alignof(UCue_Summoner_Damaged_10224102) == 0x000008, "Wrong alignment on UCue_Summoner_Damaged_10224102");
static_assert(sizeof(UCue_Summoner_Damaged_10224102) == 0x0004E0, "Wrong size on UCue_Summoner_Damaged_10224102");
static_assert(offsetof(UCue_Summoner_Damaged_10224102, AmplitudeRangeArray) == 0x0004D0, "Member 'UCue_Summoner_Damaged_10224102::AmplitudeRangeArray' has a wrong offset!");

// Class Hero_1022.Config_102251
// 0x0010 (0x00A8 - 0x0098)
class UConfig_102251 final : public UMarvelAbilityConfig
{
public:
	class UCurveFloat*                            SpeedCurve;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102251">();
	}
	static class UConfig_102251* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102251>();
	}
};
static_assert(alignof(UConfig_102251) == 0x000008, "Wrong alignment on UConfig_102251");
static_assert(sizeof(UConfig_102251) == 0x0000A8, "Wrong size on UConfig_102251");
static_assert(offsetof(UConfig_102251, SpeedCurve) == 0x000098, "Member 'UConfig_102251::SpeedCurve' has a wrong offset!");
static_assert(offsetof(UConfig_102251, BuffID) == 0x0000A0, "Member 'UConfig_102251::BuffID' has a wrong offset!");

// Class Hero_1022.Ability_102251
// 0x0008 (0x2558 - 0x2550)
class UAbility_102251 : public UMarvelGameplayAbility
{
public:
	class UConfig_102251*                         Config102251;                                      // 0x2550(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnGameplayEvent(const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102251">();
	}
	static class UAbility_102251* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102251>();
	}
};
static_assert(alignof(UAbility_102251) == 0x000008, "Wrong alignment on UAbility_102251");
static_assert(sizeof(UAbility_102251) == 0x002558, "Wrong size on UAbility_102251");
static_assert(offsetof(UAbility_102251, Config102251) == 0x002550, "Member 'UAbility_102251::Config102251' has a wrong offset!");

// Class Hero_1022.MarvelCueNotify_CaptainShadow
// 0x0110 (0x0F10 - 0x0E00)
class AMarvelCueNotify_CaptainShadow : public AMarvelCueNotify_Ability
{
public:
	class UPoseableMeshComponent*                 Mesh1;                                             // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh2;                                             // 0x0E08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh3;                                             // 0x0E10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh4;                                             // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh5;                                             // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FShadowMeshInfo                        MeshInfo;                                          // 0x0E28(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FShadowMeshInfo>                ChildsMeshInfo;                                    // 0x0E78(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ShadowMeshLOD;                                     // 0x0E88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SimulateShadowMeshLOD;                             // 0x0E8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ShadowShowTime;                                    // 0x0E90(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCurveVector*                           ShadowScaleCurve;                                  // 0x0EA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShadowOpacityCurve;                                // 0x0EA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpacityName;                                       // 0x0EB0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MovePositionName;                                  // 0x0EBC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveOffset;                                        // 0x0EC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ECC[0x4];                                      // 0x0ECC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPoseableMeshComponent*>         ShadowMeshComponents;                              // 0x0ED0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE0[0x30];                                     // 0x0EE0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecordCharacterSprintInfo(float DeltaSeconds);
	void ResetParameter();
	void SetCharacterMeshHidden(class UPoseableMeshComponent* Mesh, bool NewHidden);
	void SetCharacterMeshMovePosition(class UPoseableMeshComponent* Mesh, const struct FVector& MoveDir);
	void SetCharacterMeshOpacity(class UPoseableMeshComponent* Mesh, float Opacity);
	void SetShadowMeshMaterial(struct FShadowMeshInfo* ShadowMeshInfo, TArray<struct FShadowMeshInfo>* ChildShadowMeshInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelCueNotify_CaptainShadow">();
	}
	static class AMarvelCueNotify_CaptainShadow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelCueNotify_CaptainShadow>();
	}
};
static_assert(alignof(AMarvelCueNotify_CaptainShadow) == 0x000008, "Wrong alignment on AMarvelCueNotify_CaptainShadow");
static_assert(sizeof(AMarvelCueNotify_CaptainShadow) == 0x000F10, "Wrong size on AMarvelCueNotify_CaptainShadow");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh1) == 0x000E00, "Member 'AMarvelCueNotify_CaptainShadow::Mesh1' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh2) == 0x000E08, "Member 'AMarvelCueNotify_CaptainShadow::Mesh2' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh3) == 0x000E10, "Member 'AMarvelCueNotify_CaptainShadow::Mesh3' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh4) == 0x000E18, "Member 'AMarvelCueNotify_CaptainShadow::Mesh4' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh5) == 0x000E20, "Member 'AMarvelCueNotify_CaptainShadow::Mesh5' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, MeshInfo) == 0x000E28, "Member 'AMarvelCueNotify_CaptainShadow::MeshInfo' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ChildsMeshInfo) == 0x000E78, "Member 'AMarvelCueNotify_CaptainShadow::ChildsMeshInfo' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowMeshLOD) == 0x000E88, "Member 'AMarvelCueNotify_CaptainShadow::ShadowMeshLOD' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, SimulateShadowMeshLOD) == 0x000E8C, "Member 'AMarvelCueNotify_CaptainShadow::SimulateShadowMeshLOD' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowShowTime) == 0x000E90, "Member 'AMarvelCueNotify_CaptainShadow::ShadowShowTime' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowScaleCurve) == 0x000EA0, "Member 'AMarvelCueNotify_CaptainShadow::ShadowScaleCurve' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowOpacityCurve) == 0x000EA8, "Member 'AMarvelCueNotify_CaptainShadow::ShadowOpacityCurve' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, OpacityName) == 0x000EB0, "Member 'AMarvelCueNotify_CaptainShadow::OpacityName' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, MovePositionName) == 0x000EBC, "Member 'AMarvelCueNotify_CaptainShadow::MovePositionName' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, MoveOffset) == 0x000EC8, "Member 'AMarvelCueNotify_CaptainShadow::MoveOffset' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowMeshComponents) == 0x000ED0, "Member 'AMarvelCueNotify_CaptainShadow::ShadowMeshComponents' has a wrong offset!");

// Class Hero_1022.Cue_Ability_Loop_10225101
// 0x00C0 (0x0EC0 - 0x0E00)
class ACue_Ability_Loop_10225101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E00[0x18];                                     // 0x0E00(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      VelocityLineFX;                                    // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartFXDelayTime;                                  // 0x0E20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E24[0xC];                                      // 0x0E24(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartFXRelativeTransform;                          // 0x0E30(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         DelayStartFX;                                      // 0x0E90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     PostProcessingMaterial;                            // 0x0E98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA0[0x20];                                     // 0x0EA0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10225101">();
	}
	static class ACue_Ability_Loop_10225101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10225101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10225101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10225101");
static_assert(sizeof(ACue_Ability_Loop_10225101) == 0x000EC0, "Wrong size on ACue_Ability_Loop_10225101");
static_assert(offsetof(ACue_Ability_Loop_10225101, VelocityLineFX) == 0x000E18, "Member 'ACue_Ability_Loop_10225101::VelocityLineFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, StartFXDelayTime) == 0x000E20, "Member 'ACue_Ability_Loop_10225101::StartFXDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, StartFXRelativeTransform) == 0x000E30, "Member 'ACue_Ability_Loop_10225101::StartFXRelativeTransform' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, DelayStartFX) == 0x000E90, "Member 'ACue_Ability_Loop_10225101::DelayStartFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, PostProcessingMaterial) == 0x000E98, "Member 'ACue_Ability_Loop_10225101::PostProcessingMaterial' has a wrong offset!");

// Class Hero_1022.Ability_102252
// 0x0000 (0x2558 - 0x2558)
class UAbility_102252 final : public UAbility_102
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102252">();
	}
	static class UAbility_102252* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102252>();
	}
};
static_assert(alignof(UAbility_102252) == 0x000008, "Wrong alignment on UAbility_102252");
static_assert(sizeof(UAbility_102252) == 0x002558, "Wrong size on UAbility_102252");

// Class Hero_1022.Config_102253
// 0x1AB8 (0x1B50 - 0x0098)
class UConfig_102253 final : public UMarvelAbilityConfig
{
public:
	struct FVector                                ScopePosOffset;                                    // 0x0098(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceAimContext;                                   // 0x00B0(0x0F30)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDashAbilityInfo                       DashInfo;                                          // 0x0FE0(0x0B70)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102253">();
	}
	static class UConfig_102253* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102253>();
	}
};
static_assert(alignof(UConfig_102253) == 0x000010, "Wrong alignment on UConfig_102253");
static_assert(sizeof(UConfig_102253) == 0x001B50, "Wrong size on UConfig_102253");
static_assert(offsetof(UConfig_102253, ScopePosOffset) == 0x000098, "Member 'UConfig_102253::ScopePosOffset' has a wrong offset!");
static_assert(offsetof(UConfig_102253, TraceAimContext) == 0x0000B0, "Member 'UConfig_102253::TraceAimContext' has a wrong offset!");
static_assert(offsetof(UConfig_102253, DashInfo) == 0x000FE0, "Member 'UConfig_102253::DashInfo' has a wrong offset!");

// Class Hero_1022.Ability_102253
// 0x0150 (0x26A0 - 0x2550)
class UAbility_102253 final : public UMarvelGameplayAbility
{
public:
	uint8                                         Pad_2550[0x8];                                     // 0x2550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                                      // 0x2558(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         InitializeAbilityKey;                              // 0x2560(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         OnApplyDashKey;                                    // 0x2600(0x00A0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnDashFinish(EDashStopReason Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102253">();
	}
	static class UAbility_102253* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102253>();
	}
};
static_assert(alignof(UAbility_102253) == 0x000008, "Wrong alignment on UAbility_102253");
static_assert(sizeof(UAbility_102253) == 0x0026A0, "Wrong size on UAbility_102253");
static_assert(offsetof(UAbility_102253, TimelineTask) == 0x002558, "Member 'UAbility_102253::TimelineTask' has a wrong offset!");
static_assert(offsetof(UAbility_102253, InitializeAbilityKey) == 0x002560, "Member 'UAbility_102253::InitializeAbilityKey' has a wrong offset!");
static_assert(offsetof(UAbility_102253, OnApplyDashKey) == 0x002600, "Member 'UAbility_102253::OnApplyDashKey' has a wrong offset!");

// Class Hero_1022.Config_102254
// 0x1E98 (0x1F30 - 0x0098)
class UConfig_102254 final : public UMarvelAbilityConfig
{
public:
	float                                         MaxCharacterHeightToActivate;                      // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCharacterHeightToActivate;                      // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAimHeightToActivate;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSmashRadius;                                    // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckAngle;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SmashPermissionBuffID;                             // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SmashCooldownTag;                                  // 0x00B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRate;                                         // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTraceDistance;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceDownContext;                                  // 0x00D0(0x0F30)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceAimContext;                                   // 0x1000(0x0F30)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102254">();
	}
	static class UConfig_102254* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102254>();
	}
};
static_assert(alignof(UConfig_102254) == 0x000010, "Wrong alignment on UConfig_102254");
static_assert(sizeof(UConfig_102254) == 0x001F30, "Wrong size on UConfig_102254");
static_assert(offsetof(UConfig_102254, MaxCharacterHeightToActivate) == 0x000098, "Member 'UConfig_102254::MaxCharacterHeightToActivate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, MinCharacterHeightToActivate) == 0x00009C, "Member 'UConfig_102254::MinCharacterHeightToActivate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, MinAimHeightToActivate) == 0x0000A0, "Member 'UConfig_102254::MinAimHeightToActivate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, MaxSmashRadius) == 0x0000A4, "Member 'UConfig_102254::MaxSmashRadius' has a wrong offset!");
static_assert(offsetof(UConfig_102254, GroundCheckAngle) == 0x0000A8, "Member 'UConfig_102254::GroundCheckAngle' has a wrong offset!");
static_assert(offsetof(UConfig_102254, SmashPermissionBuffID) == 0x0000AC, "Member 'UConfig_102254::SmashPermissionBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102254, SmashCooldownTag) == 0x0000B0, "Member 'UConfig_102254::SmashCooldownTag' has a wrong offset!");
static_assert(offsetof(UConfig_102254, TraceRate) == 0x0000BC, "Member 'UConfig_102254::TraceRate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, BackTraceDistance) == 0x0000C0, "Member 'UConfig_102254::BackTraceDistance' has a wrong offset!");
static_assert(offsetof(UConfig_102254, TraceDownContext) == 0x0000D0, "Member 'UConfig_102254::TraceDownContext' has a wrong offset!");
static_assert(offsetof(UConfig_102254, TraceAimContext) == 0x001000, "Member 'UConfig_102254::TraceAimContext' has a wrong offset!");

// Class Hero_1022.Ability_102254
// 0x0060 (0x25B0 - 0x2550)
class UAbility_102254 : public UMarvelGameplayAbility
{
public:
	uint8                                         Pad_2550[0x60];                                    // 0x2550(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetCurrentAimImpactPoint();
	TArray<struct FHitResult> GetTraceResults();
	void UpdateState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102254">();
	}
	static class UAbility_102254* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102254>();
	}
};
static_assert(alignof(UAbility_102254) == 0x000008, "Wrong alignment on UAbility_102254");
static_assert(sizeof(UAbility_102254) == 0x0025B0, "Wrong size on UAbility_102254");

// Class Hero_1022.Cue_Ability_Loop_10225401
// 0x0020 (0x0E20 - 0x0E00)
class ACue_Ability_Loop_10225401 final : public AMarvelCueNotify_Ability
{
public:
	class UDecalComponent*                        DecalComponent;                                    // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistToSmooth;                                   // 0x0E08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpMaxSpeed;                                      // 0x0E0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpMinSpeed;                                      // 0x0E10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateRate;                                        // 0x0E14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E18[0x8];                                      // 0x0E18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerBuffApplied(class UAbilitySystemComponent* InASC, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& Handle);
	void OnOwnerBuffRemove(const class UAbilitySystemComponent* ASC, const struct FActiveGameplayEffect& Age);
	void OnViewingCharChanged(class AMarvelBaseCharacter* ViewingChar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10225401">();
	}
	static class ACue_Ability_Loop_10225401* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10225401>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10225401) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10225401");
static_assert(sizeof(ACue_Ability_Loop_10225401) == 0x000E20, "Wrong size on ACue_Ability_Loop_10225401");
static_assert(offsetof(ACue_Ability_Loop_10225401, DecalComponent) == 0x000E00, "Member 'ACue_Ability_Loop_10225401::DecalComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, MaxDistToSmooth) == 0x000E08, "Member 'ACue_Ability_Loop_10225401::MaxDistToSmooth' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, LerpMaxSpeed) == 0x000E0C, "Member 'ACue_Ability_Loop_10225401::LerpMaxSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, LerpMinSpeed) == 0x000E10, "Member 'ACue_Ability_Loop_10225401::LerpMinSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, UpdateRate) == 0x000E14, "Member 'ACue_Ability_Loop_10225401::UpdateRate' has a wrong offset!");

// Class Hero_1022.Config_102255
// 0x0030 (0x00C8 - 0x0098)
class UConfig_102255 final : public UMarvelAbilityConfig
{
public:
	bool                                          bIsWaitStateChanged;                               // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStateChangedTaskParam                 TaskParam;                                         // 0x009C(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102255">();
	}
	static class UConfig_102255* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102255>();
	}
};
static_assert(alignof(UConfig_102255) == 0x000008, "Wrong alignment on UConfig_102255");
static_assert(sizeof(UConfig_102255) == 0x0000C8, "Wrong size on UConfig_102255");
static_assert(offsetof(UConfig_102255, bIsWaitStateChanged) == 0x000098, "Member 'UConfig_102255::bIsWaitStateChanged' has a wrong offset!");
static_assert(offsetof(UConfig_102255, TaskParam) == 0x00009C, "Member 'UConfig_102255::TaskParam' has a wrong offset!");

// Class Hero_1022.Ability_102255
// 0x0010 (0x2560 - 0x2550)
class UAbility_102255 : public UMarvelGameplayAbility
{
public:
	uint8                                         Pad_2550[0x8];                                     // 0x2550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_WaitInputStateChanged* WaitActivationInputStateTask;                      // 0x2558(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActivatePress(float TimeWaited);
	void OnActivateRelease(float TimeWaited);
	void OnKey102235Press(float TimeWaited);
	void OnKey102235Release(float TimeWaited);
	void OnMoveForwardInput(uint8 InMovementInputs, float DeltaTime);
	void SetActivatePressing(bool bIsPressing);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102255">();
	}
	static class UAbility_102255* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102255>();
	}
};
static_assert(alignof(UAbility_102255) == 0x000008, "Wrong alignment on UAbility_102255");
static_assert(sizeof(UAbility_102255) == 0x002560, "Wrong size on UAbility_102255");
static_assert(offsetof(UAbility_102255, WaitActivationInputStateTask) == 0x002558, "Member 'UAbility_102255::WaitActivationInputStateTask' has a wrong offset!");

// Class Hero_1022.Cue_Ability_Loop_10225501
// 0x0088 (0x0F98 - 0x0F10)
class ACue_Ability_Loop_10225501 final : public AMarvelCueNotify_CaptainShadow
{
public:
	uint8                                         Pad_F10[0x18];                                     // 0x0F10(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RemoveTags;                                        // 0x0F28(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_F90[0x8];                                      // 0x0F90(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10225501">();
	}
	static class ACue_Ability_Loop_10225501* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10225501>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10225501) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10225501");
static_assert(sizeof(ACue_Ability_Loop_10225501) == 0x000F98, "Wrong size on ACue_Ability_Loop_10225501");
static_assert(offsetof(ACue_Ability_Loop_10225501, RemoveTags) == 0x000F28, "Member 'ACue_Ability_Loop_10225501::RemoveTags' has a wrong offset!");

// Class Hero_1022.Ability_102261
// 0x0000 (0x2558 - 0x2558)
class UAbility_102261 : public UAbility_108
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102261">();
	}
	static class UAbility_102261* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102261>();
	}
};
static_assert(alignof(UAbility_102261) == 0x000008, "Wrong alignment on UAbility_102261");
static_assert(sizeof(UAbility_102261) == 0x002558, "Wrong size on UAbility_102261");

// Class Hero_1022.Config_102271
// 0x0028 (0x00C0 - 0x0098)
class UConfig_102271 final : public UMarvelAbilityConfig
{
public:
	float                                         ScopeDuration;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmorBuffID;                                       // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisposableTeammateArmorBuffValue;                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisposableSelfArmorBuffValue;                      // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeammateArmorBuffValue;                            // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelfArmorBuffValue;                                // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorTimeGap;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeammateSpeedBuffID;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelfSpeedBuffID;                                   // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102271">();
	}
	static class UConfig_102271* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102271>();
	}
};
static_assert(alignof(UConfig_102271) == 0x000008, "Wrong alignment on UConfig_102271");
static_assert(sizeof(UConfig_102271) == 0x0000C0, "Wrong size on UConfig_102271");
static_assert(offsetof(UConfig_102271, ScopeDuration) == 0x000098, "Member 'UConfig_102271::ScopeDuration' has a wrong offset!");
static_assert(offsetof(UConfig_102271, ArmorBuffID) == 0x00009C, "Member 'UConfig_102271::ArmorBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102271, DisposableTeammateArmorBuffValue) == 0x0000A0, "Member 'UConfig_102271::DisposableTeammateArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, DisposableSelfArmorBuffValue) == 0x0000A4, "Member 'UConfig_102271::DisposableSelfArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, TeammateArmorBuffValue) == 0x0000A8, "Member 'UConfig_102271::TeammateArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, SelfArmorBuffValue) == 0x0000AC, "Member 'UConfig_102271::SelfArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, ArmorTimeGap) == 0x0000B0, "Member 'UConfig_102271::ArmorTimeGap' has a wrong offset!");
static_assert(offsetof(UConfig_102271, TeammateSpeedBuffID) == 0x0000B4, "Member 'UConfig_102271::TeammateSpeedBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102271, SelfSpeedBuffID) == 0x0000B8, "Member 'UConfig_102271::SelfSpeedBuffID' has a wrong offset!");

// Class Hero_1022.Ability_102271
// 0x0020 (0x2570 - 0x2550)
class UAbility_102271 : public UMarvelGameplayAbility
{
public:
	class AScope_10227101*                        Scope;                                             // 0x2550(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2558[0x18];                                    // 0x2558(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102271">();
	}
	static class UAbility_102271* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102271>();
	}
};
static_assert(alignof(UAbility_102271) == 0x000008, "Wrong alignment on UAbility_102271");
static_assert(sizeof(UAbility_102271) == 0x002570, "Wrong size on UAbility_102271");
static_assert(offsetof(UAbility_102271, Scope) == 0x002550, "Member 'UAbility_102271::Scope' has a wrong offset!");

// Class Hero_1022.Scope_10227101
// 0x0110 (0x17D0 - 0x16C0)
class AScope_10227101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	TMap<class AMarvelBaseCharacter*, class UArmorAttenuation_102271*> CachedAttenuationAbility;                          // 0x16C0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_1710[0x8];                                     // 0x1710(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Path;                                              // 0x1718(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 PathTime;                                          // 0x1728(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           Teammates;                                         // 0x1738(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           TeammatesOnPath;                                   // 0x1748(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           TeammatesOffPath;                                  // 0x1758(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class AMarvelBaseCharacter*, struct FTimerHandle> AddArmorTimerMap;                                  // 0x1768(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         MaxPathLength;                                     // 0x17B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceBetweenPointsSquared;                      // 0x17BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17C0[0x10];                                    // 0x17C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyArmorToTarget(class AMarvelBaseCharacter* Target);
	const TArray<struct FVector> GetQPath();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10227101">();
	}
	static class AScope_10227101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10227101>();
	}
};
static_assert(alignof(AScope_10227101) == 0x000010, "Wrong alignment on AScope_10227101");
static_assert(sizeof(AScope_10227101) == 0x0017D0, "Wrong size on AScope_10227101");
static_assert(offsetof(AScope_10227101, CachedAttenuationAbility) == 0x0016C0, "Member 'AScope_10227101::CachedAttenuationAbility' has a wrong offset!");
static_assert(offsetof(AScope_10227101, Path) == 0x001718, "Member 'AScope_10227101::Path' has a wrong offset!");
static_assert(offsetof(AScope_10227101, PathTime) == 0x001728, "Member 'AScope_10227101::PathTime' has a wrong offset!");
static_assert(offsetof(AScope_10227101, Teammates) == 0x001738, "Member 'AScope_10227101::Teammates' has a wrong offset!");
static_assert(offsetof(AScope_10227101, TeammatesOnPath) == 0x001748, "Member 'AScope_10227101::TeammatesOnPath' has a wrong offset!");
static_assert(offsetof(AScope_10227101, TeammatesOffPath) == 0x001758, "Member 'AScope_10227101::TeammatesOffPath' has a wrong offset!");
static_assert(offsetof(AScope_10227101, AddArmorTimerMap) == 0x001768, "Member 'AScope_10227101::AddArmorTimerMap' has a wrong offset!");
static_assert(offsetof(AScope_10227101, MaxPathLength) == 0x0017B8, "Member 'AScope_10227101::MaxPathLength' has a wrong offset!");
static_assert(offsetof(AScope_10227101, DistanceBetweenPointsSquared) == 0x0017BC, "Member 'AScope_10227101::DistanceBetweenPointsSquared' has a wrong offset!");

// Class Hero_1022.Scope_10227102
// 0x0000 (0x16C0 - 0x16C0)
class AScope_10227102 final : public AMarvelAbilityTargetActor_Scope
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10227102">();
	}
	static class AScope_10227102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10227102>();
	}
};
static_assert(alignof(AScope_10227102) == 0x000010, "Wrong alignment on AScope_10227102");
static_assert(sizeof(AScope_10227102) == 0x0016C0, "Wrong size on AScope_10227102");

// Class Hero_1022.ArmorAttenuation_102271
// 0x0000 (0x1260 - 0x1260)
class UArmorAttenuation_102271 : public UMarvelNotTreatFallAbility
{
public:
	void AddArmor(float DeltaValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmorAttenuation_102271">();
	}
	static class UArmorAttenuation_102271* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmorAttenuation_102271>();
	}
};
static_assert(alignof(UArmorAttenuation_102271) == 0x000008, "Wrong alignment on UArmorAttenuation_102271");
static_assert(sizeof(UArmorAttenuation_102271) == 0x001260, "Wrong size on UArmorAttenuation_102271");

// Class Hero_1022.Cue_Ability_Loop_10227101
// 0x0070 (0x0E70 - 0x0E00)
class ACue_Ability_Loop_10227101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_E00[0x18];                                     // 0x0E00(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      CueNiagara;                                        // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ReleaseNiagara;                                    // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DisCurve;                                          // 0x0E28(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShieldMaterialName;                                // 0x0E30(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3C[0x4];                                      // 0x0E3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ShieldMaterialShowCurve;                           // 0x0E40(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShieldMaterialHideCurve;                           // 0x0E48(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SprintShieldRaiseID;                               // 0x0E50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SprintShieldReleaseID;                             // 0x0E54(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SprintShieldRaiseLoopID;                           // 0x0E58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5C[0x14];                                     // 0x0E5C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);
	void SetShieldMaterial(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10227101">();
	}
	static class ACue_Ability_Loop_10227101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10227101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10227101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10227101");
static_assert(sizeof(ACue_Ability_Loop_10227101) == 0x000E70, "Wrong size on ACue_Ability_Loop_10227101");
static_assert(offsetof(ACue_Ability_Loop_10227101, CueNiagara) == 0x000E18, "Member 'ACue_Ability_Loop_10227101::CueNiagara' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ReleaseNiagara) == 0x000E20, "Member 'ACue_Ability_Loop_10227101::ReleaseNiagara' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, DisCurve) == 0x000E28, "Member 'ACue_Ability_Loop_10227101::DisCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ShieldMaterialName) == 0x000E30, "Member 'ACue_Ability_Loop_10227101::ShieldMaterialName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ShieldMaterialShowCurve) == 0x000E40, "Member 'ACue_Ability_Loop_10227101::ShieldMaterialShowCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ShieldMaterialHideCurve) == 0x000E48, "Member 'ACue_Ability_Loop_10227101::ShieldMaterialHideCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, SprintShieldRaiseID) == 0x000E50, "Member 'ACue_Ability_Loop_10227101::SprintShieldRaiseID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, SprintShieldReleaseID) == 0x000E54, "Member 'ACue_Ability_Loop_10227101::SprintShieldReleaseID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, SprintShieldRaiseLoopID) == 0x000E58, "Member 'ACue_Ability_Loop_10227101::SprintShieldRaiseLoopID' has a wrong offset!");

// Class Hero_1022.Cue_Ability_Loop_10227102
// 0x0000 (0x0F10 - 0x0F10)
class ACue_Ability_Loop_10227102 final : public AMarvelCueNotify_CaptainShadow
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10227102">();
	}
	static class ACue_Ability_Loop_10227102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10227102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10227102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10227102");
static_assert(sizeof(ACue_Ability_Loop_10227102) == 0x000F10, "Wrong size on ACue_Ability_Loop_10227102");

// Class Hero_1022.CaptainAmericaAnimInstance
// 0x0040 (0x0940 - 0x0900)
class UCaptainAmericaAnimInstance final : public UMarvelAnimInstance
{
public:
	class FString                                 ShieldMontageName;                                 // 0x0900(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShieldMontageLoopSectionName;                      // 0x0910(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShieldMontageLoopRunSectionName;                   // 0x091C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SmoothDirSpeed;                                    // 0x0928(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSprint;                                         // 0x092C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92D[0x3];                                      // 0x092D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintDir;                                         // 0x0930(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSpecialJump;                                    // 0x0934(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSprintAndShieldRaised;                          // 0x0935(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpInAir;                                          // 0x0936(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsJumping;                                        // 0x0937(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFalling;                                          // 0x0938(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFlash;                                            // 0x0939(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFallingInPlace;                                 // 0x093A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnGround;                                         // 0x093B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintToGround;                                   // 0x093C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBackOnGround;                                     // 0x093D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_93E[0x2];                                      // 0x093E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaAnimInstance">();
	}
	static class UCaptainAmericaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptainAmericaAnimInstance>();
	}
};
static_assert(alignof(UCaptainAmericaAnimInstance) == 0x000010, "Wrong alignment on UCaptainAmericaAnimInstance");
static_assert(sizeof(UCaptainAmericaAnimInstance) == 0x000940, "Wrong size on UCaptainAmericaAnimInstance");
static_assert(offsetof(UCaptainAmericaAnimInstance, ShieldMontageName) == 0x000900, "Member 'UCaptainAmericaAnimInstance::ShieldMontageName' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, ShieldMontageLoopSectionName) == 0x000910, "Member 'UCaptainAmericaAnimInstance::ShieldMontageLoopSectionName' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, ShieldMontageLoopRunSectionName) == 0x00091C, "Member 'UCaptainAmericaAnimInstance::ShieldMontageLoopRunSectionName' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, SmoothDirSpeed) == 0x000928, "Member 'UCaptainAmericaAnimInstance::SmoothDirSpeed' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsSprint) == 0x00092C, "Member 'UCaptainAmericaAnimInstance::bIsSprint' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, SprintDir) == 0x000930, "Member 'UCaptainAmericaAnimInstance::SprintDir' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsSpecialJump) == 0x000934, "Member 'UCaptainAmericaAnimInstance::bIsSpecialJump' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsSprintAndShieldRaised) == 0x000935, "Member 'UCaptainAmericaAnimInstance::bIsSprintAndShieldRaised' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bUpInAir) == 0x000936, "Member 'UCaptainAmericaAnimInstance::bUpInAir' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsJumping) == 0x000937, "Member 'UCaptainAmericaAnimInstance::bIsJumping' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bFalling) == 0x000938, "Member 'UCaptainAmericaAnimInstance::bFalling' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bFlash) == 0x000939, "Member 'UCaptainAmericaAnimInstance::bFlash' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsFallingInPlace) == 0x00093A, "Member 'UCaptainAmericaAnimInstance::bIsFallingInPlace' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bOnGround) == 0x00093B, "Member 'UCaptainAmericaAnimInstance::bOnGround' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bSprintToGround) == 0x00093C, "Member 'UCaptainAmericaAnimInstance::bSprintToGround' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bBackOnGround) == 0x00093D, "Member 'UCaptainAmericaAnimInstance::bBackOnGround' has a wrong offset!");

// Class Hero_1022.CaptainAmericaChildActor
// 0x0058 (0x0A98 - 0x0A40)
class ACaptainAmericaChildActor final : public AMarvelCharacterChildActor
{
public:
	bool                                          bSprint;                                           // 0x0A40(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecialJump;                                      // 0x0A41(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalJump;                                       // 0x0A42(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlash;                                            // 0x0A43(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShieldSocket;                                      // 0x0A44(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     NormalShieldMaterial;                              // 0x0A50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SpecialShieldMaterial;                             // 0x0A58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Shield;                                            // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ThunderBuffFX;                                     // 0x0A68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      RightHandArmorFX;                                  // 0x0A70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ChestBackArmorFX;                                  // 0x0A78(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A80[0x18];                                     // 0x0A80(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USkeletalMeshComponent* GetShieldMesh();
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaChildActor">();
	}
	static class ACaptainAmericaChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptainAmericaChildActor>();
	}
};
static_assert(alignof(ACaptainAmericaChildActor) == 0x000008, "Wrong alignment on ACaptainAmericaChildActor");
static_assert(sizeof(ACaptainAmericaChildActor) == 0x000A98, "Wrong size on ACaptainAmericaChildActor");
static_assert(offsetof(ACaptainAmericaChildActor, bSprint) == 0x000A40, "Member 'ACaptainAmericaChildActor::bSprint' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, bSpecialJump) == 0x000A41, "Member 'ACaptainAmericaChildActor::bSpecialJump' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, bNormalJump) == 0x000A42, "Member 'ACaptainAmericaChildActor::bNormalJump' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, bFlash) == 0x000A43, "Member 'ACaptainAmericaChildActor::bFlash' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, ShieldSocket) == 0x000A44, "Member 'ACaptainAmericaChildActor::ShieldSocket' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, NormalShieldMaterial) == 0x000A50, "Member 'ACaptainAmericaChildActor::NormalShieldMaterial' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, SpecialShieldMaterial) == 0x000A58, "Member 'ACaptainAmericaChildActor::SpecialShieldMaterial' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, Shield) == 0x000A60, "Member 'ACaptainAmericaChildActor::Shield' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, ThunderBuffFX) == 0x000A68, "Member 'ACaptainAmericaChildActor::ThunderBuffFX' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, RightHandArmorFX) == 0x000A70, "Member 'ACaptainAmericaChildActor::RightHandArmorFX' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, ChestBackArmorFX) == 0x000A78, "Member 'ACaptainAmericaChildActor::ChestBackArmorFX' has a wrong offset!");

// Class Hero_1022.CaptainAmericaCharacter
// 0x0010 (0x17D0 - 0x17C0)
class ACaptainAmericaCharacter : public AMarvelBaseCharacter
{
public:
	class UCaptainAmericaMoveLogicBaseComponent*  CaptainAmericaMoveLogic;                           // 0x17B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsShieldActive;                                   // 0x17C0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C1[0xF];                                     // 0x17C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceSetActorAndMeshRotation();
	class USkeletalMeshComponent* GetShieldMesh();
	void SetShieldActive(bool NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaCharacter">();
	}
	static class ACaptainAmericaCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptainAmericaCharacter>();
	}
};
static_assert(alignof(ACaptainAmericaCharacter) == 0x000010, "Wrong alignment on ACaptainAmericaCharacter");
static_assert(sizeof(ACaptainAmericaCharacter) == 0x0017D0, "Wrong size on ACaptainAmericaCharacter");
static_assert(offsetof(ACaptainAmericaCharacter, CaptainAmericaMoveLogic) == 0x0017B8, "Member 'ACaptainAmericaCharacter::CaptainAmericaMoveLogic' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaCharacter, bIsShieldActive) == 0x0017C0, "Member 'ACaptainAmericaCharacter::bIsShieldActive' has a wrong offset!");

// Class Hero_1022.CaptainAmericaMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UCaptainAmericaMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	void ResetBackwardWalkSpeedRatio();
	void SetBackwardWalkSpeedRatio(float NewBackwardWalkSpeedRatio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaMoveLogicBaseComponent">();
	}
	static class UCaptainAmericaMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptainAmericaMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UCaptainAmericaMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UCaptainAmericaMoveLogicBaseComponent");
static_assert(sizeof(UCaptainAmericaMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UCaptainAmericaMoveLogicBaseComponent");

// Class Hero_1022.CaptainAmericaMovementComponent
// 0x0000 (0x1AF0 - 0x1AF0)
class UCaptainAmericaMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaMovementComponent">();
	}
	static class UCaptainAmericaMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptainAmericaMovementComponent>();
	}
};
static_assert(alignof(UCaptainAmericaMovementComponent) == 0x000010, "Wrong alignment on UCaptainAmericaMovementComponent");
static_assert(sizeof(UCaptainAmericaMovementComponent) == 0x001AF0, "Wrong size on UCaptainAmericaMovementComponent");

// Class Hero_1022.EpicMomentAction_1022
// 0x0010 (0x0130 - 0x0120)
class UEpicMomentAction_1022 : public UEpicMomentBaseAction
{
public:
	struct FEpicMomentNodeInfo                    ShieldConfig;                                      // 0x0120(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1022">();
	}
	static class UEpicMomentAction_1022* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1022>();
	}
};
static_assert(alignof(UEpicMomentAction_1022) == 0x000008, "Wrong alignment on UEpicMomentAction_1022");
static_assert(sizeof(UEpicMomentAction_1022) == 0x000130, "Wrong size on UEpicMomentAction_1022");
static_assert(offsetof(UEpicMomentAction_1022, ShieldConfig) == 0x000120, "Member 'UEpicMomentAction_1022::ShieldConfig' has a wrong offset!");

}

