#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1039

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Hero_1039_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Class Hero_1039.BuffAbility_10390102
// 0x0390 (0x1478 - 0x10E8)
class UBuffAbility_10390102 : public UMarvelEffectGameplayAbility
{
public:
	struct FMarvelTraceRule                       TargetToEnergyConversion;                          // 0x10E8(0x0390)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	bool IsValidTargetForEnergy(class AActor* InActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffAbility_10390102">();
	}
	static class UBuffAbility_10390102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffAbility_10390102>();
	}
};
static_assert(alignof(UBuffAbility_10390102) == 0x000008, "Wrong alignment on UBuffAbility_10390102");
static_assert(sizeof(UBuffAbility_10390102) == 0x001478, "Wrong size on UBuffAbility_10390102");
static_assert(offsetof(UBuffAbility_10390102, TargetToEnergyConversion) == 0x0010E8, "Member 'UBuffAbility_10390102::TargetToEnergyConversion' has a wrong offset!");

// Class Hero_1039.Projectile_10392101
// 0x0050 (0x2FB0 - 0x2F60)
class AProjectile_10392101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	class UCurveFloat*                            SpeedCurve;                                        // 0x2F60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           HommingOffsetCurve;                                // 0x2F68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HommingCurveMinDistance;                           // 0x2F70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F74[0x3C];                                    // 0x2F74(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10392101">();
	}
	static class AProjectile_10392101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10392101>();
	}
};
static_assert(alignof(AProjectile_10392101) == 0x000010, "Wrong alignment on AProjectile_10392101");
static_assert(sizeof(AProjectile_10392101) == 0x002FB0, "Wrong size on AProjectile_10392101");
static_assert(offsetof(AProjectile_10392101, SpeedCurve) == 0x002F60, "Member 'AProjectile_10392101::SpeedCurve' has a wrong offset!");
static_assert(offsetof(AProjectile_10392101, HommingOffsetCurve) == 0x002F68, "Member 'AProjectile_10392101::HommingOffsetCurve' has a wrong offset!");
static_assert(offsetof(AProjectile_10392101, HommingCurveMinDistance) == 0x002F70, "Member 'AProjectile_10392101::HommingCurveMinDistance' has a wrong offset!");

// Class Hero_1039.Cue_Projectile_Loop_10392102
// 0x0020 (0x0D80 - 0x0D60)
class ACue_Projectile_Loop_10392102 : public AMarvelCueNotify_Projectile
{
public:
	class UNiagaraComponent*                      WeaponNiagara;                                     // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLerpDistance;                              // 0x0D68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLerpAlpah;                                 // 0x0D6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HammerSocket;                                      // 0x0D70(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7C[0x4];                                      // 0x0D7C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10392102">();
	}
	static class ACue_Projectile_Loop_10392102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10392102>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10392102) == 0x000008, "Wrong alignment on ACue_Projectile_Loop_10392102");
static_assert(sizeof(ACue_Projectile_Loop_10392102) == 0x000D80, "Wrong size on ACue_Projectile_Loop_10392102");
static_assert(offsetof(ACue_Projectile_Loop_10392102, WeaponNiagara) == 0x000D60, "Member 'ACue_Projectile_Loop_10392102::WeaponNiagara' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10392102, RotationLerpDistance) == 0x000D68, "Member 'ACue_Projectile_Loop_10392102::RotationLerpDistance' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10392102, RotationLerpAlpah) == 0x000D6C, "Member 'ACue_Projectile_Loop_10392102::RotationLerpAlpah' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10392102, HammerSocket) == 0x000D70, "Member 'ACue_Projectile_Loop_10392102::HammerSocket' has a wrong offset!");

// Class Hero_1039.Config_103931
// 0x0020 (0x00B8 - 0x0098)
class UConfig_103931 : public UMarvelAbilityConfig
{
public:
	float                                         RestoreEnergyValue;                                // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CrossBuffId;                                       // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrossDamage;                                       // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   DamageTags;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103931">();
	}
	static class UConfig_103931* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103931>();
	}
};
static_assert(alignof(UConfig_103931) == 0x000008, "Wrong alignment on UConfig_103931");
static_assert(sizeof(UConfig_103931) == 0x0000B8, "Wrong size on UConfig_103931");
static_assert(offsetof(UConfig_103931, RestoreEnergyValue) == 0x000098, "Member 'UConfig_103931::RestoreEnergyValue' has a wrong offset!");
static_assert(offsetof(UConfig_103931, CrossBuffId) == 0x00009C, "Member 'UConfig_103931::CrossBuffId' has a wrong offset!");
static_assert(offsetof(UConfig_103931, CrossDamage) == 0x0000A0, "Member 'UConfig_103931::CrossDamage' has a wrong offset!");
static_assert(offsetof(UConfig_103931, DamageTags) == 0x0000A8, "Member 'UConfig_103931::DamageTags' has a wrong offset!");

// Class Hero_1039.Ability_103931
// 0x0018 (0x2570 - 0x2558)
class UAbility_103931 : public UAbility_108
{
public:
	float                                         ConfigRestoreEnergy;                               // 0x2558(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255C[0xC];                                     // 0x255C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_103931*                         Config;                                            // 0x2568(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103931">();
	}
	static class UAbility_103931* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103931>();
	}
};
static_assert(alignof(UAbility_103931) == 0x000008, "Wrong alignment on UAbility_103931");
static_assert(sizeof(UAbility_103931) == 0x002570, "Wrong size on UAbility_103931");
static_assert(offsetof(UAbility_103931, ConfigRestoreEnergy) == 0x002558, "Member 'UAbility_103931::ConfigRestoreEnergy' has a wrong offset!");
static_assert(offsetof(UAbility_103931, Config) == 0x002568, "Member 'UAbility_103931::Config' has a wrong offset!");

// Class Hero_1039.Scope_10393101
// 0x0060 (0x1720 - 0x16C0)
class AScope_10393101 : public AMarvelAbilityTargetActor_Scope
{
public:
	uint8                                         Pad_16C0[0x60];                                    // 0x16C0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitTarget(class AMarvelBaseCharacter* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10393101">();
	}
	static class AScope_10393101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10393101>();
	}
};
static_assert(alignof(AScope_10393101) == 0x000010, "Wrong alignment on AScope_10393101");
static_assert(sizeof(AScope_10393101) == 0x001720, "Wrong size on AScope_10393101");

// Class Hero_1039.Ability_103941
// 0x0000 (0x2550 - 0x2550)
class UAbility_103941 : public UMarvelGameplayAbility
{
public:
	void ModifyDashInfo(class UMarvelAbilityTask_Dash* InDashTask, const struct FDashAbilityInfo& InDashInfo);
	void UpdateAnimation();
	void UpdateBodyInstance(class AMarvelBaseCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103941">();
	}
	static class UAbility_103941* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103941>();
	}
};
static_assert(alignof(UAbility_103941) == 0x000008, "Wrong alignment on UAbility_103941");
static_assert(sizeof(UAbility_103941) == 0x002550, "Wrong size on UAbility_103941");

// Class Hero_1039.Widget_Extra_ThorCharge
// 0x0010 (0x07B0 - 0x07A0)
class UWidget_Extra_ThorCharge : public UWidget_AbilityStatus_Normal
{
public:
	class UWidget_AbilityEnergy*                  Widget_Energy;                                     // 0x07A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCharging;                                       // 0x07A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A9[0x7];                                      // 0x07A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginMaxCharge();
	float GetChargePercent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Widget_Extra_ThorCharge">();
	}
	static class UWidget_Extra_ThorCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidget_Extra_ThorCharge>();
	}
};
static_assert(alignof(UWidget_Extra_ThorCharge) == 0x000008, "Wrong alignment on UWidget_Extra_ThorCharge");
static_assert(sizeof(UWidget_Extra_ThorCharge) == 0x0007B0, "Wrong size on UWidget_Extra_ThorCharge");
static_assert(offsetof(UWidget_Extra_ThorCharge, Widget_Energy) == 0x0007A0, "Member 'UWidget_Extra_ThorCharge::Widget_Energy' has a wrong offset!");
static_assert(offsetof(UWidget_Extra_ThorCharge, bIsCharging) == 0x0007A8, "Member 'UWidget_Extra_ThorCharge::bIsCharging' has a wrong offset!");

// Class Hero_1039.Cue_Ability_Loop_10395102
// 0x0018 (0x0E18 - 0x0E00)
class ACue_Ability_Loop_10395102 : public AMarvelCueNotify_Ability
{
public:
	int32                                         MoveStartAudioId;                                  // 0x0E00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveStopAudioId;                                   // 0x0E04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E08[0x8];                                      // 0x0E08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   MyCharacter;                                       // 0x0E10(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCharacterMoveChange(bool bMoving);
	void OnCharacterMovementUpdate(float DeltaTime, const struct FVector& OldLocation, const struct FVector& OldVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10395102">();
	}
	static class ACue_Ability_Loop_10395102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10395102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10395102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10395102");
static_assert(sizeof(ACue_Ability_Loop_10395102) == 0x000E18, "Wrong size on ACue_Ability_Loop_10395102");
static_assert(offsetof(ACue_Ability_Loop_10395102, MoveStartAudioId) == 0x000E00, "Member 'ACue_Ability_Loop_10395102::MoveStartAudioId' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10395102, MoveStopAudioId) == 0x000E04, "Member 'ACue_Ability_Loop_10395102::MoveStopAudioId' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10395102, MyCharacter) == 0x000E10, "Member 'ACue_Ability_Loop_10395102::MyCharacter' has a wrong offset!");

// Class Hero_1039.Config_103961
// 0x0018 (0x00B0 - 0x0098)
class UConfig_103961 : public UMarvelAbilityConfig
{
public:
	struct FVector                                CustomScopeOffset;                                 // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103961">();
	}
	static class UConfig_103961* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103961>();
	}
};
static_assert(alignof(UConfig_103961) == 0x000008, "Wrong alignment on UConfig_103961");
static_assert(sizeof(UConfig_103961) == 0x0000B0, "Wrong size on UConfig_103961");
static_assert(offsetof(UConfig_103961, CustomScopeOffset) == 0x000098, "Member 'UConfig_103961::CustomScopeOffset' has a wrong offset!");

// Class Hero_1039.Ability_103961
// 0x0008 (0x2558 - 0x2550)
class UAbility_103961 : public UMarvelGameplayAbility
{
public:
	class UConfig_103961*                         Config;                                            // 0x2550(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector ApplyScopeRelativePos(const struct FVector& InPos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103961">();
	}
	static class UAbility_103961* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103961>();
	}
};
static_assert(alignof(UAbility_103961) == 0x000008, "Wrong alignment on UAbility_103961");
static_assert(sizeof(UAbility_103961) == 0x002558, "Wrong size on UAbility_103961");
static_assert(offsetof(UAbility_103961, Config) == 0x002550, "Member 'UAbility_103961::Config' has a wrong offset!");

// Class Hero_1039.MarvelAbilityTask_PreArrivedDash
// 0x0020 (0x1DE0 - 0x1DC0)
class UMarvelAbilityTask_PreArrivedDash final : public UMarvelAbilityTask_Dash
{
public:
	FMulticastInlineDelegateProperty_             PreArrivedDelegate;                                // 0x1DC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPreArrivedInfo                        PreArrivedInfo;                                    // 0x1DD0(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasPreArrived;                                    // 0x1DD8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DD9[0x3];                                     // 0x1DD9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivateTime;                                      // 0x1DDC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UMarvelAbilityTask_PreArrivedDash* ApplyPreDash(class UMarvelBaseGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FDashAbilityInfo& Info, const struct FPreArrivedInfo& PreInfo, const struct FVector& InDirection, const struct FVector& InTargetLocation, class AActor* InTargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAbilityTask_PreArrivedDash">();
	}
	static class UMarvelAbilityTask_PreArrivedDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAbilityTask_PreArrivedDash>();
	}
};
static_assert(alignof(UMarvelAbilityTask_PreArrivedDash) == 0x000008, "Wrong alignment on UMarvelAbilityTask_PreArrivedDash");
static_assert(sizeof(UMarvelAbilityTask_PreArrivedDash) == 0x001DE0, "Wrong size on UMarvelAbilityTask_PreArrivedDash");
static_assert(offsetof(UMarvelAbilityTask_PreArrivedDash, PreArrivedDelegate) == 0x001DC0, "Member 'UMarvelAbilityTask_PreArrivedDash::PreArrivedDelegate' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_PreArrivedDash, PreArrivedInfo) == 0x001DD0, "Member 'UMarvelAbilityTask_PreArrivedDash::PreArrivedInfo' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_PreArrivedDash, bHasPreArrived) == 0x001DD8, "Member 'UMarvelAbilityTask_PreArrivedDash::bHasPreArrived' has a wrong offset!");
static_assert(offsetof(UMarvelAbilityTask_PreArrivedDash, ActivateTime) == 0x001DDC, "Member 'UMarvelAbilityTask_PreArrivedDash::ActivateTime' has a wrong offset!");

// Class Hero_1039.Cue_Ability_Loop_10396101
// 0x0028 (0x0E28 - 0x0E00)
class ACue_Ability_Loop_10396101 : public AMarvelCueNotify_Ability
{
public:
	int32                                         ScopeTableID;                                      // 0x0E00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineLength;                                        // 0x0E04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceTypeQuery;                                    // 0x0E08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E09[0x7];                                      // 0x0E09(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        DecalComponent;                                    // 0x0E10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   MyCharacter;                                       // 0x0E18(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbility_103961*                        MyAbility;                                         // 0x0E20(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10396101">();
	}
	static class ACue_Ability_Loop_10396101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10396101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10396101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10396101");
static_assert(sizeof(ACue_Ability_Loop_10396101) == 0x000E28, "Wrong size on ACue_Ability_Loop_10396101");
static_assert(offsetof(ACue_Ability_Loop_10396101, ScopeTableID) == 0x000E00, "Member 'ACue_Ability_Loop_10396101::ScopeTableID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10396101, LineLength) == 0x000E04, "Member 'ACue_Ability_Loop_10396101::LineLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10396101, TraceTypeQuery) == 0x000E08, "Member 'ACue_Ability_Loop_10396101::TraceTypeQuery' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10396101, DecalComponent) == 0x000E10, "Member 'ACue_Ability_Loop_10396101::DecalComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10396101, MyCharacter) == 0x000E18, "Member 'ACue_Ability_Loop_10396101::MyCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10396101, MyAbility) == 0x000E20, "Member 'ACue_Ability_Loop_10396101::MyAbility' has a wrong offset!");

// Class Hero_1039.TabData_1039
// 0x0000 (0x0050 - 0x0050)
class UTabData_1039 : public UHeroTabDataBase
{
public:
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1039">();
	}
	static class UTabData_1039* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1039>();
	}
};
static_assert(alignof(UTabData_1039) == 0x000008, "Wrong alignment on UTabData_1039");
static_assert(sizeof(UTabData_1039) == 0x000050, "Wrong size on UTabData_1039");

// Class Hero_1039.ThorAnimInstance
// 0x0040 (0x0940 - 0x0900)
class UThorAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bUseAeroMotion;                                    // 0x0900(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseStrikeFlyMotion;                               // 0x0901(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_902[0x2];                                      // 0x0902(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseMotionIndex;                                   // 0x0904(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_908[0x38];                                     // 0x0908(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagUpdated(const struct FGameplayTag& Tag, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThorAnimInstance">();
	}
	static class UThorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThorAnimInstance>();
	}
};
static_assert(alignof(UThorAnimInstance) == 0x000010, "Wrong alignment on UThorAnimInstance");
static_assert(sizeof(UThorAnimInstance) == 0x000940, "Wrong size on UThorAnimInstance");
static_assert(offsetof(UThorAnimInstance, bUseAeroMotion) == 0x000900, "Member 'UThorAnimInstance::bUseAeroMotion' has a wrong offset!");
static_assert(offsetof(UThorAnimInstance, bUseStrikeFlyMotion) == 0x000901, "Member 'UThorAnimInstance::bUseStrikeFlyMotion' has a wrong offset!");
static_assert(offsetof(UThorAnimInstance, BaseMotionIndex) == 0x000904, "Member 'UThorAnimInstance::BaseMotionIndex' has a wrong offset!");

// Class Hero_1039.ThorCharacter
// 0x0000 (0x17C0 - 0x17C0)
class AThorCharacter : public AMarvelBaseCharacter
{
public:
	class UThorMoveLogicBaseComponent*            ThorMoveLogic;                                     // 0x17B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThorCharacter">();
	}
	static class AThorCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThorCharacter>();
	}
};
static_assert(alignof(AThorCharacter) == 0x000010, "Wrong alignment on AThorCharacter");
static_assert(sizeof(AThorCharacter) == 0x0017C0, "Wrong size on AThorCharacter");
static_assert(offsetof(AThorCharacter, ThorMoveLogic) == 0x0017B8, "Member 'AThorCharacter::ThorMoveLogic' has a wrong offset!");

// Class Hero_1039.ThorMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UThorMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThorMoveLogicBaseComponent">();
	}
	static class UThorMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThorMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UThorMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UThorMoveLogicBaseComponent");
static_assert(sizeof(UThorMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UThorMoveLogicBaseComponent");

// Class Hero_1039.ThorMovementComponent
// 0x0000 (0x1AF0 - 0x1AF0)
class UThorMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThorMovementComponent">();
	}
	static class UThorMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThorMovementComponent>();
	}
};
static_assert(alignof(UThorMovementComponent) == 0x000010, "Wrong alignment on UThorMovementComponent");
static_assert(sizeof(UThorMovementComponent) == 0x001AF0, "Wrong size on UThorMovementComponent");

}

