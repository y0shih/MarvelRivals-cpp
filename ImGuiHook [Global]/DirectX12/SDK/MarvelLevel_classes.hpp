#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MarvelLevel

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "MarvelLevel_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class MarvelLevel.AnimNotify_LevelAnimSectionEnded
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_LevelAnimSectionEnded final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_LevelAnimSectionEnded">();
	}
	static class UAnimNotify_LevelAnimSectionEnded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_LevelAnimSectionEnded>();
	}
};
static_assert(alignof(UAnimNotify_LevelAnimSectionEnded) == 0x000008, "Wrong alignment on UAnimNotify_LevelAnimSectionEnded");
static_assert(sizeof(UAnimNotify_LevelAnimSectionEnded) == 0x000040, "Wrong size on UAnimNotify_LevelAnimSectionEnded");

// Class MarvelLevel.DeathZoneActor
// 0x0000 (0x0470 - 0x0470)
class ADeathZoneActor : public AMarvelLevelActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathZoneActor">();
	}
	static class ADeathZoneActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeathZoneActor>();
	}
};
static_assert(alignof(ADeathZoneActor) == 0x000008, "Wrong alignment on ADeathZoneActor");
static_assert(sizeof(ADeathZoneActor) == 0x000470, "Wrong size on ADeathZoneActor");

// Class MarvelLevel.EnvironmentGlobalActor
// 0x0000 (0x0470 - 0x0470)
class AEnvironmentGlobalActor final : public AEnvironmentStaticActorBase
{
public:
	void ChangeQuality(bool IsHighQuality);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentGlobalActor">();
	}
	static class AEnvironmentGlobalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentGlobalActor>();
	}
};
static_assert(alignof(AEnvironmentGlobalActor) == 0x000008, "Wrong alignment on AEnvironmentGlobalActor");
static_assert(sizeof(AEnvironmentGlobalActor) == 0x000470, "Wrong size on AEnvironmentGlobalActor");

// Class MarvelLevel.EnvironmentStaticActor
// 0x0018 (0x0488 - 0x0470)
class AEnvironmentStaticActor final : public AEnvironmentStaticActorBase
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvironmentActorTransitionComponent*   EnvironmentTransition;                             // 0x0478(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTransitionCompRemoved;                          // 0x0480(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_481[0x7];                                      // 0x0481(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentStaticActor">();
	}
	static class AEnvironmentStaticActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentStaticActor>();
	}
};
static_assert(alignof(AEnvironmentStaticActor) == 0x000008, "Wrong alignment on AEnvironmentStaticActor");
static_assert(sizeof(AEnvironmentStaticActor) == 0x000488, "Wrong size on AEnvironmentStaticActor");
static_assert(offsetof(AEnvironmentStaticActor, MeshComponent) == 0x000470, "Member 'AEnvironmentStaticActor::MeshComponent' has a wrong offset!");
static_assert(offsetof(AEnvironmentStaticActor, EnvironmentTransition) == 0x000478, "Member 'AEnvironmentStaticActor::EnvironmentTransition' has a wrong offset!");
static_assert(offsetof(AEnvironmentStaticActor, bIsTransitionCompRemoved) == 0x000480, "Member 'AEnvironmentStaticActor::bIsTransitionCompRemoved' has a wrong offset!");

// Class MarvelLevel.FillColorBox
// 0x0010 (0x0480 - 0x0470)
class AFillColorBox final : public AActor
{
public:
	TArray<uint64>                                FillColorStateList;                                // 0x0470(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)

public:
	struct FPaintSceneReconnectRebuildData GeneratePaintSceneRebuildData();
	TArray<int32> GetItemsState(const int32 InArrayLength);
	void InitializeItems(const int32 InArrayLength);
	void OnRep_FillColorStateList();
	void ReceiveDataForPy();
	void RewindForReplayForPy();
	void UpdateItemState(const TArray<int32>& ArrayIndexList, const int32 NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FillColorBox">();
	}
	static class AFillColorBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFillColorBox>();
	}
};
static_assert(alignof(AFillColorBox) == 0x000008, "Wrong alignment on AFillColorBox");
static_assert(sizeof(AFillColorBox) == 0x000480, "Wrong size on AFillColorBox");
static_assert(offsetof(AFillColorBox, FillColorStateList) == 0x000470, "Member 'AFillColorBox::FillColorStateList' has a wrong offset!");

// Class MarvelLevel.FillColorPoint
// 0x0000 (0x0470 - 0x0470)
class AFillColorPoint final : public AActor
{
public:
	void FillColor(EBattleSide BattleSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FillColorPoint">();
	}
	static class AFillColorPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFillColorPoint>();
	}
};
static_assert(alignof(AFillColorPoint) == 0x000008, "Wrong alignment on AFillColorPoint");
static_assert(sizeof(AFillColorPoint) == 0x000470, "Wrong size on AFillColorPoint");

// Class MarvelLevel.LevelAnimBaseActor
// 0x0000 (0x0470 - 0x0470)
class ALevelAnimBaseActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAnimBaseActor">();
	}
	static class ALevelAnimBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelAnimBaseActor>();
	}
};
static_assert(alignof(ALevelAnimBaseActor) == 0x000008, "Wrong alignment on ALevelAnimBaseActor");
static_assert(sizeof(ALevelAnimBaseActor) == 0x000470, "Wrong size on ALevelAnimBaseActor");

// Class MarvelLevel.LevelAnimMovementComponent
// 0x01C0 (0x0338 - 0x0178)
class ULevelAnimMovementComponent final : public UMovementComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMovementBaseChanged;                             // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bTickPoseOnDS;                                     // 0x0188(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanUpdateFromRootMotion : 1;                      // 0x0189(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableKinematic : 1;                              // 0x0189(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_18A[0x6];                                      // 0x018A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelLevelAnimBaseActor*              LevelAnimOwner;                                    // 0x0190(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    MovementBase;                                      // 0x0198(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             FloorHitResult;                                    // 0x01A0(0x0160)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	ELevelAnimMoveMode                            MovementMode;                                      // 0x0300(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityScale;                                      // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                GravityDirection;                                  // 0x0308(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocalGravityZ;                                     // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableSlide;                                      // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValidAngle;                                        // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepDeltaValue;                                   // 0x032C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELevelAnimMoveMode                            InitMovementMode;                                  // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAnimMovementComponent">();
	}
	static class ULevelAnimMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelAnimMovementComponent>();
	}
};
static_assert(alignof(ULevelAnimMovementComponent) == 0x000008, "Wrong alignment on ULevelAnimMovementComponent");
static_assert(sizeof(ULevelAnimMovementComponent) == 0x000338, "Wrong size on ULevelAnimMovementComponent");
static_assert(offsetof(ULevelAnimMovementComponent, OnMovementBaseChanged) == 0x000178, "Member 'ULevelAnimMovementComponent::OnMovementBaseChanged' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, bTickPoseOnDS) == 0x000188, "Member 'ULevelAnimMovementComponent::bTickPoseOnDS' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, LevelAnimOwner) == 0x000190, "Member 'ULevelAnimMovementComponent::LevelAnimOwner' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, MovementBase) == 0x000198, "Member 'ULevelAnimMovementComponent::MovementBase' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, FloorHitResult) == 0x0001A0, "Member 'ULevelAnimMovementComponent::FloorHitResult' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, MovementMode) == 0x000300, "Member 'ULevelAnimMovementComponent::MovementMode' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, GravityScale) == 0x000304, "Member 'ULevelAnimMovementComponent::GravityScale' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, GravityDirection) == 0x000308, "Member 'ULevelAnimMovementComponent::GravityDirection' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, LocalGravityZ) == 0x000320, "Member 'ULevelAnimMovementComponent::LocalGravityZ' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, bEnableSlide) == 0x000324, "Member 'ULevelAnimMovementComponent::bEnableSlide' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, ValidAngle) == 0x000328, "Member 'ULevelAnimMovementComponent::ValidAngle' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, SweepDeltaValue) == 0x00032C, "Member 'ULevelAnimMovementComponent::SweepDeltaValue' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, InitMovementMode) == 0x000330, "Member 'ULevelAnimMovementComponent::InitMovementMode' has a wrong offset!");

// Class MarvelLevel.LevelAudioActor
// 0x0008 (0x0478 - 0x0470)
class ALevelAudioActor final : public AActor
{
public:
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAkComponent* PyGetDefaultAkComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAudioActor">();
	}
	static class ALevelAudioActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelAudioActor>();
	}
};
static_assert(alignof(ALevelAudioActor) == 0x000008, "Wrong alignment on ALevelAudioActor");
static_assert(sizeof(ALevelAudioActor) == 0x000478, "Wrong size on ALevelAudioActor");

// Class MarvelLevel.LevelBlockActor
// 0x0018 (0x0488 - 0x0470)
class ALevelBlockActor final : public AMarvelLevelActorBase
{
public:
	uint8                                         bIsBlockPawn : 1;                                  // 0x0470(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsBlockAttack : 1;                                // 0x0470(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBattleSide>                           IgnoreBattleSides;                                 // 0x0478(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void UpdateMaskFilter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelBlockActor">();
	}
	static class ALevelBlockActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelBlockActor>();
	}
};
static_assert(alignof(ALevelBlockActor) == 0x000008, "Wrong alignment on ALevelBlockActor");
static_assert(sizeof(ALevelBlockActor) == 0x000488, "Wrong size on ALevelBlockActor");
static_assert(offsetof(ALevelBlockActor, IgnoreBattleSides) == 0x000478, "Member 'ALevelBlockActor::IgnoreBattleSides' has a wrong offset!");

// Class MarvelLevel.LevelCustomEventSubsystem
// 0x0000 (0x0038 - 0x0038)
class ULevelCustomEventSubsystem : public UWorldSubsystem
{
public:
	static class ULevelCustomEventSubsystem* GetLevelCustomEventSubsystem(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelCustomEventSubsystem">();
	}
	static class ULevelCustomEventSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelCustomEventSubsystem>();
	}
};
static_assert(alignof(ULevelCustomEventSubsystem) == 0x000008, "Wrong alignment on ULevelCustomEventSubsystem");
static_assert(sizeof(ULevelCustomEventSubsystem) == 0x000038, "Wrong size on ULevelCustomEventSubsystem");

// Class MarvelLevel.LevelFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class ULevelFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DestroyWorldNetDrive(class UObject* WorldContextObject);
	static void DestroyWorldNetDriver(class UObject* WorldContextObject);
	static int32 FindDeathCollectionIndex(class UObject* WorldContextObject);
	static void GetAllActorsWithTagInWorld(class UObject* WorldContextObject, const TArray<class FName>& Tags, TMap<class FName, struct FActorsWithSameOneTag>* OutActors);
	static float GetSequenceLength(class ULevelSequence* LevelSequence);
	static float GetSequencePlayerCurrentTime(class ULevelSequencePlayer* LevelSequencePlayer);
	static void LevelSetClientTravel(class UObject* WorldContextObject, const class FString& NextURLString);
	static TArray<struct FVector> MeshData(const class UStaticMeshComponent* StaticMeshComponent);
	static void ModifyLevelFoliageMaterial();
	static void SequencePlayerJumpTo(class ULevelSequencePlayer* LevelSequencePlayer, float TargetTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelFunctionLibrary">();
	}
	static class ULevelFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelFunctionLibrary>();
	}
};
static_assert(alignof(ULevelFunctionLibrary) == 0x000008, "Wrong alignment on ULevelFunctionLibrary");
static_assert(sizeof(ULevelFunctionLibrary) == 0x000030, "Wrong size on ULevelFunctionLibrary");

// Class MarvelLevel.MarvelLevelSummonedBase
// 0x0020 (0x0820 - 0x0800)
class AMarvelLevelSummonedBase : public AMarvelSummonerBase
{
public:
	uint8                                         Pad_7F8[0x10];                                     // 0x07F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeamComponent*                         TeamComponent;                                     // 0x0808(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHittable;                                         // 0x0810(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_811[0x3];                                      // 0x0811(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EReplicationLevel                             ConfigRepLevel;                                    // 0x0814(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfigNetFrequency;                                // 0x0818(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81C[0x4];                                      // 0x081C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTriggerRepCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelSummonedBase">();
	}
	static class AMarvelLevelSummonedBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelSummonedBase>();
	}
};
static_assert(alignof(AMarvelLevelSummonedBase) == 0x000010, "Wrong alignment on AMarvelLevelSummonedBase");
static_assert(sizeof(AMarvelLevelSummonedBase) == 0x000820, "Wrong size on AMarvelLevelSummonedBase");
static_assert(offsetof(AMarvelLevelSummonedBase, TeamComponent) == 0x000808, "Member 'AMarvelLevelSummonedBase::TeamComponent' has a wrong offset!");
static_assert(offsetof(AMarvelLevelSummonedBase, bHittable) == 0x000810, "Member 'AMarvelLevelSummonedBase::bHittable' has a wrong offset!");
static_assert(offsetof(AMarvelLevelSummonedBase, ConfigRepLevel) == 0x000814, "Member 'AMarvelLevelSummonedBase::ConfigRepLevel' has a wrong offset!");
static_assert(offsetof(AMarvelLevelSummonedBase, ConfigNetFrequency) == 0x000818, "Member 'AMarvelLevelSummonedBase::ConfigNetFrequency' has a wrong offset!");

// Class MarvelLevel.LevelGravityElevator
// 0x0210 (0x0A30 - 0x0820)
class ALevelGravityElevator final : public AMarvelLevelSummonedBase
{
public:
	int32                                         Priority;                                          // 0x0820(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GravityElevatorEffectID;                           // 0x0824(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GravityDurationTime;                               // 0x0828(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EndPointKnockUpEffectID;                           // 0x082C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinBrakingFriction;                                // 0x0830(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinBrakingDecelerationFalling;                     // 0x0834(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinBrakingDecelerationFlying;                      // 0x0838(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_83C[0x4];                                      // 0x083C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PathConveyedVelocity;                              // 0x0840(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PathConveyedEndPoint;                              // 0x0858(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GapTime;                                           // 0x0870(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_874[0x4];                                      // 0x0874(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreTags;                                        // 0x0878(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  RequireTags;                                       // 0x08E0(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         TimeInterval;                                      // 0x0948(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94C[0x1C];                                     // 0x094C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FActiveGameplayEffectHandle> CharacterEffectDict;                               // 0x0968(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           InsideCharacter;                                   // 0x09B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<int32, float>                            EffectTimeDict;                                    // 0x09C8(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxComponent;                                      // 0x0A18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A20[0x10];                                     // 0x0A20(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetPathVelocity(const struct FVector& InVelocity, class UPrimitiveComponent* UpdatedComponent, const struct FVector& InGravity, float DeltaTime, EMovementMode MovementMode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelGravityElevator">();
	}
	static class ALevelGravityElevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelGravityElevator>();
	}
};
static_assert(alignof(ALevelGravityElevator) == 0x000010, "Wrong alignment on ALevelGravityElevator");
static_assert(sizeof(ALevelGravityElevator) == 0x000A30, "Wrong size on ALevelGravityElevator");
static_assert(offsetof(ALevelGravityElevator, Priority) == 0x000820, "Member 'ALevelGravityElevator::Priority' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, GravityElevatorEffectID) == 0x000824, "Member 'ALevelGravityElevator::GravityElevatorEffectID' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, GravityDurationTime) == 0x000828, "Member 'ALevelGravityElevator::GravityDurationTime' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, EndPointKnockUpEffectID) == 0x00082C, "Member 'ALevelGravityElevator::EndPointKnockUpEffectID' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, MinBrakingFriction) == 0x000830, "Member 'ALevelGravityElevator::MinBrakingFriction' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, MinBrakingDecelerationFalling) == 0x000834, "Member 'ALevelGravityElevator::MinBrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, MinBrakingDecelerationFlying) == 0x000838, "Member 'ALevelGravityElevator::MinBrakingDecelerationFlying' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, PathConveyedVelocity) == 0x000840, "Member 'ALevelGravityElevator::PathConveyedVelocity' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, PathConveyedEndPoint) == 0x000858, "Member 'ALevelGravityElevator::PathConveyedEndPoint' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, GapTime) == 0x000870, "Member 'ALevelGravityElevator::GapTime' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, IgnoreTags) == 0x000878, "Member 'ALevelGravityElevator::IgnoreTags' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, RequireTags) == 0x0008E0, "Member 'ALevelGravityElevator::RequireTags' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, TimeInterval) == 0x000948, "Member 'ALevelGravityElevator::TimeInterval' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, CharacterEffectDict) == 0x000968, "Member 'ALevelGravityElevator::CharacterEffectDict' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, InsideCharacter) == 0x0009B8, "Member 'ALevelGravityElevator::InsideCharacter' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, EffectTimeDict) == 0x0009C8, "Member 'ALevelGravityElevator::EffectTimeDict' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, BoxComponent) == 0x000A18, "Member 'ALevelGravityElevator::BoxComponent' has a wrong offset!");

// Class MarvelLevel.LevelGravityElevatorAbility
// 0x0000 (0x10E8 - 0x10E8)
class ULevelGravityElevatorAbility final : public UMarvelEffectGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelGravityElevatorAbility">();
	}
	static class ULevelGravityElevatorAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelGravityElevatorAbility>();
	}
};
static_assert(alignof(ULevelGravityElevatorAbility) == 0x000008, "Wrong alignment on ULevelGravityElevatorAbility");
static_assert(sizeof(ULevelGravityElevatorAbility) == 0x0010E8, "Wrong size on ULevelGravityElevatorAbility");

// Class MarvelLevel.LevelGravityZoneGameplayEffectComponent
// 0x0048 (0x0078 - 0x0030)
class ULevelGravityZoneGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	struct FGameplayTagQuery                      BeDispelledQuery;                                  // 0x0030(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelGravityZoneGameplayEffectComponent">();
	}
	static class ULevelGravityZoneGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelGravityZoneGameplayEffectComponent>();
	}
};
static_assert(alignof(ULevelGravityZoneGameplayEffectComponent) == 0x000008, "Wrong alignment on ULevelGravityZoneGameplayEffectComponent");
static_assert(sizeof(ULevelGravityZoneGameplayEffectComponent) == 0x000078, "Wrong size on ULevelGravityZoneGameplayEffectComponent");
static_assert(offsetof(ULevelGravityZoneGameplayEffectComponent, BeDispelledQuery) == 0x000030, "Member 'ULevelGravityZoneGameplayEffectComponent::BeDispelledQuery' has a wrong offset!");

// Class MarvelLevel.LevelGravityZoneEffectTemplate
// 0x0000 (0x13A0 - 0x13A0)
class ULevelGravityZoneEffectTemplate : public UMarvelGameplayEffectTemplate
{
public:
	bool IsDispelledByAbility(const struct FGameplayTagContainer& AbilityTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelGravityZoneEffectTemplate">();
	}
	static class ULevelGravityZoneEffectTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelGravityZoneEffectTemplate>();
	}
};
static_assert(alignof(ULevelGravityZoneEffectTemplate) == 0x000008, "Wrong alignment on ULevelGravityZoneEffectTemplate");
static_assert(sizeof(ULevelGravityZoneEffectTemplate) == 0x0013A0, "Wrong size on ULevelGravityZoneEffectTemplate");

// Class MarvelLevel.Ability_200401
// 0x0000 (0x5A90 - 0x5A90)
class UAbility_200401 : public UMarvelAeroBaseAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_200401">();
	}
	static class UAbility_200401* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_200401>();
	}
};
static_assert(alignof(UAbility_200401) == 0x000010, "Wrong alignment on UAbility_200401");
static_assert(sizeof(UAbility_200401) == 0x005A90, "Wrong size on UAbility_200401");

// Class MarvelLevel.LevelLightControlActor
// 0x0068 (0x04D8 - 0x0470)
class ALevelLightControlActor final : public AActor
{
public:
	TArray<class FName>                           LightActorTags;                                    // 0x0470(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         FramingNumber;                                     // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlashRate;                                         // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxIntensityLight;                                 // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinIntensityLight;                                 // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0x48];                                     // 0x0490(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideLights();
	void Initialize();
	void StartChangeLights();
	void StopChangeLights();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelLightControlActor">();
	}
	static class ALevelLightControlActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelLightControlActor>();
	}
};
static_assert(alignof(ALevelLightControlActor) == 0x000008, "Wrong alignment on ALevelLightControlActor");
static_assert(sizeof(ALevelLightControlActor) == 0x0004D8, "Wrong size on ALevelLightControlActor");
static_assert(offsetof(ALevelLightControlActor, LightActorTags) == 0x000470, "Member 'ALevelLightControlActor::LightActorTags' has a wrong offset!");
static_assert(offsetof(ALevelLightControlActor, FramingNumber) == 0x000480, "Member 'ALevelLightControlActor::FramingNumber' has a wrong offset!");
static_assert(offsetof(ALevelLightControlActor, FlashRate) == 0x000484, "Member 'ALevelLightControlActor::FlashRate' has a wrong offset!");
static_assert(offsetof(ALevelLightControlActor, MaxIntensityLight) == 0x000488, "Member 'ALevelLightControlActor::MaxIntensityLight' has a wrong offset!");
static_assert(offsetof(ALevelLightControlActor, MinIntensityLight) == 0x00048C, "Member 'ALevelLightControlActor::MinIntensityLight' has a wrong offset!");

// Class MarvelLevel.LevelPackageRulesFuncLibrary
// 0x0000 (0x0030 - 0x0030)
class ULevelPackageRulesFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void UpdatePackageDataTables();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelPackageRulesFuncLibrary">();
	}
	static class ULevelPackageRulesFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelPackageRulesFuncLibrary>();
	}
};
static_assert(alignof(ULevelPackageRulesFuncLibrary) == 0x000008, "Wrong alignment on ULevelPackageRulesFuncLibrary");
static_assert(sizeof(ULevelPackageRulesFuncLibrary) == 0x000030, "Wrong size on ULevelPackageRulesFuncLibrary");

// Class MarvelLevel.LevelStaticMeshActor
// 0x0000 (0x0470 - 0x0470)
class ALevelStaticMeshActor final : public AActor
{
public:
	TArray<struct FVector> MeshData(const class UStaticMeshComponent* StaticMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStaticMeshActor">();
	}
	static class ALevelStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelStaticMeshActor>();
	}
};
static_assert(alignof(ALevelStaticMeshActor) == 0x000008, "Wrong alignment on ALevelStaticMeshActor");
static_assert(sizeof(ALevelStaticMeshActor) == 0x000470, "Wrong size on ALevelStaticMeshActor");

// Class MarvelLevel.LevelTransportPipe
// 0x0000 (0x0820 - 0x0820)
class ALevelTransportPipe final : public AMarvelLevelSummonedBase
{
public:
	bool GetKnockUp(struct FPhysicForceMove* OutPhysicKnockUp) const;
	struct FVector GetPathVelocity(const struct FVector& InVelocity, class UPrimitiveComponent* UpdatedComponent, const struct FVector& InGravity, float DeltaTime, EMovementMode MovementMode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelTransportPipe">();
	}
	static class ALevelTransportPipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelTransportPipe>();
	}
};
static_assert(alignof(ALevelTransportPipe) == 0x000010, "Wrong alignment on ALevelTransportPipe");
static_assert(sizeof(ALevelTransportPipe) == 0x000820, "Wrong size on ALevelTransportPipe");

// Class MarvelLevel.MarvelAudioCondition
// 0x0000 (0x0030 - 0x0030)
class UMarvelAudioCondition : public UObject
{
public:
	void PyPostEditChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAudioCondition">();
	}
	static class UMarvelAudioCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAudioCondition>();
	}
};
static_assert(alignof(UMarvelAudioCondition) == 0x000008, "Wrong alignment on UMarvelAudioCondition");
static_assert(sizeof(UMarvelAudioCondition) == 0x000030, "Wrong size on UMarvelAudioCondition");

// Class MarvelLevel.MarvelLevelAnimActionComponent
// 0x0180 (0x0270 - 0x00F0)
class UMarvelLevelAnimActionComponent final : public UActorComponent
{
public:
	TArray<struct FMarvelLevelAnimAction>         LevelAnimActions;                                  // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelAnimMovementComponent*            MovementComponent;                                 // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReplicatedActionIndex;                             // 0x0110(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x1C];                                     // 0x0114(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         WeakLinkingInteractableActors;                     // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x130];                                    // 0x0140(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyHit(class AActor* InSourceAvatar);
	void OnLinkClientGCBreak();
	void OnLinkGCBreak(const struct FChaosBreakEvent& BreakEvent);
	void OnLinkGCIgnoreBreak(const int32& Index_0, const float& ServerTime);
	void OnMovementBaseChanged(class UPrimitiveComponent* NewBase, struct FHitResult* FloorHitResult);
	void OnRep_ReplicatedActionIndex();
	void OnServerSimulateMontageSectionEnded();
	void ResetForLevelSwitch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelAnimActionComponent">();
	}
	static class UMarvelLevelAnimActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelLevelAnimActionComponent>();
	}
};
static_assert(alignof(UMarvelLevelAnimActionComponent) == 0x000008, "Wrong alignment on UMarvelLevelAnimActionComponent");
static_assert(sizeof(UMarvelLevelAnimActionComponent) == 0x000270, "Wrong size on UMarvelLevelAnimActionComponent");
static_assert(offsetof(UMarvelLevelAnimActionComponent, LevelAnimActions) == 0x0000F0, "Member 'UMarvelLevelAnimActionComponent::LevelAnimActions' has a wrong offset!");
static_assert(offsetof(UMarvelLevelAnimActionComponent, MeshComponent) == 0x000100, "Member 'UMarvelLevelAnimActionComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(UMarvelLevelAnimActionComponent, MovementComponent) == 0x000108, "Member 'UMarvelLevelAnimActionComponent::MovementComponent' has a wrong offset!");
static_assert(offsetof(UMarvelLevelAnimActionComponent, ReplicatedActionIndex) == 0x000110, "Member 'UMarvelLevelAnimActionComponent::ReplicatedActionIndex' has a wrong offset!");
static_assert(offsetof(UMarvelLevelAnimActionComponent, WeakLinkingInteractableActors) == 0x000130, "Member 'UMarvelLevelAnimActionComponent::WeakLinkingInteractableActors' has a wrong offset!");

// Class MarvelLevel.MarvelLevelAnimActor
// 0x0030 (0x04A0 - 0x0470)
class AMarvelLevelAnimActor final : public AMarvelLevelAnimBaseActor
{
public:
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0478(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0480(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelOptimizationComponent*            LevelOptimizationComp;                             // 0x0488(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelLevelAnimActionComponent*        ActionComponent;                                   // 0x0490(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelAnimMovementComponent*            MovementComponent;                                 // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAllRequiredMapLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelAnimActor">();
	}
	static class AMarvelLevelAnimActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelAnimActor>();
	}
};
static_assert(alignof(AMarvelLevelAnimActor) == 0x000008, "Wrong alignment on AMarvelLevelAnimActor");
static_assert(sizeof(AMarvelLevelAnimActor) == 0x0004A0, "Wrong size on AMarvelLevelAnimActor");
static_assert(offsetof(AMarvelLevelAnimActor, CapsuleComponent) == 0x000478, "Member 'AMarvelLevelAnimActor::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AMarvelLevelAnimActor, MeshComponent) == 0x000480, "Member 'AMarvelLevelAnimActor::MeshComponent' has a wrong offset!");
static_assert(offsetof(AMarvelLevelAnimActor, LevelOptimizationComp) == 0x000488, "Member 'AMarvelLevelAnimActor::LevelOptimizationComp' has a wrong offset!");
static_assert(offsetof(AMarvelLevelAnimActor, ActionComponent) == 0x000490, "Member 'AMarvelLevelAnimActor::ActionComponent' has a wrong offset!");
static_assert(offsetof(AMarvelLevelAnimActor, MovementComponent) == 0x000498, "Member 'AMarvelLevelAnimActor::MovementComponent' has a wrong offset!");

// Class MarvelLevel.MarvelLevelAudioItem
// 0x0000 (0x0038 - 0x0038)
class UMarvelLevelAudioItem : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelAudioItem">();
	}
	static class UMarvelLevelAudioItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelLevelAudioItem>();
	}
};
static_assert(alignof(UMarvelLevelAudioItem) == 0x000008, "Wrong alignment on UMarvelLevelAudioItem");
static_assert(sizeof(UMarvelLevelAudioItem) == 0x000038, "Wrong size on UMarvelLevelAudioItem");

// Class MarvelLevel.MarvelLevelKnockUpAbility
// 0x0000 (0x1D50 - 0x1D50)
class UMarvelLevelKnockUpAbility : public UMarvelKnockUpAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelKnockUpAbility">();
	}
	static class UMarvelLevelKnockUpAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelLevelKnockUpAbility>();
	}
};
static_assert(alignof(UMarvelLevelKnockUpAbility) == 0x000008, "Wrong alignment on UMarvelLevelKnockUpAbility");
static_assert(sizeof(UMarvelLevelKnockUpAbility) == 0x001D50, "Wrong size on UMarvelLevelKnockUpAbility");

// Class MarvelLevel.MarvelLevelProcessController
// 0x0000 (0x0470 - 0x0470)
class AMarvelLevelProcessController : public AMarvelLevelActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelProcessController">();
	}
	static class AMarvelLevelProcessController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelProcessController>();
	}
};
static_assert(alignof(AMarvelLevelProcessController) == 0x000008, "Wrong alignment on AMarvelLevelProcessController");
static_assert(sizeof(AMarvelLevelProcessController) == 0x000470, "Wrong size on AMarvelLevelProcessController");

// Class MarvelLevel.MarvelLevelRuleControlBase
// 0x00A0 (0x0190 - 0x00F0)
class UMarvelLevelRuleControlBase : public UActorComponent
{
public:
	TMap<class FString, struct FTimerHandle>      LevelNodeDelayTimeMap;                             // 0x00F0(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FTimerHandle>      LevelNodeRepeatTimeMap;                            // 0x0140(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelRuleControlBase">();
	}
	static class UMarvelLevelRuleControlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelLevelRuleControlBase>();
	}
};
static_assert(alignof(UMarvelLevelRuleControlBase) == 0x000008, "Wrong alignment on UMarvelLevelRuleControlBase");
static_assert(sizeof(UMarvelLevelRuleControlBase) == 0x000190, "Wrong size on UMarvelLevelRuleControlBase");
static_assert(offsetof(UMarvelLevelRuleControlBase, LevelNodeDelayTimeMap) == 0x0000F0, "Member 'UMarvelLevelRuleControlBase::LevelNodeDelayTimeMap' has a wrong offset!");
static_assert(offsetof(UMarvelLevelRuleControlBase, LevelNodeRepeatTimeMap) == 0x000140, "Member 'UMarvelLevelRuleControlBase::LevelNodeRepeatTimeMap' has a wrong offset!");

// Class MarvelLevel.MarvelLevelSummoned_StaticMesh
// 0x0010 (0x0830 - 0x0820)
class AMarvelLevelSummoned_StaticMesh final : public AMarvelLevelSummonedBase
{
public:
	class UStaticMeshComponent*                   SummonedStaticMesh;                                // 0x0820(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_828[0x8];                                      // 0x0828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelSummoned_StaticMesh">();
	}
	static class AMarvelLevelSummoned_StaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelSummoned_StaticMesh>();
	}
};
static_assert(alignof(AMarvelLevelSummoned_StaticMesh) == 0x000010, "Wrong alignment on AMarvelLevelSummoned_StaticMesh");
static_assert(sizeof(AMarvelLevelSummoned_StaticMesh) == 0x000830, "Wrong size on AMarvelLevelSummoned_StaticMesh");
static_assert(offsetof(AMarvelLevelSummoned_StaticMesh, SummonedStaticMesh) == 0x000820, "Member 'AMarvelLevelSummoned_StaticMesh::SummonedStaticMesh' has a wrong offset!");

// Class MarvelLevel.Cue_Buff_20000001
// 0x0008 (0x0FF0 - 0x0FE8)
class ACue_Buff_20000001 final : public AMarvelCueNotify_Buff
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0FE8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_20000001">();
	}
	static class ACue_Buff_20000001* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_20000001>();
	}
};
static_assert(alignof(ACue_Buff_20000001) == 0x000008, "Wrong alignment on ACue_Buff_20000001");
static_assert(sizeof(ACue_Buff_20000001) == 0x000FF0, "Wrong size on ACue_Buff_20000001");
static_assert(offsetof(ACue_Buff_20000001, AudioEvent) == 0x000FE8, "Member 'ACue_Buff_20000001::AudioEvent' has a wrong offset!");

// Class MarvelLevel.MarvelLevelSummoned_20000010
// 0x0010 (0x0830 - 0x0820)
class AMarvelLevelSummoned_20000010 final : public AMarvelLevelSummonedBase
{
public:
	TArray<class AActor*>                         ExOcclusionTargets;                                // 0x0820(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelSummoned_20000010">();
	}
	static class AMarvelLevelSummoned_20000010* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelSummoned_20000010>();
	}
};
static_assert(alignof(AMarvelLevelSummoned_20000010) == 0x000010, "Wrong alignment on AMarvelLevelSummoned_20000010");
static_assert(sizeof(AMarvelLevelSummoned_20000010) == 0x000830, "Wrong size on AMarvelLevelSummoned_20000010");
static_assert(offsetof(AMarvelLevelSummoned_20000010, ExOcclusionTargets) == 0x000820, "Member 'AMarvelLevelSummoned_20000010::ExOcclusionTargets' has a wrong offset!");

// Class MarvelLevel.MarvelLevelSummoned_KnockUp
// 0x0050 (0x0870 - 0x0820)
class AMarvelLevelSummoned_KnockUp final : public AMarvelLevelSummonedBase
{
public:
	struct FPhysicForceMove                       PhysicKnockUp;                                     // 0x0820(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelSummoned_KnockUp">();
	}
	static class AMarvelLevelSummoned_KnockUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelSummoned_KnockUp>();
	}
};
static_assert(alignof(AMarvelLevelSummoned_KnockUp) == 0x000010, "Wrong alignment on AMarvelLevelSummoned_KnockUp");
static_assert(sizeof(AMarvelLevelSummoned_KnockUp) == 0x000870, "Wrong size on AMarvelLevelSummoned_KnockUp");
static_assert(offsetof(AMarvelLevelSummoned_KnockUp, PhysicKnockUp) == 0x000820, "Member 'AMarvelLevelSummoned_KnockUp::PhysicKnockUp' has a wrong offset!");

// Class MarvelLevel.MarvelRuleCondition
// 0x0000 (0x0030 - 0x0030)
class UMarvelRuleCondition : public UObject
{
public:
	void PyPostEditChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelRuleCondition">();
	}
	static class UMarvelRuleCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelRuleCondition>();
	}
};
static_assert(alignof(UMarvelRuleCondition) == 0x000008, "Wrong alignment on UMarvelRuleCondition");
static_assert(sizeof(UMarvelRuleCondition) == 0x000030, "Wrong size on UMarvelRuleCondition");

// Class MarvelLevel.MarvelRuleConfig
// 0x0000 (0x0030 - 0x0030)
class UMarvelRuleConfig : public UObject
{
public:
	void PyPostEditChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelRuleConfig">();
	}
	static class UMarvelRuleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelRuleConfig>();
	}
};
static_assert(alignof(UMarvelRuleConfig) == 0x000008, "Wrong alignment on UMarvelRuleConfig");
static_assert(sizeof(UMarvelRuleConfig) == 0x000030, "Wrong size on UMarvelRuleConfig");

// Class MarvelLevel.MarvelRuleControllerItem
// 0x0008 (0x0040 - 0x0038)
class UMarvelRuleControllerItem final : public UPrimaryDataAsset
{
public:
	TSubclassOf<class UMarvelLevelRuleControlBase> RuleControllerClass;                               // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelRuleControllerItem">();
	}
	static class UMarvelRuleControllerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelRuleControllerItem>();
	}
};
static_assert(alignof(UMarvelRuleControllerItem) == 0x000008, "Wrong alignment on UMarvelRuleControllerItem");
static_assert(sizeof(UMarvelRuleControllerItem) == 0x000040, "Wrong size on UMarvelRuleControllerItem");
static_assert(offsetof(UMarvelRuleControllerItem, RuleControllerClass) == 0x000038, "Member 'UMarvelRuleControllerItem::RuleControllerClass' has a wrong offset!");

// Class MarvelLevel.MarvelRuleItem
// 0x0010 (0x0048 - 0x0038)
class UMarvelRuleItem final : public UPrimaryDataAsset
{
public:
	TArray<struct FRuleContent>                   RuleList;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelRuleItem">();
	}
	static class UMarvelRuleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelRuleItem>();
	}
};
static_assert(alignof(UMarvelRuleItem) == 0x000008, "Wrong alignment on UMarvelRuleItem");
static_assert(sizeof(UMarvelRuleItem) == 0x000048, "Wrong size on UMarvelRuleItem");
static_assert(offsetof(UMarvelRuleItem, RuleList) == 0x000038, "Member 'UMarvelRuleItem::RuleList' has a wrong offset!");

// Class MarvelLevel.PlayerStateTrainComponent
// 0x0030 (0x0120 - 0x00F0)
class UPlayerStateTrainComponent : public UMarvelActorComponentBase
{
public:
	int32                                         SelfPlayerUID;                                     // 0x00F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MainAttackHit;                                     // 0x00F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MainAttackMiss;                                    // 0x00F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         GenerateIDList;                                    // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MainAttackCriticalHit;                             // 0x0110(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillCount;                                         // 0x0114(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstigateDamage;                                   // 0x0118(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindMainAttack();
	void ClearMainAttackData();
	void OnActorDeath(class AActor* Source, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnActorTakeDamage(class AActor* InInstigator, class AActor* InTarget, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnRep_MainAttackHit();
	void OnRep_MainAttackMiss();
	void OnTargetActorRecycleAgentTask(class AActor* Source, class UMarvelGameplayAbility* SourceAbility, const struct FMarvelTargetActorGenerateInfo& GenerateInfo, const struct FEndAgentTaskInfo& EndAgentTaskInfo);
	void OnWeaponAmmoUse(class AActor* Source, class AActor* Target, int32 AbilityID, bool bHit, bool bIsCritHit, const struct FGlobalEventExtraData& ExtraData);
	void UnbindMainAttack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateTrainComponent">();
	}
	static class UPlayerStateTrainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateTrainComponent>();
	}
};
static_assert(alignof(UPlayerStateTrainComponent) == 0x000008, "Wrong alignment on UPlayerStateTrainComponent");
static_assert(sizeof(UPlayerStateTrainComponent) == 0x000120, "Wrong size on UPlayerStateTrainComponent");
static_assert(offsetof(UPlayerStateTrainComponent, SelfPlayerUID) == 0x0000F0, "Member 'UPlayerStateTrainComponent::SelfPlayerUID' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, MainAttackHit) == 0x0000F4, "Member 'UPlayerStateTrainComponent::MainAttackHit' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, MainAttackMiss) == 0x0000F8, "Member 'UPlayerStateTrainComponent::MainAttackMiss' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, GenerateIDList) == 0x000100, "Member 'UPlayerStateTrainComponent::GenerateIDList' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, MainAttackCriticalHit) == 0x000110, "Member 'UPlayerStateTrainComponent::MainAttackCriticalHit' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, KillCount) == 0x000114, "Member 'UPlayerStateTrainComponent::KillCount' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, InstigateDamage) == 0x000118, "Member 'UPlayerStateTrainComponent::InstigateDamage' has a wrong offset!");

// Class MarvelLevel.RuleComponent
// 0x0000 (0x00F0 - 0x00F0)
class URuleComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RuleComponent">();
	}
	static class URuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URuleComponent>();
	}
};
static_assert(alignof(URuleComponent) == 0x000008, "Wrong alignment on URuleComponent");
static_assert(sizeof(URuleComponent) == 0x0000F0, "Wrong size on URuleComponent");

// Class MarvelLevel.Summoned_20020001
// 0x0010 (0x0830 - 0x0820)
class ASummoned_20020001 final : public AMarvelLevelSummonedBase
{
public:
	class UStaticMeshComponent*                   SummonedStaticMesh;                                // 0x0820(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_828[0x8];                                      // 0x0828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_SetReplicatingMovement(bool NewReplicate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_20020001">();
	}
	static class ASummoned_20020001* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_20020001>();
	}
};
static_assert(alignof(ASummoned_20020001) == 0x000010, "Wrong alignment on ASummoned_20020001");
static_assert(sizeof(ASummoned_20020001) == 0x000830, "Wrong size on ASummoned_20020001");
static_assert(offsetof(ASummoned_20020001, SummonedStaticMesh) == 0x000820, "Member 'ASummoned_20020001::SummonedStaticMesh' has a wrong offset!");

// Class MarvelLevel.TurnOnLevelTimerNode
// 0x0048 (0x0080 - 0x0038)
class UTurnOnLevelTimerNode final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnLoop;                                            // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTurnOnLevelTimerNode* TurnOnLevelTimer(const class UActorComponent* WorldContextObject, const class FString& Name_0, float DelayTime, bool bLooping, float LoopTime);

	void DelayFinish();
	void OnGSEndPlay(class AActor* InSource, EEndPlayReason Reason);
	void RepeatLoopFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurnOnLevelTimerNode">();
	}
	static class UTurnOnLevelTimerNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurnOnLevelTimerNode>();
	}
};
static_assert(alignof(UTurnOnLevelTimerNode) == 0x000008, "Wrong alignment on UTurnOnLevelTimerNode");
static_assert(sizeof(UTurnOnLevelTimerNode) == 0x000080, "Wrong size on UTurnOnLevelTimerNode");
static_assert(offsetof(UTurnOnLevelTimerNode, OnLoop) == 0x000038, "Member 'UTurnOnLevelTimerNode::OnLoop' has a wrong offset!");
static_assert(offsetof(UTurnOnLevelTimerNode, OnCompleted) == 0x000048, "Member 'UTurnOnLevelTimerNode::OnCompleted' has a wrong offset!");

}

