#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1026

#include "Basic.hpp"

#include "GameplayAbilities_structs.hpp"
#include "Hero_1026_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Class Hero_1026.Cue_Ability_Loop_10260101
// 0x00B0 (0x0EB0 - 0x0E00)
class ACue_Ability_Loop_10260101 final : public AMarvelCueNotify_Ability
{
public:
	bool                                          bUseMaxLoopTime;                                   // 0x0E00(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E01[0x3];                                      // 0x0E01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FxMaxLoopTime;                                     // 0x0E04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FxCurrentTime;                                     // 0x0E08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FxAttributeTime;                                   // 0x0E0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0E10(0x0040)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFxMaterialsCurve>              MaterialsCurveArray;                               // 0x0E50(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFxMaterialsCurve>              TimeMaterialsCurveArray;                           // 0x0E60(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinAttributeValue;                                 // 0x0E70(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuffTag;                                           // 0x0E74(0x000C)(Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         MeshCom;                                           // 0x0E80(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E88[0x28];                                     // 0x0E88(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterMeshMaterialChanged();
	void OnDeath(class AActor* InSource, class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnTagUpdate(const struct FGameplayTag& TagUpdated, bool bTagExists);
	void UpdateMaterials(float CurrentValue);
	void UpdateMaterialsForTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10260101">();
	}
	static class ACue_Ability_Loop_10260101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10260101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10260101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10260101");
static_assert(sizeof(ACue_Ability_Loop_10260101) == 0x000EB0, "Wrong size on ACue_Ability_Loop_10260101");
static_assert(offsetof(ACue_Ability_Loop_10260101, bUseMaxLoopTime) == 0x000E00, "Member 'ACue_Ability_Loop_10260101::bUseMaxLoopTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, FxMaxLoopTime) == 0x000E04, "Member 'ACue_Ability_Loop_10260101::FxMaxLoopTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, FxCurrentTime) == 0x000E08, "Member 'ACue_Ability_Loop_10260101::FxCurrentTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, FxAttributeTime) == 0x000E0C, "Member 'ACue_Ability_Loop_10260101::FxAttributeTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, Attribute) == 0x000E10, "Member 'ACue_Ability_Loop_10260101::Attribute' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, MaterialsCurveArray) == 0x000E50, "Member 'ACue_Ability_Loop_10260101::MaterialsCurveArray' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, TimeMaterialsCurveArray) == 0x000E60, "Member 'ACue_Ability_Loop_10260101::TimeMaterialsCurveArray' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, MinAttributeValue) == 0x000E70, "Member 'ACue_Ability_Loop_10260101::MinAttributeValue' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, BuffTag) == 0x000E74, "Member 'ACue_Ability_Loop_10260101::BuffTag' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10260101, MeshCom) == 0x000E80, "Member 'ACue_Ability_Loop_10260101::MeshCom' has a wrong offset!");

// Class Hero_1026.TraceComponent_10261101
// 0x0020 (0x16D0 - 0x16B0)
class UTraceComponent_10261101 final : public UMarvelAgentTraceComponent
{
public:
	struct FVector                                Offset;                                            // 0x16A8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndWhenHeadCollide;                               // 0x16C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C1[0xF];                                     // 0x16C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTraceResult(class UObject* TraceSource, const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10261101">();
	}
	static class UTraceComponent_10261101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10261101>();
	}
};
static_assert(alignof(UTraceComponent_10261101) == 0x000010, "Wrong alignment on UTraceComponent_10261101");
static_assert(sizeof(UTraceComponent_10261101) == 0x0016D0, "Wrong size on UTraceComponent_10261101");
static_assert(offsetof(UTraceComponent_10261101, Offset) == 0x0016A8, "Member 'UTraceComponent_10261101::Offset' has a wrong offset!");
static_assert(offsetof(UTraceComponent_10261101, bEndWhenHeadCollide) == 0x0016C0, "Member 'UTraceComponent_10261101::bEndWhenHeadCollide' has a wrong offset!");

// Class Hero_1026.Ability_102611
// 0x0058 (0x2630 - 0x25D8)
class UAbility_102611 final : public UWallRunningAbility
{
public:
	struct FVector                                HitNormal;                                         // 0x25D8(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25F0[0x1];                                     // 0x25F0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsClimbingZ;                                      // 0x25F1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25F2[0x2];                                     // 0x25F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputXYRate;                                       // 0x25F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25F8[0x4];                                     // 0x25F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedMeshOffset;                                  // 0x25FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeClimbNoSpeed;                               // 0x2600(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValidClimbSpeed;                                // 0x2604(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceStartOffset;                                  // 0x2608(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanActivateLength;                                 // 0x2620(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2624[0x4];                                     // 0x2624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_102612*                        TraceAbility;                                      // 0x2628(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EndClimbing();
	void SetHitNormal(const struct FVector& InNormal);
	void UpdateLastTimeHasValidSpeed();

	bool GetIsValidActivated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102611">();
	}
	static class UAbility_102611* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102611>();
	}
};
static_assert(alignof(UAbility_102611) == 0x000008, "Wrong alignment on UAbility_102611");
static_assert(sizeof(UAbility_102611) == 0x002630, "Wrong size on UAbility_102611");
static_assert(offsetof(UAbility_102611, HitNormal) == 0x0025D8, "Member 'UAbility_102611::HitNormal' has a wrong offset!");
static_assert(offsetof(UAbility_102611, bIsClimbingZ) == 0x0025F1, "Member 'UAbility_102611::bIsClimbingZ' has a wrong offset!");
static_assert(offsetof(UAbility_102611, InputXYRate) == 0x0025F4, "Member 'UAbility_102611::InputXYRate' has a wrong offset!");
static_assert(offsetof(UAbility_102611, CachedMeshOffset) == 0x0025FC, "Member 'UAbility_102611::CachedMeshOffset' has a wrong offset!");
static_assert(offsetof(UAbility_102611, MaxTimeClimbNoSpeed) == 0x002600, "Member 'UAbility_102611::MaxTimeClimbNoSpeed' has a wrong offset!");
static_assert(offsetof(UAbility_102611, MinValidClimbSpeed) == 0x002604, "Member 'UAbility_102611::MinValidClimbSpeed' has a wrong offset!");
static_assert(offsetof(UAbility_102611, TraceStartOffset) == 0x002608, "Member 'UAbility_102611::TraceStartOffset' has a wrong offset!");
static_assert(offsetof(UAbility_102611, CanActivateLength) == 0x002620, "Member 'UAbility_102611::CanActivateLength' has a wrong offset!");
static_assert(offsetof(UAbility_102611, TraceAbility) == 0x002628, "Member 'UAbility_102611::TraceAbility' has a wrong offset!");

// Class Hero_1026.Config_102612
// 0x0030 (0x0110 - 0x00E0)
class UConfig_102612 final : public UWallRunningPassiveAbilityConfig
{
public:
	bool                                          bUseNewMethod;                                     // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawOffset;                                         // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallCheckAngle;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInvalidWallTime;                                // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCrossHorizonAngle;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinClimbWallHeight;                                // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizonExtendAngle;                                // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceWithSphere;                                  // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceSphereRadius;                                 // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceLineLength;                                   // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawHorizonExtend;                                // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawHorizonExtendTime;                             // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102612">();
	}
	static class UConfig_102612* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102612>();
	}
};
static_assert(alignof(UConfig_102612) == 0x000008, "Wrong alignment on UConfig_102612");
static_assert(sizeof(UConfig_102612) == 0x000110, "Wrong size on UConfig_102612");
static_assert(offsetof(UConfig_102612, bUseNewMethod) == 0x0000E0, "Member 'UConfig_102612::bUseNewMethod' has a wrong offset!");
static_assert(offsetof(UConfig_102612, YawOffset) == 0x0000E4, "Member 'UConfig_102612::YawOffset' has a wrong offset!");
static_assert(offsetof(UConfig_102612, WallCheckAngle) == 0x0000E8, "Member 'UConfig_102612::WallCheckAngle' has a wrong offset!");
static_assert(offsetof(UConfig_102612, MaxInvalidWallTime) == 0x0000EC, "Member 'UConfig_102612::MaxInvalidWallTime' has a wrong offset!");
static_assert(offsetof(UConfig_102612, MaxCrossHorizonAngle) == 0x0000F0, "Member 'UConfig_102612::MaxCrossHorizonAngle' has a wrong offset!");
static_assert(offsetof(UConfig_102612, MinClimbWallHeight) == 0x0000F4, "Member 'UConfig_102612::MinClimbWallHeight' has a wrong offset!");
static_assert(offsetof(UConfig_102612, HorizonExtendAngle) == 0x0000F8, "Member 'UConfig_102612::HorizonExtendAngle' has a wrong offset!");
static_assert(offsetof(UConfig_102612, bTraceWithSphere) == 0x0000FC, "Member 'UConfig_102612::bTraceWithSphere' has a wrong offset!");
static_assert(offsetof(UConfig_102612, TraceSphereRadius) == 0x000100, "Member 'UConfig_102612::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UConfig_102612, TraceLineLength) == 0x000104, "Member 'UConfig_102612::TraceLineLength' has a wrong offset!");
static_assert(offsetof(UConfig_102612, bDrawHorizonExtend) == 0x000108, "Member 'UConfig_102612::bDrawHorizonExtend' has a wrong offset!");
static_assert(offsetof(UConfig_102612, DrawHorizonExtendTime) == 0x00010C, "Member 'UConfig_102612::DrawHorizonExtendTime' has a wrong offset!");

// Class Hero_1026.Ability_102612
// 0x0198 (0x2700 - 0x2568)
class UAbility_102612 final : public UWallRunningPassiveAbility
{
public:
	uint8                                         Pad_2568[0x8];                                     // 0x2568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlackPantherMovementComponent*         MoveComp;                                          // 0x2570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbility_102611*                        ClimbAbility;                                      // 0x2578(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTracing;                                        // 0x2580(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasFoundWall;                                     // 0x2581(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSpacePressed;                                   // 0x2582(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWPressed;                                       // 0x2583(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanClimbWall;                                     // 0x2584(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2585[0x17B];                                   // 0x2585(0x017B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndTracing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102612">();
	}
	static class UAbility_102612* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102612>();
	}
};
static_assert(alignof(UAbility_102612) == 0x000008, "Wrong alignment on UAbility_102612");
static_assert(sizeof(UAbility_102612) == 0x002700, "Wrong size on UAbility_102612");
static_assert(offsetof(UAbility_102612, MoveComp) == 0x002570, "Member 'UAbility_102612::MoveComp' has a wrong offset!");
static_assert(offsetof(UAbility_102612, ClimbAbility) == 0x002578, "Member 'UAbility_102612::ClimbAbility' has a wrong offset!");
static_assert(offsetof(UAbility_102612, bIsTracing) == 0x002580, "Member 'UAbility_102612::bIsTracing' has a wrong offset!");
static_assert(offsetof(UAbility_102612, bHasFoundWall) == 0x002581, "Member 'UAbility_102612::bHasFoundWall' has a wrong offset!");
static_assert(offsetof(UAbility_102612, bIsSpacePressed) == 0x002582, "Member 'UAbility_102612::bIsSpacePressed' has a wrong offset!");
static_assert(offsetof(UAbility_102612, bIsWPressed) == 0x002583, "Member 'UAbility_102612::bIsWPressed' has a wrong offset!");
static_assert(offsetof(UAbility_102612, bCanClimbWall) == 0x002584, "Member 'UAbility_102612::bCanClimbWall' has a wrong offset!");

// Class Hero_1026.Ability_102613
// 0x0008 (0x2650 - 0x2648)
class UAbility_102613 : public UMarvelAbility_DoubleJump
{
public:
	uint8                                         Pad_2648[0x8];                                     // 0x2648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102613">();
	}
	static class UAbility_102613* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102613>();
	}
};
static_assert(alignof(UAbility_102613) == 0x000008, "Wrong alignment on UAbility_102613");
static_assert(sizeof(UAbility_102613) == 0x002650, "Wrong size on UAbility_102613");

// Class Hero_1026.Config_102641
// 0x0B88 (0x0C20 - 0x0098)
class UConfig_102641 : public UMarvelAbilityConfig
{
public:
	struct FDashAbilityInfo                       DashInfo;                                          // 0x0098(0x0B70)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MinAbilityLoopTime;                                // 0x0C08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndAbilityWhenHit;                                // 0x0C0C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0D[0x3];                                      // 0x0C0D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rate;                                              // 0x0C10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetAnimRootMotionTranslationScale;                // 0x0C14(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C15[0x3];                                      // 0x0C15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractiveAbilityCooldown;                        // 0x0C18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1C[0x4];                                      // 0x0C1C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102641">();
	}
	static class UConfig_102641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102641>();
	}
};
static_assert(alignof(UConfig_102641) == 0x000008, "Wrong alignment on UConfig_102641");
static_assert(sizeof(UConfig_102641) == 0x000C20, "Wrong size on UConfig_102641");
static_assert(offsetof(UConfig_102641, DashInfo) == 0x000098, "Member 'UConfig_102641::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_102641, MinAbilityLoopTime) == 0x000C08, "Member 'UConfig_102641::MinAbilityLoopTime' has a wrong offset!");
static_assert(offsetof(UConfig_102641, bEndAbilityWhenHit) == 0x000C0C, "Member 'UConfig_102641::bEndAbilityWhenHit' has a wrong offset!");
static_assert(offsetof(UConfig_102641, Rate) == 0x000C10, "Member 'UConfig_102641::Rate' has a wrong offset!");
static_assert(offsetof(UConfig_102641, bSetAnimRootMotionTranslationScale) == 0x000C14, "Member 'UConfig_102641::bSetAnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UConfig_102641, InteractiveAbilityCooldown) == 0x000C18, "Member 'UConfig_102641::InteractiveAbilityCooldown' has a wrong offset!");

// Class Hero_1026.Ability_102641
// 0x0070 (0x25C0 - 0x2550)
class UAbility_102641 : public UMarvelGameplayAbility
{
public:
	struct FTimerHandle                           TimerHandle;                                       // 0x2550(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           EndAbilityHandle;                                  // 0x2568(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2580[0x10];                                    // 0x2580(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* PlayTimelineTask;                                  // 0x2590(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_Dash*                DashTask;                                          // 0x2598(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A0[0x20];                                    // 0x25A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckDashTaskValidWhenBreak();
	void EndLimitCameraTask();
	void MyActiveAbility();
	void MyEndAbility();
	void OnAbilityHit(class UGameplayAbility* InAbility, const struct FMarvelAbilityHitParams& HitParams, const TArray<struct FHitResult>& HitResults);
	void OnDashTaskFinished(EDashStopReason Reason);
	void OnTimerSuccess();
	void OnTranslatedByPortal(class APortalViewActor* Portal);
	void OnTranslatedByPortalTimer();
	void StartLimitCameraTask(float TimeSeconds, const struct FRotator& TargetRotator);
	void TickUpdateCameraLimitation(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102641">();
	}
	static class UAbility_102641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102641>();
	}
};
static_assert(alignof(UAbility_102641) == 0x000008, "Wrong alignment on UAbility_102641");
static_assert(sizeof(UAbility_102641) == 0x0025C0, "Wrong size on UAbility_102641");
static_assert(offsetof(UAbility_102641, TimerHandle) == 0x002550, "Member 'UAbility_102641::TimerHandle' has a wrong offset!");
static_assert(offsetof(UAbility_102641, EndAbilityHandle) == 0x002568, "Member 'UAbility_102641::EndAbilityHandle' has a wrong offset!");
static_assert(offsetof(UAbility_102641, PlayTimelineTask) == 0x002590, "Member 'UAbility_102641::PlayTimelineTask' has a wrong offset!");
static_assert(offsetof(UAbility_102641, DashTask) == 0x002598, "Member 'UAbility_102641::DashTask' has a wrong offset!");

// Class Hero_1026.Cue_Ability_Loop_10265101
// 0x0028 (0x0E28 - 0x0E00)
class ACue_Ability_Loop_10265101 final : public AMarvelCueNotify_Ability
{
public:
	float                                         SpearHorizonRotationOffset;                        // 0x0E00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpearVerticalRotationOffset;                       // 0x0E04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugLine;                                        // 0x0E08(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E09[0x3];                                      // 0x0E09(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RHandName;                                         // 0x0E0C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0E18(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0E20(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10265101">();
	}
	static class ACue_Ability_Loop_10265101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10265101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10265101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10265101");
static_assert(sizeof(ACue_Ability_Loop_10265101) == 0x000E28, "Wrong size on ACue_Ability_Loop_10265101");
static_assert(offsetof(ACue_Ability_Loop_10265101, SpearHorizonRotationOffset) == 0x000E00, "Member 'ACue_Ability_Loop_10265101::SpearHorizonRotationOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10265101, SpearVerticalRotationOffset) == 0x000E04, "Member 'ACue_Ability_Loop_10265101::SpearVerticalRotationOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10265101, bDebugLine) == 0x000E08, "Member 'ACue_Ability_Loop_10265101::bDebugLine' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10265101, RHandName) == 0x000E0C, "Member 'ACue_Ability_Loop_10265101::RHandName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10265101, OwnerCharacter) == 0x000E18, "Member 'ACue_Ability_Loop_10265101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10265101, Mesh) == 0x000E20, "Member 'ACue_Ability_Loop_10265101::Mesh' has a wrong offset!");

// Class Hero_1026.Config_102661
// 0x0000 (0x0098 - 0x0098)
class UConfig_102661 : public UMarvelAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102661">();
	}
	static class UConfig_102661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102661>();
	}
};
static_assert(alignof(UConfig_102661) == 0x000008, "Wrong alignment on UConfig_102661");
static_assert(sizeof(UConfig_102661) == 0x000098, "Wrong size on UConfig_102661");

// Class Hero_1026.Ability_102661
// 0x0030 (0x2588 - 0x2558)
class UAbility_102661 : public UAbility_108
{
public:
	ERush_State_102661                            CurrentStat;                                       // 0x2558(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2559[0x3];                                     // 0x2559(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopCount;                                         // 0x255C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDashFinish;                                     // 0x2560(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2561[0x7];                                     // 0x2561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStateChangeDelegate;                             // 0x2568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddedShield;                                     // 0x2578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	ERush_State_102661 GetCurrentStart();
	void OnRep_CurrentStat();
	void SetCurrentStat(ERush_State_102661 NewStat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102661">();
	}
	static class UAbility_102661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102661>();
	}
};
static_assert(alignof(UAbility_102661) == 0x000008, "Wrong alignment on UAbility_102661");
static_assert(sizeof(UAbility_102661) == 0x002588, "Wrong size on UAbility_102661");
static_assert(offsetof(UAbility_102661, CurrentStat) == 0x002558, "Member 'UAbility_102661::CurrentStat' has a wrong offset!");
static_assert(offsetof(UAbility_102661, LoopCount) == 0x00255C, "Member 'UAbility_102661::LoopCount' has a wrong offset!");
static_assert(offsetof(UAbility_102661, bIsDashFinish) == 0x002560, "Member 'UAbility_102661::bIsDashFinish' has a wrong offset!");
static_assert(offsetof(UAbility_102661, OnStateChangeDelegate) == 0x002568, "Member 'UAbility_102661::OnStateChangeDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_102661, OnAddedShield) == 0x002578, "Member 'UAbility_102661::OnAddedShield' has a wrong offset!");

// Class Hero_1026.Config_102671
// 0x0000 (0x0098 - 0x0098)
class UConfig_102671 final : public UMarvelAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102671">();
	}
	static class UConfig_102671* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102671>();
	}
};
static_assert(alignof(UConfig_102671) == 0x000008, "Wrong alignment on UConfig_102671");
static_assert(sizeof(UConfig_102671) == 0x000098, "Wrong size on UConfig_102671");

// Class Hero_1026.Ability_102671
// 0x0000 (0x2550 - 0x2550)
class UAbility_102671 : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102671">();
	}
	static class UAbility_102671* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102671>();
	}
};
static_assert(alignof(UAbility_102671) == 0x000008, "Wrong alignment on UAbility_102671");
static_assert(sizeof(UAbility_102671) == 0x002550, "Wrong size on UAbility_102671");

// Class Hero_1026.Summoner_10267101
// 0x0000 (0x0800 - 0x0800)
class ASummoner_10267101 : public AMarvelSummonerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoner_10267101">();
	}
	static class ASummoner_10267101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoner_10267101>();
	}
};
static_assert(alignof(ASummoner_10267101) == 0x000010, "Wrong alignment on ASummoner_10267101");
static_assert(sizeof(ASummoner_10267101) == 0x000800, "Wrong size on ASummoner_10267101");

// Class Hero_1026.SummonedComp_10267101
// 0x0000 (0x0C90 - 0x0C90)
class USummonedComp_10267101 : public UMarvelSummonedComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10267101">();
	}
	static class USummonedComp_10267101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10267101>();
	}
};
static_assert(alignof(USummonedComp_10267101) == 0x000010, "Wrong alignment on USummonedComp_10267101");
static_assert(sizeof(USummonedComp_10267101) == 0x000C90, "Wrong size on USummonedComp_10267101");

// Class Hero_1026.Cue_Ability_Loop_10267101
// 0x0008 (0x0E08 - 0x0E00)
class ACue_Ability_Loop_10267101 : public AMarvelCueNotify_Ability
{
public:
	class AMarvelBaseCharacter*                   MyCharacter;                                       // 0x0E00(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10267101">();
	}
	static class ACue_Ability_Loop_10267101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10267101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10267101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10267101");
static_assert(sizeof(ACue_Ability_Loop_10267101) == 0x000E08, "Wrong size on ACue_Ability_Loop_10267101");
static_assert(offsetof(ACue_Ability_Loop_10267101, MyCharacter) == 0x000E00, "Member 'ACue_Ability_Loop_10267101::MyCharacter' has a wrong offset!");

// Class Hero_1026.Cue_Ability_Loop_10267102
// 0x0038 (0x0E38 - 0x0E00)
class ACue_Ability_Loop_10267102 final : public AMarvelCueNotify_Ability
{
public:
	TArray<struct FFxMaterialsCurve>              TimeMaterialsCurveArray;                           // 0x0E00(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDecalComponent*>                DecalComps;                                        // 0x0E10(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       MaterialInstances;                                 // 0x0E20(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E30[0x8];                                      // 0x0E30(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10267102">();
	}
	static class ACue_Ability_Loop_10267102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10267102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10267102) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10267102");
static_assert(sizeof(ACue_Ability_Loop_10267102) == 0x000E38, "Wrong size on ACue_Ability_Loop_10267102");
static_assert(offsetof(ACue_Ability_Loop_10267102, TimeMaterialsCurveArray) == 0x000E00, "Member 'ACue_Ability_Loop_10267102::TimeMaterialsCurveArray' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10267102, DecalComps) == 0x000E10, "Member 'ACue_Ability_Loop_10267102::DecalComps' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10267102, MaterialInstances) == 0x000E20, "Member 'ACue_Ability_Loop_10267102::MaterialInstances' has a wrong offset!");

// Class Hero_1026.BlackPantherAnimInstance
// 0x0050 (0x0950 - 0x0900)
class UBlackPantherAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          UseAO;                                             // 0x0900(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoubleJump;                                     // 0x0901(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_902[0x2];                                      // 0x0902(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentAngle;                                      // 0x0904(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterShift;                                       // 0x0908(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExitShift;                                        // 0x0909(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipEndState;                                     // 0x090A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90B[0x45];                                     // 0x090B(0x0045)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStateChanged(ERush_State_102661 CurrentStat);
	void OnTagUpdated(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackPantherAnimInstance">();
	}
	static class UBlackPantherAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackPantherAnimInstance>();
	}
};
static_assert(alignof(UBlackPantherAnimInstance) == 0x000010, "Wrong alignment on UBlackPantherAnimInstance");
static_assert(sizeof(UBlackPantherAnimInstance) == 0x000950, "Wrong size on UBlackPantherAnimInstance");
static_assert(offsetof(UBlackPantherAnimInstance, UseAO) == 0x000900, "Member 'UBlackPantherAnimInstance::UseAO' has a wrong offset!");
static_assert(offsetof(UBlackPantherAnimInstance, bIsDoubleJump) == 0x000901, "Member 'UBlackPantherAnimInstance::bIsDoubleJump' has a wrong offset!");
static_assert(offsetof(UBlackPantherAnimInstance, CurrentAngle) == 0x000904, "Member 'UBlackPantherAnimInstance::CurrentAngle' has a wrong offset!");
static_assert(offsetof(UBlackPantherAnimInstance, bEnterShift) == 0x000908, "Member 'UBlackPantherAnimInstance::bEnterShift' has a wrong offset!");
static_assert(offsetof(UBlackPantherAnimInstance, bExitShift) == 0x000909, "Member 'UBlackPantherAnimInstance::bExitShift' has a wrong offset!");
static_assert(offsetof(UBlackPantherAnimInstance, bSkipEndState) == 0x00090A, "Member 'UBlackPantherAnimInstance::bSkipEndState' has a wrong offset!");

// Class Hero_1026.BlackPantherCharacter
// 0x0000 (0x17C0 - 0x17C0)
class ABlackPantherCharacter : public AMarvelBaseCharacter
{
public:
	class UBlackPantherMoveLogicBaseComponent*    BlackPantherMoveLogic;                             // 0x17B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackPantherCharacter">();
	}
	static class ABlackPantherCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlackPantherCharacter>();
	}
};
static_assert(alignof(ABlackPantherCharacter) == 0x000010, "Wrong alignment on ABlackPantherCharacter");
static_assert(sizeof(ABlackPantherCharacter) == 0x0017C0, "Wrong size on ABlackPantherCharacter");
static_assert(offsetof(ABlackPantherCharacter, BlackPantherMoveLogic) == 0x0017B8, "Member 'ABlackPantherCharacter::BlackPantherMoveLogic' has a wrong offset!");

// Class Hero_1026.BlackPantherChildActor
// 0x0010 (0x0A50 - 0x0A40)
class ABlackPantherChildActor final : public AMarvelCharacterChildActor
{
public:
	float                                         DelayLengthToRotateMesh;                           // 0x0A40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A44[0xC];                                      // 0x0A44(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackPantherChildActor">();
	}
	static class ABlackPantherChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlackPantherChildActor>();
	}
};
static_assert(alignof(ABlackPantherChildActor) == 0x000008, "Wrong alignment on ABlackPantherChildActor");
static_assert(sizeof(ABlackPantherChildActor) == 0x000A50, "Wrong size on ABlackPantherChildActor");
static_assert(offsetof(ABlackPantherChildActor, DelayLengthToRotateMesh) == 0x000A40, "Member 'ABlackPantherChildActor::DelayLengthToRotateMesh' has a wrong offset!");

// Class Hero_1026.BlackPantherMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UBlackPantherMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackPantherMoveLogicBaseComponent">();
	}
	static class UBlackPantherMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackPantherMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UBlackPantherMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UBlackPantherMoveLogicBaseComponent");
static_assert(sizeof(UBlackPantherMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UBlackPantherMoveLogicBaseComponent");

// Class Hero_1026.BlackPantherMovementComponent
// 0x0000 (0x2EE0 - 0x2EE0)
class UBlackPantherMovementComponent final : public UCharacterWallRunningComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackPantherMovementComponent">();
	}
	static class UBlackPantherMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackPantherMovementComponent>();
	}
};
static_assert(alignof(UBlackPantherMovementComponent) == 0x000010, "Wrong alignment on UBlackPantherMovementComponent");
static_assert(sizeof(UBlackPantherMovementComponent) == 0x002EE0, "Wrong size on UBlackPantherMovementComponent");

// Class Hero_1026.TabData_1026
// 0x0000 (0x0050 - 0x0050)
class UTabData_1026 final : public UHeroTabDataBase
{
public:
	void OnAbilityInitialize(int32 AbilityID);
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnShieldAdded(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1026">();
	}
	static class UTabData_1026* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1026>();
	}
};
static_assert(alignof(UTabData_1026) == 0x000008, "Wrong alignment on UTabData_1026");
static_assert(sizeof(UTabData_1026) == 0x000050, "Wrong size on UTabData_1026");

}

