#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_Synergy

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Hero_Synergy_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_Synergy.Cue_Scope_Loop_100005
// 0x0008 (0x0D28 - 0x0D20)
class ACue_Scope_Loop_100005 final : public AMarvelCueNotify_Scope
{
public:
	bool                                          bBeSeenThroughNiagara;                             // 0x0D20(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D21[0x7];                                      // 0x0D21(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_100005">();
	}
	static class ACue_Scope_Loop_100005* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_100005>();
	}
};
static_assert(alignof(ACue_Scope_Loop_100005) == 0x000008, "Wrong alignment on ACue_Scope_Loop_100005");
static_assert(sizeof(ACue_Scope_Loop_100005) == 0x000D28, "Wrong size on ACue_Scope_Loop_100005");
static_assert(offsetof(ACue_Scope_Loop_100005, bBeSeenThroughNiagara) == 0x000D20, "Member 'ACue_Scope_Loop_100005::bBeSeenThroughNiagara' has a wrong offset!");

// Class Hero_Synergy.MarvelBackTrackConfig
// 0x1F08 (0x1FA0 - 0x0098)
class UMarvelBackTrackConfig final : public UMarvelAbilityConfig
{
public:
	bool                                          bHoldBackTrackSwitch;                              // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecordInterval;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRecordDistance;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTrackTime;                                     // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTrackTotalTime;                                // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTrackInterpSpeed;                              // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreFillDistance;                                   // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BackTrackTags;                                     // 0x00B8(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EMovementMode                                 BackTrackMoveMode;                                 // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BackTrackEndSectionName;                           // 0x0124(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             ReachTestTraceContext;                             // 0x0130(0x0F30)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             LandTestTraceContext;                              // 0x1060(0x0F30)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bApplyShieldBuff;                                  // 0x1F90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F91[0x3];                                     // 0x1F91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NotTreatShieldBuff;                                // 0x1F94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InjuryToShieldRatio;                               // 0x1F98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugDrawTime;                                     // 0x1F9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelBackTrackConfig">();
	}
	static class UMarvelBackTrackConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelBackTrackConfig>();
	}
};
static_assert(alignof(UMarvelBackTrackConfig) == 0x000010, "Wrong alignment on UMarvelBackTrackConfig");
static_assert(sizeof(UMarvelBackTrackConfig) == 0x001FA0, "Wrong size on UMarvelBackTrackConfig");
static_assert(offsetof(UMarvelBackTrackConfig, bHoldBackTrackSwitch) == 0x000098, "Member 'UMarvelBackTrackConfig::bHoldBackTrackSwitch' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, RecordInterval) == 0x00009C, "Member 'UMarvelBackTrackConfig::RecordInterval' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, MinRecordDistance) == 0x0000A0, "Member 'UMarvelBackTrackConfig::MinRecordDistance' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackTime) == 0x0000A4, "Member 'UMarvelBackTrackConfig::BackTrackTime' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackTotalTime) == 0x0000A8, "Member 'UMarvelBackTrackConfig::BackTrackTotalTime' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackInterpSpeed) == 0x0000AC, "Member 'UMarvelBackTrackConfig::BackTrackInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, PreFillDistance) == 0x0000B0, "Member 'UMarvelBackTrackConfig::PreFillDistance' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackTags) == 0x0000B8, "Member 'UMarvelBackTrackConfig::BackTrackTags' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackMoveMode) == 0x000120, "Member 'UMarvelBackTrackConfig::BackTrackMoveMode' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, BackTrackEndSectionName) == 0x000124, "Member 'UMarvelBackTrackConfig::BackTrackEndSectionName' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, ReachTestTraceContext) == 0x000130, "Member 'UMarvelBackTrackConfig::ReachTestTraceContext' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, LandTestTraceContext) == 0x001060, "Member 'UMarvelBackTrackConfig::LandTestTraceContext' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, bApplyShieldBuff) == 0x001F90, "Member 'UMarvelBackTrackConfig::bApplyShieldBuff' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, NotTreatShieldBuff) == 0x001F94, "Member 'UMarvelBackTrackConfig::NotTreatShieldBuff' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, InjuryToShieldRatio) == 0x001F98, "Member 'UMarvelBackTrackConfig::InjuryToShieldRatio' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackConfig, DebugDrawTime) == 0x001F9C, "Member 'UMarvelBackTrackConfig::DebugDrawTime' has a wrong offset!");

// Class Hero_Synergy.MarvelBackTrackAbility
// 0x00C0 (0x2618 - 0x2558)
class UMarvelBackTrackAbility : public UAbility_108
{
public:
	TArray<struct FBackTrackContext>              PathDatas;                                         // 0x2558(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	double                                        BackTrackStartTime;                                // 0x2568(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelBackTrackConfig*                 BackTrackConfig;                                   // 0x2570(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   TargetCharacter;                                   // 0x2578(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           RecordStateTimer;                                  // 0x2580(0x0018)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 CacheMovementMode;                                 // 0x2598(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2599[0x7];                                     // 0x2599(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_WaitLongPressRelease* WaitLongPressReleaseTask;                          // 0x25A0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBackTracking;                                   // 0x25A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A9[0x3];                                     // 0x25A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartPointIdx;                                     // 0x25AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StopPointIdx;                                      // 0x25B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PathPointNum;                                      // 0x25B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OutTime;                                           // 0x25B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateTimeCount;                                   // 0x25BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRecording;                                        // 0x25C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInterruptEnd;                                     // 0x25C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C2[0x6];                                     // 0x25C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MinPos;                                            // 0x25C8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MaxPos;                                            // 0x25E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DelayStartRecordHandle;                            // 0x25F8(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2610[0x8];                                     // 0x2610(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayStartRecord(bool bSetDelay);
	bool IsHoldMode();
	void MulticastInterrupt();
	void OnCharacterMovementPreUpdated(float DeltaTime);
	void OnCharTranslatedByPortal(class APortalViewActor* InPortalActor);
	void OnClientAckMoveWithStamp(const float Timestamp, const struct FVector& Location);
	void OnLivingStateChanged(EPlayerLivingState LivingState);
	void OnLongPressRelease(float TimeHeld);
	void OnLongPressTimeOverMaxHoldTime(float TimeHeld);
	void OnServerHandleClientMoveWithStamp(const float Timestamp, const struct FVector& Location);
	void RecordState(const float Timestamp, const struct FVector& Location);
	bool ServerCheckClientLocValid(const struct FVector& InTargetLoc, bool bStrictCheck);
	void ServerInterrupt(const struct FVector& InClientLocation);
	void StartBackTrack();
	void StartRecordState();
	void StopBackTrack();
	void StopRecordState(bool bClearData);

	bool SafeMoveTo(const struct FVector& TargetLoc, struct FHitResult* OutHit, bool bSweep) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelBackTrackAbility">();
	}
	static class UMarvelBackTrackAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelBackTrackAbility>();
	}
};
static_assert(alignof(UMarvelBackTrackAbility) == 0x000008, "Wrong alignment on UMarvelBackTrackAbility");
static_assert(sizeof(UMarvelBackTrackAbility) == 0x002618, "Wrong size on UMarvelBackTrackAbility");
static_assert(offsetof(UMarvelBackTrackAbility, PathDatas) == 0x002558, "Member 'UMarvelBackTrackAbility::PathDatas' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, BackTrackStartTime) == 0x002568, "Member 'UMarvelBackTrackAbility::BackTrackStartTime' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, BackTrackConfig) == 0x002570, "Member 'UMarvelBackTrackAbility::BackTrackConfig' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, TargetCharacter) == 0x002578, "Member 'UMarvelBackTrackAbility::TargetCharacter' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, RecordStateTimer) == 0x002580, "Member 'UMarvelBackTrackAbility::RecordStateTimer' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, CacheMovementMode) == 0x002598, "Member 'UMarvelBackTrackAbility::CacheMovementMode' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, WaitLongPressReleaseTask) == 0x0025A0, "Member 'UMarvelBackTrackAbility::WaitLongPressReleaseTask' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, bIsBackTracking) == 0x0025A8, "Member 'UMarvelBackTrackAbility::bIsBackTracking' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, StartPointIdx) == 0x0025AC, "Member 'UMarvelBackTrackAbility::StartPointIdx' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, StopPointIdx) == 0x0025B0, "Member 'UMarvelBackTrackAbility::StopPointIdx' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, PathPointNum) == 0x0025B4, "Member 'UMarvelBackTrackAbility::PathPointNum' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, OutTime) == 0x0025B8, "Member 'UMarvelBackTrackAbility::OutTime' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, UpdateTimeCount) == 0x0025BC, "Member 'UMarvelBackTrackAbility::UpdateTimeCount' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, bRecording) == 0x0025C0, "Member 'UMarvelBackTrackAbility::bRecording' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, bInterruptEnd) == 0x0025C1, "Member 'UMarvelBackTrackAbility::bInterruptEnd' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, MinPos) == 0x0025C8, "Member 'UMarvelBackTrackAbility::MinPos' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, MaxPos) == 0x0025E0, "Member 'UMarvelBackTrackAbility::MaxPos' has a wrong offset!");
static_assert(offsetof(UMarvelBackTrackAbility, DelayStartRecordHandle) == 0x0025F8, "Member 'UMarvelBackTrackAbility::DelayStartRecordHandle' has a wrong offset!");

// Class Hero_Synergy.TraceComponent_100009
// 0x0050 (0x1700 - 0x16B0)
class UTraceComponent_100009 : public UMarvelAgentTraceComponent
{
public:
	TMap<int32, struct FGameplayTagContainer>     BondRequireTags;                                   // 0x16A8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F8[0x8];                                     // 0x16F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnPreOutTraceResults(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_100009">();
	}
	static class UTraceComponent_100009* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_100009>();
	}
};
static_assert(alignof(UTraceComponent_100009) == 0x000010, "Wrong alignment on UTraceComponent_100009");
static_assert(sizeof(UTraceComponent_100009) == 0x001700, "Wrong size on UTraceComponent_100009");
static_assert(offsetof(UTraceComponent_100009, BondRequireTags) == 0x0016A8, "Member 'UTraceComponent_100009::BondRequireTags' has a wrong offset!");

// Class Hero_Synergy.BuffManagerAbility_100009
// 0x01E8 (0x12D0 - 0x10E8)
class UBuffManagerAbility_100009 : public UMarvelEffectGameplayAbility
{
public:
	int32                                         ManagedBuffID;                                     // 0x10E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBindToDamage;                                     // 0x10EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBindToDebuff;                                     // 0x10ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10EE[0x2];                                     // 0x10EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               DebuffTagRequirements;                             // 0x10F0(0x0118)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bBindToAbilities;                                  // 0x1208(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1209[0x7];                                     // 0x1209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BindToAbilitiseTags;                               // 0x1210(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bBindToCollide;                                    // 0x1278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestoreBuff;                                      // 0x1279(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_127A[0x2];                                     // 0x127A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RestoreBuffDelay;                                  // 0x127C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1280[0x50];                                    // 0x1280(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityActivate(int32 AbilityID);
	void OnAbilityEnded(int32 AbilityID);
	void OnBuffExecuted(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle);
	void OnBuffRemoved(const struct FGameplayEffectSpec& RemovedSpec, bool bPrematureRemoval);
	void OnOwnerCollide(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnOwnerTakeDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void RemoveBuffFromSelf();
	void RestoreBuffToSelfWithDelay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffManagerAbility_100009">();
	}
	static class UBuffManagerAbility_100009* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffManagerAbility_100009>();
	}
};
static_assert(alignof(UBuffManagerAbility_100009) == 0x000008, "Wrong alignment on UBuffManagerAbility_100009");
static_assert(sizeof(UBuffManagerAbility_100009) == 0x0012D0, "Wrong size on UBuffManagerAbility_100009");
static_assert(offsetof(UBuffManagerAbility_100009, ManagedBuffID) == 0x0010E8, "Member 'UBuffManagerAbility_100009::ManagedBuffID' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, bBindToDamage) == 0x0010EC, "Member 'UBuffManagerAbility_100009::bBindToDamage' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, bBindToDebuff) == 0x0010ED, "Member 'UBuffManagerAbility_100009::bBindToDebuff' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, DebuffTagRequirements) == 0x0010F0, "Member 'UBuffManagerAbility_100009::DebuffTagRequirements' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, bBindToAbilities) == 0x001208, "Member 'UBuffManagerAbility_100009::bBindToAbilities' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, BindToAbilitiseTags) == 0x001210, "Member 'UBuffManagerAbility_100009::BindToAbilitiseTags' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, bBindToCollide) == 0x001278, "Member 'UBuffManagerAbility_100009::bBindToCollide' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, bRestoreBuff) == 0x001279, "Member 'UBuffManagerAbility_100009::bRestoreBuff' has a wrong offset!");
static_assert(offsetof(UBuffManagerAbility_100009, RestoreBuffDelay) == 0x00127C, "Member 'UBuffManagerAbility_100009::RestoreBuffDelay' has a wrong offset!");

// Class Hero_Synergy.Config_100015
// 0x0160 (0x1330 - 0x11D0)
#pragma pack(push, 0x1)
class alignas(0x10) UConfig_100015 : public UMarvelSelectTargetConfig
{
public:
	TMap<int32, int32>                            BondIDMap;                                         // 0x11C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         WavingBuffID;                                      // 0x1218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WavingHoldTime;                                    // 0x121C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockAbilityTags;                                  // 0x1220(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CancelAbilityTags;                                 // 0x1288(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bOptimizeGameStateFindTarget;                      // 0x12F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12F1[0x3];                                     // 0x12F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetFilterDistance;                              // 0x12F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalEndCD;                                       // 0x12F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchEndCD;                                       // 0x12FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateChangedTaskParam                 ExitRideInputSetting;                              // 0x1300(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_100015">();
	}
	static class UConfig_100015* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_100015>();
	}
};
#pragma pack(pop)
static_assert(alignof(UConfig_100015) == 0x000010, "Wrong alignment on UConfig_100015");
static_assert(sizeof(UConfig_100015) == 0x001330, "Wrong size on UConfig_100015");
static_assert(offsetof(UConfig_100015, BondIDMap) == 0x0011C8, "Member 'UConfig_100015::BondIDMap' has a wrong offset!");
static_assert(offsetof(UConfig_100015, WavingBuffID) == 0x001218, "Member 'UConfig_100015::WavingBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_100015, WavingHoldTime) == 0x00121C, "Member 'UConfig_100015::WavingHoldTime' has a wrong offset!");
static_assert(offsetof(UConfig_100015, BlockAbilityTags) == 0x001220, "Member 'UConfig_100015::BlockAbilityTags' has a wrong offset!");
static_assert(offsetof(UConfig_100015, CancelAbilityTags) == 0x001288, "Member 'UConfig_100015::CancelAbilityTags' has a wrong offset!");
static_assert(offsetof(UConfig_100015, bOptimizeGameStateFindTarget) == 0x0012F0, "Member 'UConfig_100015::bOptimizeGameStateFindTarget' has a wrong offset!");
static_assert(offsetof(UConfig_100015, TargetFilterDistance) == 0x0012F4, "Member 'UConfig_100015::TargetFilterDistance' has a wrong offset!");
static_assert(offsetof(UConfig_100015, NormalEndCD) == 0x0012F8, "Member 'UConfig_100015::NormalEndCD' has a wrong offset!");
static_assert(offsetof(UConfig_100015, LaunchEndCD) == 0x0012FC, "Member 'UConfig_100015::LaunchEndCD' has a wrong offset!");
static_assert(offsetof(UConfig_100015, ExitRideInputSetting) == 0x001300, "Member 'UConfig_100015::ExitRideInputSetting' has a wrong offset!");

// Class Hero_Synergy.Ability_100015
// 0x0438 (0x2B48 - 0x2710)
class UAbility_100015 : public UMarvelSelectTargetAbility
{
public:
	class AMarvelGameState*                       CurrentGameState;                                  // 0x2710(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwningCharacter;                                   // 0x2718(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_100015*                         CoopConfig;                                        // 0x2720(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   WavingCharacter;                                   // 0x2728(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   ConfirmedCharacter;                                // 0x2730(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWavingStateChanged;                              // 0x2738(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FSynergyWavingData                     WavingData;                                        // 0x2748(0x02C8)(BlueprintVisible, Net, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	ESynergyWavingState                           CurrentWavingState;                                // 0x2A10(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A11[0x7];                                     // 0x2A11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   TraceHeroIDSet;                                    // 0x2A18(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           WavingHoldTimer;                                   // 0x2A68(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConfirmed;                                        // 0x2A80(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A81[0x7];                                     // 0x2A81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_WaitInputStateChanged* RideCancelTask;                                    // 0x2A88(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         RideCancelKey;                                     // 0x2A90(0x00A0)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B30[0x18];                                    // 0x2B30(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddWavingData(const struct FHitResult& InHitResult);
	void BindCancelRideInput();
	void CancelRelevantSynergyAbility(bool bNormalEnd);
	void ClearWavingHoldTimer();
	void CustomCommitSynergyCoolDown(bool bNormalEnd);
	struct FPortalSegments GetDashPortalSegments();
	class UAbility_100015* GetRelevantSynergyAbility(class AMarvelBaseCharacter* InCharacter);
	bool HasActiveBond();
	bool IsAbilityNormalEnd();
	void K2_OnStartWaving();
	void K2_OnWavingConfirmed();
	void K2_OnWavingTimeOut();
	void OnCoopAbilityTickStateChanged(bool bShouldAbilityTick);
	void OnOwnerGameplayTagUpdate(const struct FGameplayTag& InTag, bool bTagExists);
	void OnRep_ConfirmedCharacter();
	void OnRep_CurrentWavingState();
	void OnRep_WavingData();
	void OnRideCancel(float StateIntervalTime);
	void Python_OnRideCancel();
	void SetCurrentWavingCharacter(const class AActor* TargetActor);
	void SetWavingConfirmedByCharacter(class AMarvelBaseCharacter* InCharacter);
	void SetWavingState(ESynergyWavingState InNewState);

	ESynergyWavingState GetWavingState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_100015">();
	}
	static class UAbility_100015* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_100015>();
	}
};
static_assert(alignof(UAbility_100015) == 0x000008, "Wrong alignment on UAbility_100015");
static_assert(sizeof(UAbility_100015) == 0x002B48, "Wrong size on UAbility_100015");
static_assert(offsetof(UAbility_100015, CurrentGameState) == 0x002710, "Member 'UAbility_100015::CurrentGameState' has a wrong offset!");
static_assert(offsetof(UAbility_100015, OwningCharacter) == 0x002718, "Member 'UAbility_100015::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_100015, CoopConfig) == 0x002720, "Member 'UAbility_100015::CoopConfig' has a wrong offset!");
static_assert(offsetof(UAbility_100015, WavingCharacter) == 0x002728, "Member 'UAbility_100015::WavingCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_100015, ConfirmedCharacter) == 0x002730, "Member 'UAbility_100015::ConfirmedCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_100015, OnWavingStateChanged) == 0x002738, "Member 'UAbility_100015::OnWavingStateChanged' has a wrong offset!");
static_assert(offsetof(UAbility_100015, WavingData) == 0x002748, "Member 'UAbility_100015::WavingData' has a wrong offset!");
static_assert(offsetof(UAbility_100015, CurrentWavingState) == 0x002A10, "Member 'UAbility_100015::CurrentWavingState' has a wrong offset!");
static_assert(offsetof(UAbility_100015, TraceHeroIDSet) == 0x002A18, "Member 'UAbility_100015::TraceHeroIDSet' has a wrong offset!");
static_assert(offsetof(UAbility_100015, WavingHoldTimer) == 0x002A68, "Member 'UAbility_100015::WavingHoldTimer' has a wrong offset!");
static_assert(offsetof(UAbility_100015, bConfirmed) == 0x002A80, "Member 'UAbility_100015::bConfirmed' has a wrong offset!");
static_assert(offsetof(UAbility_100015, RideCancelTask) == 0x002A88, "Member 'UAbility_100015::RideCancelTask' has a wrong offset!");
static_assert(offsetof(UAbility_100015, RideCancelKey) == 0x002A90, "Member 'UAbility_100015::RideCancelKey' has a wrong offset!");

// Class Hero_Synergy.UIC_SelectTarget_100015
// 0x00B8 (0x0210 - 0x0158)
class UUIC_SelectTarget_100015 final : public UUIC_SelectTarget
{
public:
	struct FUIActionData                          WaveActionData;                                    // 0x0158(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUIActionData                          ConfirmActionData;                                 // 0x01B0(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAbility_100015*                        OwningAbility;                                     // 0x0208(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIC_SelectTarget_100015">();
	}
	static class UUIC_SelectTarget_100015* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIC_SelectTarget_100015>();
	}
};
static_assert(alignof(UUIC_SelectTarget_100015) == 0x000008, "Wrong alignment on UUIC_SelectTarget_100015");
static_assert(sizeof(UUIC_SelectTarget_100015) == 0x000210, "Wrong size on UUIC_SelectTarget_100015");
static_assert(offsetof(UUIC_SelectTarget_100015, WaveActionData) == 0x000158, "Member 'UUIC_SelectTarget_100015::WaveActionData' has a wrong offset!");
static_assert(offsetof(UUIC_SelectTarget_100015, ConfirmActionData) == 0x0001B0, "Member 'UUIC_SelectTarget_100015::ConfirmActionData' has a wrong offset!");
static_assert(offsetof(UUIC_SelectTarget_100015, OwningAbility) == 0x000208, "Member 'UUIC_SelectTarget_100015::OwningAbility' has a wrong offset!");

// Class Hero_Synergy.Config_100016
// 0x0030 (0x00C8 - 0x0098)
class UConfig_100016 : public UMarvelAbilityConfig
{
public:
	struct FVector                                ThrowSplineOffset;                                 // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowSplineInitSpeed;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowSplineMaxSpeed;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowSplineMaxAcceleration;                        // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowSplineUpGravityRatio;                         // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowSplineDownGravityRatio;                       // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_100016">();
	}
	static class UConfig_100016* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_100016>();
	}
};
static_assert(alignof(UConfig_100016) == 0x000008, "Wrong alignment on UConfig_100016");
static_assert(sizeof(UConfig_100016) == 0x0000C8, "Wrong size on UConfig_100016");
static_assert(offsetof(UConfig_100016, ThrowSplineOffset) == 0x000098, "Member 'UConfig_100016::ThrowSplineOffset' has a wrong offset!");
static_assert(offsetof(UConfig_100016, ThrowSplineInitSpeed) == 0x0000B0, "Member 'UConfig_100016::ThrowSplineInitSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_100016, ThrowSplineMaxSpeed) == 0x0000B4, "Member 'UConfig_100016::ThrowSplineMaxSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_100016, ThrowSplineMaxAcceleration) == 0x0000B8, "Member 'UConfig_100016::ThrowSplineMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UConfig_100016, ThrowSplineUpGravityRatio) == 0x0000BC, "Member 'UConfig_100016::ThrowSplineUpGravityRatio' has a wrong offset!");
static_assert(offsetof(UConfig_100016, ThrowSplineDownGravityRatio) == 0x0000C0, "Member 'UConfig_100016::ThrowSplineDownGravityRatio' has a wrong offset!");

// Class Hero_Synergy.Ability_100016
// 0x0048 (0x25B0 - 0x2568)
class UAbility_100016 : public UMarvelAbility_LongPressTrigger
{
public:
	FMulticastInlineDelegateProperty_             ThrowSplineHudEnabledDispatcher;                   // 0x2568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   ThrowCharacter;                                    // 0x2578(0x0008)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowPrediction_UpHeight;                          // 0x2580(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowPrediction_DownHeight;                        // 0x2584(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowPrediction_UpSeconds;                         // 0x2588(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowPrediction_DownSeconds;                       // 0x258C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceMoveSpeed;                                    // 0x2590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpGravityRatio;                                    // 0x2594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownGravityRatio;                                  // 0x2598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMoveSpeed;                                      // 0x259C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x25A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReleased;                                         // 0x25A4(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A5[0x3];                                     // 0x25A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_100016*                         CoopConfig;                                        // 0x25A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BroadcastThrowSplineHudEnabled(bool bEnabled);
	void OnRep_ThrowCharacter();
	void OnThrowCharacterCoopRideStateChanged(bool bIsRiding, class AMarvelBaseCharacter* RideCharacter);
	void PredictThrowDataWhenPressed(const struct FVector& PredictVelocity, TArray<struct FVector>* PredictionPath, float MaxFallSeconds, float MaxJumpHeightDown);
	struct FVector PredictThrowVelocity(float PredictSpeed, bool bRemoteRole, const struct FRotator& InRotator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_100016">();
	}
	static class UAbility_100016* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_100016>();
	}
};
static_assert(alignof(UAbility_100016) == 0x000008, "Wrong alignment on UAbility_100016");
static_assert(sizeof(UAbility_100016) == 0x0025B0, "Wrong size on UAbility_100016");
static_assert(offsetof(UAbility_100016, ThrowSplineHudEnabledDispatcher) == 0x002568, "Member 'UAbility_100016::ThrowSplineHudEnabledDispatcher' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ThrowCharacter) == 0x002578, "Member 'UAbility_100016::ThrowCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ThrowPrediction_UpHeight) == 0x002580, "Member 'UAbility_100016::ThrowPrediction_UpHeight' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ThrowPrediction_DownHeight) == 0x002584, "Member 'UAbility_100016::ThrowPrediction_DownHeight' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ThrowPrediction_UpSeconds) == 0x002588, "Member 'UAbility_100016::ThrowPrediction_UpSeconds' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ThrowPrediction_DownSeconds) == 0x00258C, "Member 'UAbility_100016::ThrowPrediction_DownSeconds' has a wrong offset!");
static_assert(offsetof(UAbility_100016, ForceMoveSpeed) == 0x002590, "Member 'UAbility_100016::ForceMoveSpeed' has a wrong offset!");
static_assert(offsetof(UAbility_100016, UpGravityRatio) == 0x002594, "Member 'UAbility_100016::UpGravityRatio' has a wrong offset!");
static_assert(offsetof(UAbility_100016, DownGravityRatio) == 0x002598, "Member 'UAbility_100016::DownGravityRatio' has a wrong offset!");
static_assert(offsetof(UAbility_100016, MaxMoveSpeed) == 0x00259C, "Member 'UAbility_100016::MaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(UAbility_100016, MaxAcceleration) == 0x0025A0, "Member 'UAbility_100016::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UAbility_100016, bReleased) == 0x0025A4, "Member 'UAbility_100016::bReleased' has a wrong offset!");
static_assert(offsetof(UAbility_100016, CoopConfig) == 0x0025A8, "Member 'UAbility_100016::CoopConfig' has a wrong offset!");

// Class Hero_Synergy.Cue_Ability_Loop_100016
// 0x00B8 (0x0EB8 - 0x0E00)
class ACue_Ability_Loop_100016 final : public AMarvelCueNotify_Ability
{
public:
	class UMarvelSplineComponent*                 SplineComponent;                                   // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            TailStaticMesh;                                    // 0x0E08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BodyStaticMesh;                                    // 0x0E10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            HeadStaticMesh;                                    // 0x0E18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           SplineMeshCollection;                              // 0x0E20(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x0E30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E34[0x4];                                      // 0x0E34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_100016*                        OwnerAbility;                                      // 0x0E38(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0E40(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedCurve;                                        // 0x0E48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressedSecondsMin;                                 // 0x0E50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAuxiliaryLineOn;                                 // 0x0E54(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E55[0x3];                                      // 0x0E55(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTerminalHeight;                                 // 0x0E58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressedTimeAdjust;                                 // 0x0E5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressedTimeInterpAlpha;                            // 0x0E60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemoteVelocityInterpAlpha;                         // 0x0E64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E68[0x4];                                      // 0x0E68(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumOfSplinePoints;                              // 0x0E6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenPathReduction;                                // 0x0E70(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E71[0x3];                                      // 0x0E71(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastSegmentLength;                                 // 0x0E74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpSeconds;                                    // 0x0E78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpHeightDown;                                 // 0x0E7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumOfSplineMeshUsed;                            // 0x0E80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E84[0x20];                                     // 0x0E84(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WolverineAlphaValue;                               // 0x0EA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA8[0x5];                                      // 0x0EA8(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAbilityEnableDrawSpline;                          // 0x0EAD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EAE[0xA];                                      // 0x0EAE(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerAbilityThrowSplineHudEnabledChanged(bool bEnabled);
	void OnPressRelease(float TimeWaited);
	void OnPressTimeMin(float TimeWaited);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_100016">();
	}
	static class ACue_Ability_Loop_100016* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_100016>();
	}
};
static_assert(alignof(ACue_Ability_Loop_100016) == 0x000008, "Wrong alignment on ACue_Ability_Loop_100016");
static_assert(sizeof(ACue_Ability_Loop_100016) == 0x000EB8, "Wrong size on ACue_Ability_Loop_100016");
static_assert(offsetof(ACue_Ability_Loop_100016, SplineComponent) == 0x000E00, "Member 'ACue_Ability_Loop_100016::SplineComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, TailStaticMesh) == 0x000E08, "Member 'ACue_Ability_Loop_100016::TailStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, BodyStaticMesh) == 0x000E10, "Member 'ACue_Ability_Loop_100016::BodyStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, HeadStaticMesh) == 0x000E18, "Member 'ACue_Ability_Loop_100016::HeadStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, SplineMeshCollection) == 0x000E20, "Member 'ACue_Ability_Loop_100016::SplineMeshCollection' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, AbilityID) == 0x000E30, "Member 'ACue_Ability_Loop_100016::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, OwnerAbility) == 0x000E38, "Member 'ACue_Ability_Loop_100016::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, OwnerCharacter) == 0x000E40, "Member 'ACue_Ability_Loop_100016::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, SpeedCurve) == 0x000E48, "Member 'ACue_Ability_Loop_100016::SpeedCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, PressedSecondsMin) == 0x000E50, "Member 'ACue_Ability_Loop_100016::PressedSecondsMin' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, IsAuxiliaryLineOn) == 0x000E54, "Member 'ACue_Ability_Loop_100016::IsAuxiliaryLineOn' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, MinTerminalHeight) == 0x000E58, "Member 'ACue_Ability_Loop_100016::MinTerminalHeight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, PressedTimeAdjust) == 0x000E5C, "Member 'ACue_Ability_Loop_100016::PressedTimeAdjust' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, PressedTimeInterpAlpha) == 0x000E60, "Member 'ACue_Ability_Loop_100016::PressedTimeInterpAlpha' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, RemoteVelocityInterpAlpha) == 0x000E64, "Member 'ACue_Ability_Loop_100016::RemoteVelocityInterpAlpha' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, MaxNumOfSplinePoints) == 0x000E6C, "Member 'ACue_Ability_Loop_100016::MaxNumOfSplinePoints' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, bOpenPathReduction) == 0x000E70, "Member 'ACue_Ability_Loop_100016::bOpenPathReduction' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, LastSegmentLength) == 0x000E74, "Member 'ACue_Ability_Loop_100016::LastSegmentLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, MaxJumpSeconds) == 0x000E78, "Member 'ACue_Ability_Loop_100016::MaxJumpSeconds' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, MaxJumpHeightDown) == 0x000E7C, "Member 'ACue_Ability_Loop_100016::MaxJumpHeightDown' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, MaxNumOfSplineMeshUsed) == 0x000E80, "Member 'ACue_Ability_Loop_100016::MaxNumOfSplineMeshUsed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, WolverineAlphaValue) == 0x000EA4, "Member 'ACue_Ability_Loop_100016::WolverineAlphaValue' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_100016, bAbilityEnableDrawSpline) == 0x000EAD, "Member 'ACue_Ability_Loop_100016::bAbilityEnableDrawSpline' has a wrong offset!");

// Class Hero_Synergy.SynergyThrowSplineMeshComponent
// 0x0000 (0x0A20 - 0x0A20)
class USynergyThrowSplineMeshComponent final : public USplineMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SynergyThrowSplineMeshComponent">();
	}
	static class USynergyThrowSplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USynergyThrowSplineMeshComponent>();
	}
};
static_assert(alignof(USynergyThrowSplineMeshComponent) == 0x000010, "Wrong alignment on USynergyThrowSplineMeshComponent");
static_assert(sizeof(USynergyThrowSplineMeshComponent) == 0x000A20, "Wrong size on USynergyThrowSplineMeshComponent");

}

