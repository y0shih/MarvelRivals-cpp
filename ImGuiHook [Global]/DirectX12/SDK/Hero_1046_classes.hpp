#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1046

#include "Basic.hpp"

#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Hero_1046_structs.hpp"


namespace SDK
{

// Class Hero_1046.Config_104621
// 0x0078 (0x0110 - 0x0098)
class UConfig_104621 final : public UMarvelAbilityConfig
{
public:
	int32                                         ReloadAbilityID;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumeAmmosForEachEnergy;                         // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitInterval;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GatherInterval;                                    // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileID;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ProjectileOffset;                                  // 0x00B0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104621">();
	}
	static class UConfig_104621* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104621>();
	}
};
static_assert(alignof(UConfig_104621) == 0x000010, "Wrong alignment on UConfig_104621");
static_assert(sizeof(UConfig_104621) == 0x000110, "Wrong size on UConfig_104621");
static_assert(offsetof(UConfig_104621, ReloadAbilityID) == 0x000098, "Member 'UConfig_104621::ReloadAbilityID' has a wrong offset!");
static_assert(offsetof(UConfig_104621, ConsumeAmmosForEachEnergy) == 0x00009C, "Member 'UConfig_104621::ConsumeAmmosForEachEnergy' has a wrong offset!");
static_assert(offsetof(UConfig_104621, EmitInterval) == 0x0000A0, "Member 'UConfig_104621::EmitInterval' has a wrong offset!");
static_assert(offsetof(UConfig_104621, GatherInterval) == 0x0000A4, "Member 'UConfig_104621::GatherInterval' has a wrong offset!");
static_assert(offsetof(UConfig_104621, ProjectileID) == 0x0000A8, "Member 'UConfig_104621::ProjectileID' has a wrong offset!");
static_assert(offsetof(UConfig_104621, ProjectileOffset) == 0x0000B0, "Member 'UConfig_104621::ProjectileOffset' has a wrong offset!");

// Class Hero_1046.Ability_104621
// 0x0020 (0x2588 - 0x2568)
class UAbility_104621 : public UMarvelAbility_LongPressTrigger
{
public:
	FMulticastInlineDelegateProperty_             HasGatherEnergyBallNumDelegate;                    // 0x2568(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	int32                                         MaxEnergyBallNum;                                  // 0x2578(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_257C[0xC];                                     // 0x257C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxEnergyBallNum(int32 InNum);

	void OnAbilityActiveFailed(const class UGameplayAbility* InAbility, const struct FGameplayTagContainer& Tags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104621">();
	}
	static class UAbility_104621* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104621>();
	}
};
static_assert(alignof(UAbility_104621) == 0x000008, "Wrong alignment on UAbility_104621");
static_assert(sizeof(UAbility_104621) == 0x002588, "Wrong size on UAbility_104621");
static_assert(offsetof(UAbility_104621, HasGatherEnergyBallNumDelegate) == 0x002568, "Member 'UAbility_104621::HasGatherEnergyBallNumDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_104621, MaxEnergyBallNum) == 0x002578, "Member 'UAbility_104621::MaxEnergyBallNum' has a wrong offset!");

// Class Hero_1046.Cue_Ability_Loop_10462101
// 0x0140 (0x0F40 - 0x0E00)
class ACue_Ability_Loop_10462101 final : public AMarvelCueNotify_Ability
{
public:
	struct FGameplayTag                           DeactivateEventTag;                                // 0x0E00(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0C[0x4];                                      // 0x0E0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         ReleaseFXAsset;                                    // 0x0E10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LoopFXAsset;                                       // 0x0E18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             ReleaseFXOffset;                                   // 0x0E20(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             LoopFXOffset;                                      // 0x0E80(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketAttachedName;                                // 0x0EE0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioSwitchGroup;                                  // 0x0EEC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioSwitchState;                                  // 0x0EF8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleaseAudioID;                                    // 0x0F04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0F08(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     WeaponReleaseFX;                                   // 0x0F10(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     WeaponLoopFX;                                      // 0x0F18(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F20[0x8];                                      // 0x0F20(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_104621*                        OwningAbility;                                     // 0x0F28(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F30[0x10];                                     // 0x0F30(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10462101">();
	}
	static class ACue_Ability_Loop_10462101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10462101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10462101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10462101");
static_assert(sizeof(ACue_Ability_Loop_10462101) == 0x000F40, "Wrong size on ACue_Ability_Loop_10462101");
static_assert(offsetof(ACue_Ability_Loop_10462101, DeactivateEventTag) == 0x000E00, "Member 'ACue_Ability_Loop_10462101::DeactivateEventTag' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, ReleaseFXAsset) == 0x000E10, "Member 'ACue_Ability_Loop_10462101::ReleaseFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, LoopFXAsset) == 0x000E18, "Member 'ACue_Ability_Loop_10462101::LoopFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, ReleaseFXOffset) == 0x000E20, "Member 'ACue_Ability_Loop_10462101::ReleaseFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, LoopFXOffset) == 0x000E80, "Member 'ACue_Ability_Loop_10462101::LoopFXOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, SocketAttachedName) == 0x000EE0, "Member 'ACue_Ability_Loop_10462101::SocketAttachedName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, AudioSwitchGroup) == 0x000EEC, "Member 'ACue_Ability_Loop_10462101::AudioSwitchGroup' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, AudioSwitchState) == 0x000EF8, "Member 'ACue_Ability_Loop_10462101::AudioSwitchState' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, ReleaseAudioID) == 0x000F04, "Member 'ACue_Ability_Loop_10462101::ReleaseAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, OwnerCharacter) == 0x000F08, "Member 'ACue_Ability_Loop_10462101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, WeaponReleaseFX) == 0x000F10, "Member 'ACue_Ability_Loop_10462101::WeaponReleaseFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, WeaponLoopFX) == 0x000F18, "Member 'ACue_Ability_Loop_10462101::WeaponLoopFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10462101, OwningAbility) == 0x000F28, "Member 'ACue_Ability_Loop_10462101::OwningAbility' has a wrong offset!");

// Class Hero_1046.AnimNotify_SpawnProjectileFromWeapon
// 0x0010 (0x0088 - 0x0078)
class UAnimNotify_SpawnProjectileFromWeapon final : public UAnimNotify_SpawnProjectile
{
public:
	class FName                                   WeaponSocketName;                                  // 0x0078(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SpawnProjectileFromWeapon">();
	}
	static class UAnimNotify_SpawnProjectileFromWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SpawnProjectileFromWeapon>();
	}
};
static_assert(alignof(UAnimNotify_SpawnProjectileFromWeapon) == 0x000008, "Wrong alignment on UAnimNotify_SpawnProjectileFromWeapon");
static_assert(sizeof(UAnimNotify_SpawnProjectileFromWeapon) == 0x000088, "Wrong size on UAnimNotify_SpawnProjectileFromWeapon");
static_assert(offsetof(UAnimNotify_SpawnProjectileFromWeapon, WeaponSocketName) == 0x000078, "Member 'UAnimNotify_SpawnProjectileFromWeapon::WeaponSocketName' has a wrong offset!");

// Class Hero_1046.AnimNotify_WeaponPlayNiagaraEffectEx
// 0x0000 (0x0360 - 0x0360)
class UAnimNotify_WeaponPlayNiagaraEffectEx final : public UAnimNotify_PlayNiagaraEffectEx
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WeaponPlayNiagaraEffectEx">();
	}
	static class UAnimNotify_WeaponPlayNiagaraEffectEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WeaponPlayNiagaraEffectEx>();
	}
};
static_assert(alignof(UAnimNotify_WeaponPlayNiagaraEffectEx) == 0x000010, "Wrong alignment on UAnimNotify_WeaponPlayNiagaraEffectEx");
static_assert(sizeof(UAnimNotify_WeaponPlayNiagaraEffectEx) == 0x000360, "Wrong size on UAnimNotify_WeaponPlayNiagaraEffectEx");

// Class Hero_1046.Config_104641
// 0x10C8 (0x1160 - 0x0098)
class UConfig_104641 final : public UMarvelAbilityConfig
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSelectTaskParam                       SelectTaskParams;                                  // 0x00A0(0x1040)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bCanSelectPreTarget;                               // 0x10E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E1[0x3];                                     // 0x10E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TreatmentBuffID;                                   // 0x10E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBounceTime;                                     // 0x10E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreatmentAttenuation;                              // 0x10EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETreatPriorityType                            PriorityOne;                                       // 0x10F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETreatPriorityType                            PriorityTwo;                                       // 0x10F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETreatPriorityType                            PriorityThree;                                     // 0x10F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETreatPriorityType                            PriorityFour;                                      // 0x10F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F4[0x4];                                     // 0x10F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagContainer;                                      // 0x10F8(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104641">();
	}
	static class UConfig_104641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104641>();
	}
};
static_assert(alignof(UConfig_104641) == 0x000010, "Wrong alignment on UConfig_104641");
static_assert(sizeof(UConfig_104641) == 0x001160, "Wrong size on UConfig_104641");
static_assert(offsetof(UConfig_104641, SelectTaskParams) == 0x0000A0, "Member 'UConfig_104641::SelectTaskParams' has a wrong offset!");
static_assert(offsetof(UConfig_104641, bCanSelectPreTarget) == 0x0010E0, "Member 'UConfig_104641::bCanSelectPreTarget' has a wrong offset!");
static_assert(offsetof(UConfig_104641, TreatmentBuffID) == 0x0010E4, "Member 'UConfig_104641::TreatmentBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104641, MaxBounceTime) == 0x0010E8, "Member 'UConfig_104641::MaxBounceTime' has a wrong offset!");
static_assert(offsetof(UConfig_104641, TreatmentAttenuation) == 0x0010EC, "Member 'UConfig_104641::TreatmentAttenuation' has a wrong offset!");
static_assert(offsetof(UConfig_104641, PriorityOne) == 0x0010F0, "Member 'UConfig_104641::PriorityOne' has a wrong offset!");
static_assert(offsetof(UConfig_104641, PriorityTwo) == 0x0010F1, "Member 'UConfig_104641::PriorityTwo' has a wrong offset!");
static_assert(offsetof(UConfig_104641, PriorityThree) == 0x0010F2, "Member 'UConfig_104641::PriorityThree' has a wrong offset!");
static_assert(offsetof(UConfig_104641, PriorityFour) == 0x0010F3, "Member 'UConfig_104641::PriorityFour' has a wrong offset!");
static_assert(offsetof(UConfig_104641, TagContainer) == 0x0010F8, "Member 'UConfig_104641::TagContainer' has a wrong offset!");

// Class Hero_1046.Ability_104641
// 0x0180 (0x26D8 - 0x2558)
class UAbility_104641 : public UAbility_108
{
public:
	class UMarvelAbilityTask_SelectTarget*        SelectTargetTask;                                  // 0x2558(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104641*                         Config;                                            // 0x2560(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             FirstTreatResult;                                  // 0x2568(0x0160)(Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TreatNextTargetDelegate;                           // 0x26C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104641">();
	}
	static class UAbility_104641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104641>();
	}
};
static_assert(alignof(UAbility_104641) == 0x000008, "Wrong alignment on UAbility_104641");
static_assert(sizeof(UAbility_104641) == 0x0026D8, "Wrong size on UAbility_104641");
static_assert(offsetof(UAbility_104641, SelectTargetTask) == 0x002558, "Member 'UAbility_104641::SelectTargetTask' has a wrong offset!");
static_assert(offsetof(UAbility_104641, Config) == 0x002560, "Member 'UAbility_104641::Config' has a wrong offset!");
static_assert(offsetof(UAbility_104641, FirstTreatResult) == 0x002568, "Member 'UAbility_104641::FirstTreatResult' has a wrong offset!");
static_assert(offsetof(UAbility_104641, TreatNextTargetDelegate) == 0x0026C8, "Member 'UAbility_104641::TreatNextTargetDelegate' has a wrong offset!");

// Class Hero_1046.Scope_10464101
// 0x01E0 (0x18A0 - 0x16C0)
class AScope_10464101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	class UAbility_104641*                        OwnerAbility;                                      // 0x16C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104641*                         AbilityConfig;                                     // 0x16C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x16D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ACharacter*>                     TreatedTargets;                                    // 0x16D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E8[0x28];                                    // 0x16E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             FirstTreatTarget;                                  // 0x1710(0x0160)(Net, IsPlainOldData, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FTreatTarget_104641                    NextTreatTarget;                                   // 0x1870(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1880[0x20];                                    // 0x1880(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FirstTreatTarget();
	void OnRep_NextTreatTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10464101">();
	}
	static class AScope_10464101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10464101>();
	}
};
static_assert(alignof(AScope_10464101) == 0x000010, "Wrong alignment on AScope_10464101");
static_assert(sizeof(AScope_10464101) == 0x0018A0, "Wrong size on AScope_10464101");
static_assert(offsetof(AScope_10464101, OwnerAbility) == 0x0016C0, "Member 'AScope_10464101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(AScope_10464101, AbilityConfig) == 0x0016C8, "Member 'AScope_10464101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(AScope_10464101, OwnerCharacter) == 0x0016D0, "Member 'AScope_10464101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AScope_10464101, TreatedTargets) == 0x0016D8, "Member 'AScope_10464101::TreatedTargets' has a wrong offset!");
static_assert(offsetof(AScope_10464101, FirstTreatTarget) == 0x001710, "Member 'AScope_10464101::FirstTreatTarget' has a wrong offset!");
static_assert(offsetof(AScope_10464101, NextTreatTarget) == 0x001870, "Member 'AScope_10464101::NextTreatTarget' has a wrong offset!");

// Class Hero_1046.TraceComponent_10464101
// 0x0000 (0x16B0 - 0x16B0)
class UTraceComponent_10464101 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10464101">();
	}
	static class UTraceComponent_10464101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10464101>();
	}
};
static_assert(alignof(UTraceComponent_10464101) == 0x000010, "Wrong alignment on UTraceComponent_10464101");
static_assert(sizeof(UTraceComponent_10464101) == 0x0016B0, "Wrong size on UTraceComponent_10464101");

// Class Hero_1046.AdamWarlockAnimInstance
// 0x0010 (0x0910 - 0x0900)
class UAdamWarlockAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsInSoulStatus;                                   // 0x0900(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_901[0xF];                                      // 0x0901(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockAnimInstance">();
	}
	static class UAdamWarlockAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamWarlockAnimInstance>();
	}
};
static_assert(alignof(UAdamWarlockAnimInstance) == 0x000010, "Wrong alignment on UAdamWarlockAnimInstance");
static_assert(sizeof(UAdamWarlockAnimInstance) == 0x000910, "Wrong size on UAdamWarlockAnimInstance");
static_assert(offsetof(UAdamWarlockAnimInstance, bIsInSoulStatus) == 0x000900, "Member 'UAdamWarlockAnimInstance::bIsInSoulStatus' has a wrong offset!");

// Class Hero_1046.Cue_Buff_10464101
// 0x0008 (0x0FF0 - 0x0FE8)
class ACue_Buff_10464101 final : public AMarvelCueNotify_Buff
{
public:
	class UFXSystemAsset*                         HealEffect;                                        // 0x0FE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10464101">();
	}
	static class ACue_Buff_10464101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10464101>();
	}
};
static_assert(alignof(ACue_Buff_10464101) == 0x000008, "Wrong alignment on ACue_Buff_10464101");
static_assert(sizeof(ACue_Buff_10464101) == 0x000FF0, "Wrong size on ACue_Buff_10464101");
static_assert(offsetof(ACue_Buff_10464101, HealEffect) == 0x000FE8, "Member 'ACue_Buff_10464101::HealEffect' has a wrong offset!");

// Class Hero_1046.Cue_Scope_Loop_10464101
// 0x0090 (0x0DB0 - 0x0D20)
class ACue_Scope_Loop_10464101 final : public AMarvelCueNotify_Scope
{
public:
	class UAbility_104641*                        OwnerAbility;                                      // 0x0D20(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AScope_10464101*                        OwningScope;                                       // 0x0D28(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0D30(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LinkEffectTemplate;                                // 0x0D38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LinkEffectTemplateSelf;                            // 0x0D40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         HealthEffectTemplate;                              // 0x0D48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinkEffectPair>                LinkEffects;                                       // 0x0D50(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                FirstLinkEffectOffset;                             // 0x0D60(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstLinkEffectSocketName;                         // 0x0D78(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D84[0x4];                                      // 0x0D84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LinkEffectOffset;                                  // 0x0D88(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinkEffectSocketName;                              // 0x0DA0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DAC[0x4];                                      // 0x0DAC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SpawnLinkEffect(class ACharacter* FromCharacter, class ACharacter* ToCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10464101">();
	}
	static class ACue_Scope_Loop_10464101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10464101>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10464101) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10464101");
static_assert(sizeof(ACue_Scope_Loop_10464101) == 0x000DB0, "Wrong size on ACue_Scope_Loop_10464101");
static_assert(offsetof(ACue_Scope_Loop_10464101, OwnerAbility) == 0x000D20, "Member 'ACue_Scope_Loop_10464101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, OwningScope) == 0x000D28, "Member 'ACue_Scope_Loop_10464101::OwningScope' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, OwnerCharacter) == 0x000D30, "Member 'ACue_Scope_Loop_10464101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, LinkEffectTemplate) == 0x000D38, "Member 'ACue_Scope_Loop_10464101::LinkEffectTemplate' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, LinkEffectTemplateSelf) == 0x000D40, "Member 'ACue_Scope_Loop_10464101::LinkEffectTemplateSelf' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, HealthEffectTemplate) == 0x000D48, "Member 'ACue_Scope_Loop_10464101::HealthEffectTemplate' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, LinkEffects) == 0x000D50, "Member 'ACue_Scope_Loop_10464101::LinkEffects' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, FirstLinkEffectOffset) == 0x000D60, "Member 'ACue_Scope_Loop_10464101::FirstLinkEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, FirstLinkEffectSocketName) == 0x000D78, "Member 'ACue_Scope_Loop_10464101::FirstLinkEffectSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, LinkEffectOffset) == 0x000D88, "Member 'ACue_Scope_Loop_10464101::LinkEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10464101, LinkEffectSocketName) == 0x000DA0, "Member 'ACue_Scope_Loop_10464101::LinkEffectSocketName' has a wrong offset!");

// Class Hero_1046.Cue_Buff_10465101
// 0x00C0 (0x10A8 - 0x0FE8)
class ACue_Buff_10465101 final : public AMarvelCueNotify_Buff
{
public:
	class FName                                   TopParamName;                                      // 0x0FE8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomParamName;                                   // 0x0FF4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TopBoneName;                                       // 0x1000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomBoneName;                                    // 0x100C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpenParamName;                                     // 0x1018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickUpdateParam;                                  // 0x1024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1025[0x3];                                     // 0x1025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FadeParamName;                                     // 0x1028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x1034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LinkEffectTemp;                                    // 0x1038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinkEffectEndPoint;                                // 0x1040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinkEffectStartPoint;                              // 0x104C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x1058(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinkEffectPair                        LinkEffectPair;                                    // 0x1060(0x0020)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1080[0x28];                                    // 0x1080(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBuffOwnerDeath(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10465101">();
	}
	static class ACue_Buff_10465101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10465101>();
	}
};
static_assert(alignof(ACue_Buff_10465101) == 0x000008, "Wrong alignment on ACue_Buff_10465101");
static_assert(sizeof(ACue_Buff_10465101) == 0x0010A8, "Wrong size on ACue_Buff_10465101");
static_assert(offsetof(ACue_Buff_10465101, TopParamName) == 0x000FE8, "Member 'ACue_Buff_10465101::TopParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, BottomParamName) == 0x000FF4, "Member 'ACue_Buff_10465101::BottomParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, TopBoneName) == 0x001000, "Member 'ACue_Buff_10465101::TopBoneName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, BottomBoneName) == 0x00100C, "Member 'ACue_Buff_10465101::BottomBoneName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, OpenParamName) == 0x001018, "Member 'ACue_Buff_10465101::OpenParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, bTickUpdateParam) == 0x001024, "Member 'ACue_Buff_10465101::bTickUpdateParam' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, FadeParamName) == 0x001028, "Member 'ACue_Buff_10465101::FadeParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, FadeTime) == 0x001034, "Member 'ACue_Buff_10465101::FadeTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, LinkEffectTemp) == 0x001038, "Member 'ACue_Buff_10465101::LinkEffectTemp' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, LinkEffectEndPoint) == 0x001040, "Member 'ACue_Buff_10465101::LinkEffectEndPoint' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, LinkEffectStartPoint) == 0x00104C, "Member 'ACue_Buff_10465101::LinkEffectStartPoint' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, NiagaraComponent) == 0x001058, "Member 'ACue_Buff_10465101::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10465101, LinkEffectPair) == 0x001060, "Member 'ACue_Buff_10465101::LinkEffectPair' has a wrong offset!");

// Class Hero_1046.Cue_Ability_Instant_10464101
// 0x0000 (0x0368 - 0x0368)
class UCue_Ability_Instant_10464101 final : public UMarvelCueNotify_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Instant_10464101">();
	}
	static class UCue_Ability_Instant_10464101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Ability_Instant_10464101>();
	}
};
static_assert(alignof(UCue_Ability_Instant_10464101) == 0x000008, "Wrong alignment on UCue_Ability_Instant_10464101");
static_assert(sizeof(UCue_Ability_Instant_10464101) == 0x000368, "Wrong size on UCue_Ability_Instant_10464101");

// Class Hero_1046.Config_104651
// 0x0030 (0x00C8 - 0x0098)
class UConfig_104651 final : public UMarvelAbilityConfig
{
public:
	float                                         BuffRemoveDelay;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHealthRatioForRemoveBuff;                       // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SymbioticScopeID;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SymbioticBuffID;                                   // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDeltaRadius;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinkTargetPerTarget;                            // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HealthLinkTreatBuffID;                             // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinkSelf;                                         // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           EffectTag;                                         // 0x00B8(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104651">();
	}
	static class UConfig_104651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104651>();
	}
};
static_assert(alignof(UConfig_104651) == 0x000008, "Wrong alignment on UConfig_104651");
static_assert(sizeof(UConfig_104651) == 0x0000C8, "Wrong size on UConfig_104651");
static_assert(offsetof(UConfig_104651, BuffRemoveDelay) == 0x000098, "Member 'UConfig_104651::BuffRemoveDelay' has a wrong offset!");
static_assert(offsetof(UConfig_104651, MinHealthRatioForRemoveBuff) == 0x00009C, "Member 'UConfig_104651::MinHealthRatioForRemoveBuff' has a wrong offset!");
static_assert(offsetof(UConfig_104651, SymbioticScopeID) == 0x0000A0, "Member 'UConfig_104651::SymbioticScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_104651, SymbioticBuffID) == 0x0000A4, "Member 'UConfig_104651::SymbioticBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104651, TraceDeltaRadius) == 0x0000A8, "Member 'UConfig_104651::TraceDeltaRadius' has a wrong offset!");
static_assert(offsetof(UConfig_104651, MaxLinkTargetPerTarget) == 0x0000AC, "Member 'UConfig_104651::MaxLinkTargetPerTarget' has a wrong offset!");
static_assert(offsetof(UConfig_104651, HealthLinkTreatBuffID) == 0x0000B0, "Member 'UConfig_104651::HealthLinkTreatBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_104651, bLinkSelf) == 0x0000B4, "Member 'UConfig_104651::bLinkSelf' has a wrong offset!");
static_assert(offsetof(UConfig_104651, EffectTag) == 0x0000B8, "Member 'UConfig_104651::EffectTag' has a wrong offset!");

// Class Hero_1046.Ability_104651
// 0x0010 (0x2568 - 0x2558)
class UAbility_104651 : public UAbility_108
{
public:
	uint8                                         Pad_2558[0x10];                                    // 0x2558(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOriginLinkGroupEnd(const class AActor* BuffInstigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104651">();
	}
	static class UAbility_104651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104651>();
	}
};
static_assert(alignof(UAbility_104651) == 0x000008, "Wrong alignment on UAbility_104651");
static_assert(sizeof(UAbility_104651) == 0x002568, "Wrong size on UAbility_104651");

// Class Hero_1046.Scope_10465102
// 0x0050 (0x1710 - 0x16C0)
class AScope_10465102 final : public AMarvelAbilityTargetActor_Scope
{
public:
	class UAbility_104651*                        OwnerAbility;                                      // 0x16C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_104651*                         AbilityConfig;                                     // 0x16C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x16D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelBaseAbilitySystemComponent*      OwnerABS;                                          // 0x16D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinkedBuffInfo>                LinkedTargetsInfo;                                 // 0x16E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         LinkTargets;                                       // 0x16F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1700[0x10];                                    // 0x1700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10465102">();
	}
	static class AScope_10465102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10465102>();
	}
};
static_assert(alignof(AScope_10465102) == 0x000010, "Wrong alignment on AScope_10465102");
static_assert(sizeof(AScope_10465102) == 0x001710, "Wrong size on AScope_10465102");
static_assert(offsetof(AScope_10465102, OwnerAbility) == 0x0016C0, "Member 'AScope_10465102::OwnerAbility' has a wrong offset!");
static_assert(offsetof(AScope_10465102, AbilityConfig) == 0x0016C8, "Member 'AScope_10465102::AbilityConfig' has a wrong offset!");
static_assert(offsetof(AScope_10465102, OwnerCharacter) == 0x0016D0, "Member 'AScope_10465102::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AScope_10465102, OwnerABS) == 0x0016D8, "Member 'AScope_10465102::OwnerABS' has a wrong offset!");
static_assert(offsetof(AScope_10465102, LinkedTargetsInfo) == 0x0016E0, "Member 'AScope_10465102::LinkedTargetsInfo' has a wrong offset!");
static_assert(offsetof(AScope_10465102, LinkTargets) == 0x0016F0, "Member 'AScope_10465102::LinkTargets' has a wrong offset!");

// Class Hero_1046.Cue_Buff_10466103
// 0x00A8 (0x10A8 - 0x1000)
class ACue_Buff_10466103 final : public ACue_Buff_Resurrection
{
public:
	class UTexture2D*                             Icon;                                              // 0x1000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OnRespawningText;                                  // 0x1008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   OnRespawningFinishText;                            // 0x1020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   OnRespawningAbortText;                             // 0x1038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     RevivingMaterial;                                  // 0x1050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightColumnDelay;                                  // 0x1058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105C[0x4];                                     // 0x105C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         LightColumnAsset;                                  // 0x1060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         ExplodeFXAsset;                                    // 0x1068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TextureParamName;                                  // 0x1070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ResurrectionAudioID;                               // 0x1080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1084[0x1C];                                    // 0x1084(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterAudioComponent*               AudioComp;                                         // 0x10A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOwnerRebornReset(class AActor* Target, const struct FCharacterRebornParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10466103">();
	}
	static class ACue_Buff_10466103* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10466103>();
	}
};
static_assert(alignof(ACue_Buff_10466103) == 0x000008, "Wrong alignment on ACue_Buff_10466103");
static_assert(sizeof(ACue_Buff_10466103) == 0x0010A8, "Wrong size on ACue_Buff_10466103");
static_assert(offsetof(ACue_Buff_10466103, Icon) == 0x001000, "Member 'ACue_Buff_10466103::Icon' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, OnRespawningText) == 0x001008, "Member 'ACue_Buff_10466103::OnRespawningText' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, OnRespawningFinishText) == 0x001020, "Member 'ACue_Buff_10466103::OnRespawningFinishText' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, OnRespawningAbortText) == 0x001038, "Member 'ACue_Buff_10466103::OnRespawningAbortText' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, RevivingMaterial) == 0x001050, "Member 'ACue_Buff_10466103::RevivingMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, LightColumnDelay) == 0x001058, "Member 'ACue_Buff_10466103::LightColumnDelay' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, LightColumnAsset) == 0x001060, "Member 'ACue_Buff_10466103::LightColumnAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, ExplodeFXAsset) == 0x001068, "Member 'ACue_Buff_10466103::ExplodeFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, TextureParamName) == 0x001070, "Member 'ACue_Buff_10466103::TextureParamName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, ResurrectionAudioID) == 0x001080, "Member 'ACue_Buff_10466103::ResurrectionAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10466103, AudioComp) == 0x0010A0, "Member 'ACue_Buff_10466103::AudioComp' has a wrong offset!");

// Class Hero_1046.HealthLinkAbility_104651
// 0x0028 (0x1130 - 0x1108)
class UHealthLinkAbility_104651 : public UMarvelHealthLinkAbility
{
public:
	float                                         MinHealthRatio;                                    // 0x1108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110C[0x14];                                    // 0x110C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelBaseAbilitySystemComponent*      OwnerASC;                                          // 0x1120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelBaseAbilitySystemComponent*      InstigatorASC;                                     // 0x1128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthLinkAbility_104651">();
	}
	static class UHealthLinkAbility_104651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthLinkAbility_104651>();
	}
};
static_assert(alignof(UHealthLinkAbility_104651) == 0x000008, "Wrong alignment on UHealthLinkAbility_104651");
static_assert(sizeof(UHealthLinkAbility_104651) == 0x001130, "Wrong size on UHealthLinkAbility_104651");
static_assert(offsetof(UHealthLinkAbility_104651, MinHealthRatio) == 0x001108, "Member 'UHealthLinkAbility_104651::MinHealthRatio' has a wrong offset!");
static_assert(offsetof(UHealthLinkAbility_104651, OwnerASC) == 0x001120, "Member 'UHealthLinkAbility_104651::OwnerASC' has a wrong offset!");
static_assert(offsetof(UHealthLinkAbility_104651, InstigatorASC) == 0x001128, "Member 'UHealthLinkAbility_104651::InstigatorASC' has a wrong offset!");

// Class Hero_1046.Cue_Scope_Loop_10465102
// 0x0050 (0x0D70 - 0x0D20)
class ACue_Scope_Loop_10465102 final : public AMarvelCueNotify_Scope
{
public:
	class UMaterialInterface*                     RangeMaterial;                                     // 0x0D20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalInnerRadius;                                  // 0x0D28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DecalVisible;                                      // 0x0D2C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2D[0x3];                                      // 0x0D2D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDecalSizeYZ;                                   // 0x0D30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D34[0x4];                                      // 0x0D34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ViewTarget;                                        // 0x0D38(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AScope_10465102*                        OwnerScope;                                        // 0x0D40(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAgentTraceComponent*             TraceComponent;                                    // 0x0D48(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0D50(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               RangeMID;                                          // 0x0D58(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        RangeDecal;                                        // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D68[0x8];                                      // 0x0D68(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10465102">();
	}
	static class ACue_Scope_Loop_10465102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10465102>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10465102) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10465102");
static_assert(sizeof(ACue_Scope_Loop_10465102) == 0x000D70, "Wrong size on ACue_Scope_Loop_10465102");
static_assert(offsetof(ACue_Scope_Loop_10465102, RangeMaterial) == 0x000D20, "Member 'ACue_Scope_Loop_10465102::RangeMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, DecalInnerRadius) == 0x000D28, "Member 'ACue_Scope_Loop_10465102::DecalInnerRadius' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, DecalVisible) == 0x000D2C, "Member 'ACue_Scope_Loop_10465102::DecalVisible' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, BaseDecalSizeYZ) == 0x000D30, "Member 'ACue_Scope_Loop_10465102::BaseDecalSizeYZ' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, ViewTarget) == 0x000D38, "Member 'ACue_Scope_Loop_10465102::ViewTarget' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, OwnerScope) == 0x000D40, "Member 'ACue_Scope_Loop_10465102::OwnerScope' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, TraceComponent) == 0x000D48, "Member 'ACue_Scope_Loop_10465102::TraceComponent' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, OwnerCharacter) == 0x000D50, "Member 'ACue_Scope_Loop_10465102::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, RangeMID) == 0x000D58, "Member 'ACue_Scope_Loop_10465102::RangeMID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10465102, RangeDecal) == 0x000D60, "Member 'ACue_Scope_Loop_10465102::RangeDecal' has a wrong offset!");

// Class Hero_1046.Cue_Ability_Loop_10465101
// 0x0058 (0x0E58 - 0x0E00)
class ACue_Ability_Loop_10465101 final : public AMarvelCueNotify_Ability
{
public:
	class UFXSystemAsset*                         LinkEffectTemplate;                                // 0x0E00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinkEffectOffset;                                  // 0x0E08(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinkEffectSocketName;                              // 0x0E20(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponAttachedSocketName;                          // 0x0E2C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbility_104651*                        OwnerAbility;                                      // 0x0E38(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0E40(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinkEffectPair>                LinkEffects;                                       // 0x0E48(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void SpawnLinkEffects(const TArray<class AActor*>& LinkTargets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10465101">();
	}
	static class ACue_Ability_Loop_10465101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10465101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10465101) == 0x000008, "Wrong alignment on ACue_Ability_Loop_10465101");
static_assert(sizeof(ACue_Ability_Loop_10465101) == 0x000E58, "Wrong size on ACue_Ability_Loop_10465101");
static_assert(offsetof(ACue_Ability_Loop_10465101, LinkEffectTemplate) == 0x000E00, "Member 'ACue_Ability_Loop_10465101::LinkEffectTemplate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, LinkEffectOffset) == 0x000E08, "Member 'ACue_Ability_Loop_10465101::LinkEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, LinkEffectSocketName) == 0x000E20, "Member 'ACue_Ability_Loop_10465101::LinkEffectSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, WeaponAttachedSocketName) == 0x000E2C, "Member 'ACue_Ability_Loop_10465101::WeaponAttachedSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, OwnerAbility) == 0x000E38, "Member 'ACue_Ability_Loop_10465101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, OwnerCharacter) == 0x000E40, "Member 'ACue_Ability_Loop_10465101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10465101, LinkEffects) == 0x000E48, "Member 'ACue_Ability_Loop_10465101::LinkEffects' has a wrong offset!");

// Class Hero_1046.Ability_104661
// 0x00D0 (0x5B60 - 0x5A90)
class UAbility_104661 : public UMarvelAeroBaseAbility
{
public:
	struct FTransform                             TraceStartTransform;                               // 0x5A90(0x0060)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             TraceEndTransform;                                 // 0x5AF0(0x0060)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ResurrectedActors;                                 // 0x5B50(0x0010)(BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	bool GetTraceTransform();
	void SetResurrectedActors(const TArray<int32>& InActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104661">();
	}
	static class UAbility_104661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104661>();
	}
};
static_assert(alignof(UAbility_104661) == 0x000010, "Wrong alignment on UAbility_104661");
static_assert(sizeof(UAbility_104661) == 0x005B60, "Wrong size on UAbility_104661");
static_assert(offsetof(UAbility_104661, TraceStartTransform) == 0x005A90, "Member 'UAbility_104661::TraceStartTransform' has a wrong offset!");
static_assert(offsetof(UAbility_104661, TraceEndTransform) == 0x005AF0, "Member 'UAbility_104661::TraceEndTransform' has a wrong offset!");
static_assert(offsetof(UAbility_104661, ResurrectedActors) == 0x005B50, "Member 'UAbility_104661::ResurrectedActors' has a wrong offset!");

// Class Hero_1046.ResurrectionAbility_10466101
// 0x0018 (0x1198 - 0x1180)
class UResurrectionAbility_10466101 : public UMarvelBaseResurrectionAbility
{
public:
	float                                         MaxResurrectionHeight;                             // 0x1180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResurrectionAreaRadius;                            // 0x1184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPositionSearchTime;                             // 0x1188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionDetectHeight;                             // 0x118C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathAnimationTime;                                // 0x1190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1194[0x4];                                     // 0x1194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResurrectionAbility_10466101">();
	}
	static class UResurrectionAbility_10466101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResurrectionAbility_10466101>();
	}
};
static_assert(alignof(UResurrectionAbility_10466101) == 0x000008, "Wrong alignment on UResurrectionAbility_10466101");
static_assert(sizeof(UResurrectionAbility_10466101) == 0x001198, "Wrong size on UResurrectionAbility_10466101");
static_assert(offsetof(UResurrectionAbility_10466101, MaxResurrectionHeight) == 0x001180, "Member 'UResurrectionAbility_10466101::MaxResurrectionHeight' has a wrong offset!");
static_assert(offsetof(UResurrectionAbility_10466101, ResurrectionAreaRadius) == 0x001184, "Member 'UResurrectionAbility_10466101::ResurrectionAreaRadius' has a wrong offset!");
static_assert(offsetof(UResurrectionAbility_10466101, MaxPositionSearchTime) == 0x001188, "Member 'UResurrectionAbility_10466101::MaxPositionSearchTime' has a wrong offset!");
static_assert(offsetof(UResurrectionAbility_10466101, OcclusionDetectHeight) == 0x00118C, "Member 'UResurrectionAbility_10466101::OcclusionDetectHeight' has a wrong offset!");
static_assert(offsetof(UResurrectionAbility_10466101, DeathAnimationTime) == 0x001190, "Member 'UResurrectionAbility_10466101::DeathAnimationTime' has a wrong offset!");

// Class Hero_1046.EffectAbility_104661
// 0x0008 (0x10F0 - 0x10E8)
class UEffectAbility_104661 : public UMarvelEffectGameplayAbility
{
public:
	uint8                                         Pad_10E8[0x8];                                     // 0x10E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StopKillCamImmediately(bool bSet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectAbility_104661">();
	}
	static class UEffectAbility_104661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectAbility_104661>();
	}
};
static_assert(alignof(UEffectAbility_104661) == 0x000008, "Wrong alignment on UEffectAbility_104661");
static_assert(sizeof(UEffectAbility_104661) == 0x0010F0, "Wrong size on UEffectAbility_104661");

// Class Hero_1046.Cue_Scope_Loop_10466101
// 0x0128 (0x0E48 - 0x0D20)
class ACue_Scope_Loop_10466101 final : public AMarvelCueNotify_Scope
{
public:
	float                                         UpdateFXInterval;                                  // 0x0D20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D24[0x4];                                      // 0x0D24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWidgetStyle_BattleTransientTip        TipEnter;                                          // 0x0D28(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FWidgetStyle_BattleTransientTip        TipLeave;                                          // 0x0D70(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB8[0x28];                                     // 0x0DB8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_104661*                        Ability_104661;                                    // 0x0DE0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           PreTracedActors;                                   // 0x0DE8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E38[0x10];                                     // 0x0E38(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10466101">();
	}
	static class ACue_Scope_Loop_10466101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10466101>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10466101) == 0x000008, "Wrong alignment on ACue_Scope_Loop_10466101");
static_assert(sizeof(ACue_Scope_Loop_10466101) == 0x000E48, "Wrong size on ACue_Scope_Loop_10466101");
static_assert(offsetof(ACue_Scope_Loop_10466101, UpdateFXInterval) == 0x000D20, "Member 'ACue_Scope_Loop_10466101::UpdateFXInterval' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10466101, TipEnter) == 0x000D28, "Member 'ACue_Scope_Loop_10466101::TipEnter' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10466101, TipLeave) == 0x000D70, "Member 'ACue_Scope_Loop_10466101::TipLeave' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10466101, Ability_104661) == 0x000DE0, "Member 'ACue_Scope_Loop_10466101::Ability_104661' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10466101, PreTracedActors) == 0x000DE8, "Member 'ACue_Scope_Loop_10466101::PreTracedActors' has a wrong offset!");

// Class Hero_1046.AdamWarlockSoulAnimData
// 0x0028 (0x0068 - 0x0040)
class UAdamWarlockSoulAnimData final : public UAnimationDataCollection
{
public:
	class UAnimSequence*                          Idle_Seq;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Ascending_Seq;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Hovering_2D;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Descending_2D;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Ascending_Lean_2D;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockSoulAnimData">();
	}
	static class UAdamWarlockSoulAnimData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamWarlockSoulAnimData>();
	}
};
static_assert(alignof(UAdamWarlockSoulAnimData) == 0x000008, "Wrong alignment on UAdamWarlockSoulAnimData");
static_assert(sizeof(UAdamWarlockSoulAnimData) == 0x000068, "Wrong size on UAdamWarlockSoulAnimData");
static_assert(offsetof(UAdamWarlockSoulAnimData, Idle_Seq) == 0x000040, "Member 'UAdamWarlockSoulAnimData::Idle_Seq' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulAnimData, Ascending_Seq) == 0x000048, "Member 'UAdamWarlockSoulAnimData::Ascending_Seq' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulAnimData, Hovering_2D) == 0x000050, "Member 'UAdamWarlockSoulAnimData::Hovering_2D' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulAnimData, Descending_2D) == 0x000058, "Member 'UAdamWarlockSoulAnimData::Descending_2D' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulAnimData, Ascending_Lean_2D) == 0x000060, "Member 'UAdamWarlockSoulAnimData::Ascending_Lean_2D' has a wrong offset!");

// Class Hero_1046.AdamWarlockSoulSubAnimInstance
// 0x00B0 (0x09B0 - 0x0900)
class UAdamWarlockSoulSubAnimInstance final : public UMarvelAnimInstance
{
public:
	float                                         VelocityZThreshold;                                // 0x0900(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccZThreshold;                                     // 0x0904(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAccTransition;                                 // 0x0908(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_909[0x7];                                      // 0x0909(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAdamWarlockSoulAnimData*               SoulFreeFlyData;                                   // 0x0910(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAccelerating;                                   // 0x0918(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInAscending;                                    // 0x0919(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInDescending;                                   // 0x091A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInHovering;                                     // 0x091B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x091C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanX;                                             // 0x0920(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanY;                                             // 0x0924(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLean;                                          // 0x0928(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_929[0x7];                                      // 0x0929(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MovingVelocityNormal;                              // 0x0930(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentAcceleration;                               // 0x0948(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentAccelerationNormal;                         // 0x0960(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Idle_Seq;                                          // 0x0978(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Ascending_Seq;                                     // 0x0980(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Hovering_2D;                                       // 0x0988(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Descending_2D;                                     // 0x0990(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Ascending_Lean_2D;                                 // 0x0998(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A0[0x10];                                     // 0x09A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockSoulSubAnimInstance">();
	}
	static class UAdamWarlockSoulSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamWarlockSoulSubAnimInstance>();
	}
};
static_assert(alignof(UAdamWarlockSoulSubAnimInstance) == 0x000010, "Wrong alignment on UAdamWarlockSoulSubAnimInstance");
static_assert(sizeof(UAdamWarlockSoulSubAnimInstance) == 0x0009B0, "Wrong size on UAdamWarlockSoulSubAnimInstance");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, VelocityZThreshold) == 0x000900, "Member 'UAdamWarlockSoulSubAnimInstance::VelocityZThreshold' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, AccZThreshold) == 0x000904, "Member 'UAdamWarlockSoulSubAnimInstance::AccZThreshold' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bUseAccTransition) == 0x000908, "Member 'UAdamWarlockSoulSubAnimInstance::bUseAccTransition' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, SoulFreeFlyData) == 0x000910, "Member 'UAdamWarlockSoulSubAnimInstance::SoulFreeFlyData' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bIsAccelerating) == 0x000918, "Member 'UAdamWarlockSoulSubAnimInstance::bIsAccelerating' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bIsInAscending) == 0x000919, "Member 'UAdamWarlockSoulSubAnimInstance::bIsInAscending' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bIsInDescending) == 0x00091A, "Member 'UAdamWarlockSoulSubAnimInstance::bIsInDescending' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bIsInHovering) == 0x00091B, "Member 'UAdamWarlockSoulSubAnimInstance::bIsInHovering' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, MaxSpeed) == 0x00091C, "Member 'UAdamWarlockSoulSubAnimInstance::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, LeanX) == 0x000920, "Member 'UAdamWarlockSoulSubAnimInstance::LeanX' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, LeanY) == 0x000924, "Member 'UAdamWarlockSoulSubAnimInstance::LeanY' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, bUseLean) == 0x000928, "Member 'UAdamWarlockSoulSubAnimInstance::bUseLean' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, MovingVelocityNormal) == 0x000930, "Member 'UAdamWarlockSoulSubAnimInstance::MovingVelocityNormal' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, CurrentAcceleration) == 0x000948, "Member 'UAdamWarlockSoulSubAnimInstance::CurrentAcceleration' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, CurrentAccelerationNormal) == 0x000960, "Member 'UAdamWarlockSoulSubAnimInstance::CurrentAccelerationNormal' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, Idle_Seq) == 0x000978, "Member 'UAdamWarlockSoulSubAnimInstance::Idle_Seq' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, Ascending_Seq) == 0x000980, "Member 'UAdamWarlockSoulSubAnimInstance::Ascending_Seq' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, Hovering_2D) == 0x000988, "Member 'UAdamWarlockSoulSubAnimInstance::Hovering_2D' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, Descending_2D) == 0x000990, "Member 'UAdamWarlockSoulSubAnimInstance::Descending_2D' has a wrong offset!");
static_assert(offsetof(UAdamWarlockSoulSubAnimInstance, Ascending_Lean_2D) == 0x000998, "Member 'UAdamWarlockSoulSubAnimInstance::Ascending_Lean_2D' has a wrong offset!");

// Class Hero_1046.AdamWarlockCharacter
// 0x0030 (0x17F0 - 0x17C0)
class AAdamWarlockCharacter : public AMarvelBaseCharacter
{
public:
	int32                                         ResurrectAbilityID;                                // 0x17B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfLinkTargets;                                  // 0x17BC(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FullGatherReleaseDispatcher;                       // 0x17C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAdamWarlockMoveLogicBaseComponent*     AdamWarlockMoveLogic;                              // 0x17D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17D8[0x18];                                    // 0x17D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignDeathCueTag(const struct FGameplayTag& InDeathCue);
	bool CanResurrectSelf(const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockCharacter">();
	}
	static class AAdamWarlockCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAdamWarlockCharacter>();
	}
};
static_assert(alignof(AAdamWarlockCharacter) == 0x000010, "Wrong alignment on AAdamWarlockCharacter");
static_assert(sizeof(AAdamWarlockCharacter) == 0x0017F0, "Wrong size on AAdamWarlockCharacter");
static_assert(offsetof(AAdamWarlockCharacter, ResurrectAbilityID) == 0x0017B8, "Member 'AAdamWarlockCharacter::ResurrectAbilityID' has a wrong offset!");
static_assert(offsetof(AAdamWarlockCharacter, NumOfLinkTargets) == 0x0017BC, "Member 'AAdamWarlockCharacter::NumOfLinkTargets' has a wrong offset!");
static_assert(offsetof(AAdamWarlockCharacter, FullGatherReleaseDispatcher) == 0x0017C0, "Member 'AAdamWarlockCharacter::FullGatherReleaseDispatcher' has a wrong offset!");
static_assert(offsetof(AAdamWarlockCharacter, AdamWarlockMoveLogic) == 0x0017D0, "Member 'AAdamWarlockCharacter::AdamWarlockMoveLogic' has a wrong offset!");

// Class Hero_1046.AdamWarlockMoveLogicBaseComponent
// 0x0000 (0x03F0 - 0x03F0)
class UAdamWarlockMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockMoveLogicBaseComponent">();
	}
	static class UAdamWarlockMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamWarlockMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UAdamWarlockMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UAdamWarlockMoveLogicBaseComponent");
static_assert(sizeof(UAdamWarlockMoveLogicBaseComponent) == 0x0003F0, "Wrong size on UAdamWarlockMoveLogicBaseComponent");

// Class Hero_1046.AdamWarlockMovementComponent
// 0x0000 (0x1AF0 - 0x1AF0)
class UAdamWarlockMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamWarlockMovementComponent">();
	}
	static class UAdamWarlockMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamWarlockMovementComponent>();
	}
};
static_assert(alignof(UAdamWarlockMovementComponent) == 0x000010, "Wrong alignment on UAdamWarlockMovementComponent");
static_assert(sizeof(UAdamWarlockMovementComponent) == 0x001AF0, "Wrong size on UAdamWarlockMovementComponent");

// Class Hero_1046.EpicMomentAction_1046
// 0x0040 (0x01B0 - 0x0170)
class UEpicMomentAction_1046 : public UEpicMomentAction_Treat
{
public:
	uint8                                         Pad_170[0x28];                                     // 0x0170(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    QConfig;                                           // 0x0198(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ResurrectedDelay;                                  // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfResurrectedActors;                            // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorResurrected(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierParameter& ModifierParameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1046">();
	}
	static class UEpicMomentAction_1046* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1046>();
	}
};
static_assert(alignof(UEpicMomentAction_1046) == 0x000008, "Wrong alignment on UEpicMomentAction_1046");
static_assert(sizeof(UEpicMomentAction_1046) == 0x0001B0, "Wrong size on UEpicMomentAction_1046");
static_assert(offsetof(UEpicMomentAction_1046, QConfig) == 0x000198, "Member 'UEpicMomentAction_1046::QConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1046, ResurrectedDelay) == 0x0001A4, "Member 'UEpicMomentAction_1046::ResurrectedDelay' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1046, NumOfResurrectedActors) == 0x0001A8, "Member 'UEpicMomentAction_1046::NumOfResurrectedActors' has a wrong offset!");

}

